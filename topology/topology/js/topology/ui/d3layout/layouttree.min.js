LayoutTree = function() {
	this.version = "0.1.0";
	this.config = {
		maxDepth : 100,
		levelDistance : 40,
		siblingDistance : 40,
		subtreeDistance : 50,
		orientation : LayoutTree.O_TOP,
		nodeJustification : LayoutTree.NJ_TOP,
		defaultNodeWidth : 40,
		defaultNodeHeight : 40
	};
	this.self = this;
	this.maxLevelHeight = [];
	this.maxLevelWidth = [];
	this.previousLevelNode = [];
	this.nDatabaseNodes = [];
	this.mapIDs = {};
	this.depth = 0;
	this.root = new LayoutNode(-1, null, 0, 0);
	this.root.level = 0
};
LayoutTree.O_TOP = 0;
LayoutTree.O_BOTTOM = 1;
LayoutTree.O_RIGHT = 2;
LayoutTree.O_LEFT = 3;
LayoutTree.NJ_TOP = 0;
LayoutTree.NJ_CENTER = 1;
LayoutTree.NJ_BOTTOM = 2;
LayoutTree.prototype = {
	updateTree : function() {
		this.positionTree()
	},
	add : function(id, pid, w, h) {
		if (String(id) === String(pid)) {
			throw new Error("添加节点[" + id + "]失败，节点id不能和父节点id相同")
		}
		var nw = Number(w) || this.config.defaultNodeWidth;
		var nh = Number(h) || this.config.defaultNodeHeight;
		var pnode = null;
		if (pid == -1) {
			pnode = this.root
		} else {
			for (var k = 0; k < this.nodes().length; k++) {
				if (this.nodes()[k].id == pid) {
					pnode = this.nodes()[k];
					break
				}
			}
		}
		if (pnode == null) {
			throw new Error("添加节点[" + id + "]失败，父节点[" + pid + "]不存在")
		}
		var node = new LayoutNode(id, pid, nw, nh);
		node.nodeParent = pnode;
		var i = this.nodes().length;
		node.dbIndex = this.mapIDs[id] = i;
		this.nDatabaseNodes[i] = node;
		var h = pnode.nodeChildren.length;
		node.siblingIndex = h;
		pnode.nodeChildren[h] = node;
		node.level = pnode.level + 1;
		this.depth = Math.max(this.depth, node.level)
	},
	nodes : function() {
		return this.nDatabaseNodes
	},
	_firstWalk : function(node, level) {
		var leftSibling = null;
		node.x = 0;
		node.y = 0;
		node.prelim = 0;
		node.modifier = 0;
		node.leftNeighbor = null;
		node.rightNeighbor = null;
		this._setLevelHeight(node, level);
		this._setLevelWidth(node, level);
		this._setNeighbors(node, level);
		if (node.getChildrenCount() == 0 || level == this.config.maxDepth) {
			leftSibling = node.getLeftSibling();
			if (leftSibling != null) {
				node.prelim = leftSibling.prelim
						+ this.getNodeSize(leftSibling)
						+ this.config.siblingDistance
			} else {
				node.prelim = 0
			}
		} else {
			var n = node.getChildrenCount();
			for (var i = 0; i < n; i++) {
				var iChild = node.getChildAt(i);
				this._firstWalk(iChild, level + 1)
			}
			var midPoint = node.getChildrenCenter(this.self);
			midPoint -= this.getNodeSize(node) / 2;
			leftSibling = node.getLeftSibling();
			if (leftSibling != null) {
				node.prelim = leftSibling.prelim
						+ this.getNodeSize(leftSibling)
						+ this.config.siblingDistance;
				node.modifier = node.prelim - midPoint;
				this._apportion(node, level)
			} else {
				node.prelim = midPoint
			}
		}
	},
	_apportion : function(node, level) {
		var firstChild = node.getFirstChild();
		var firstChildLeftNeighbor = firstChild.leftNeighbor;
		var j = 1;
		for (var k = this.config.maxDepth - level; firstChild != null
				&& firstChildLeftNeighbor != null && j <= k;) {
			var modifierSumRight = 0;
			var modifierSumLeft = 0;
			var rightAncestor = firstChild;
			var leftAncestor = firstChildLeftNeighbor;
			for (var l = 0; l < j; l++) {
				rightAncestor = rightAncestor.nodeParent;
				leftAncestor = leftAncestor.nodeParent;
				modifierSumRight += rightAncestor.modifier;
				modifierSumLeft += leftAncestor.modifier
			}
			var totalGap = (firstChildLeftNeighbor.prelim + modifierSumLeft
					+ this.getNodeSize(firstChildLeftNeighbor) + this.config.subtreeDistance)
					- (firstChild.prelim + modifierSumRight);
			if (totalGap > 0) {
				var subtreeAux = node;
				var numSubtrees = 0;
				for (; subtreeAux != null && subtreeAux != leftAncestor; subtreeAux = subtreeAux
						.getLeftSibling()) {
					numSubtrees++
				}
				if (subtreeAux != null) {
					var subtreeMoveAux = node;
					var singleGap = totalGap / numSubtrees;
					for (; subtreeMoveAux != leftAncestor; subtreeMoveAux = subtreeMoveAux
							.getLeftSibling()) {
						subtreeMoveAux.prelim += totalGap;
						subtreeMoveAux.modifier += totalGap;
						totalGap -= singleGap
					}
				}
			}
			j++;
			if (firstChild.getChildrenCount() == 0) {
				firstChild = this._getLeftmost(node, 0, j)
			} else {
				firstChild = firstChild.getFirstChild()
			}
			if (firstChild != null) {
				firstChildLeftNeighbor = firstChild.leftNeighbor
			}
		}
	},
	_secondWalk : function(node, level, X, Y) {
		if (level <= this.config.maxDepth) {
			var xTmp = node.prelim + X;
			var yTmp = Y;
			var maxsizeTmp = 0;
			var nodesizeTmp = 0;
			var flag = false;
			switch (this.config.orientation) {
			case LayoutTree.O_TOP:
			case LayoutTree.O_BOTTOM:
				maxsizeTmp = this.maxLevelHeight[level];
				if (level == 0) {
					maxsizeTmp -= this.maxLevelHeight[1]
				}
				nodesizeTmp = node.h;
				break;
			case LayoutTree.O_RIGHT:
			case LayoutTree.O_LEFT:
				maxsizeTmp = this.maxLevelWidth[level];
				if (level == 0) {
					maxsizeTmp -= this.maxLevelWidth[1]
				}
				flag = true;
				nodesizeTmp = node.w;
				break
			}
			switch (this.config.nodeJustification) {
			case LayoutTree.NJ_TOP:
				node.x = xTmp;
				node.y = yTmp;
				break;
			case LayoutTree.NJ_CENTER:
				node.x = xTmp;
				node.y = yTmp + (maxsizeTmp - nodesizeTmp) / 2;
				break;
			case LayoutTree.NJ_BOTTOM:
				node.x = xTmp;
				node.y = (yTmp + maxsizeTmp) - nodesizeTmp;
				break
			}
			if (flag) {
				var swapTmp = node.x;
				node.x = node.y;
				node.y = swapTmp
			}
			switch (this.config.orientation) {
			case LayoutTree.O_BOTTOM:
				node.y = -node.y - nodesizeTmp;
				break;
			case LayoutTree.O_RIGHT:
				node.x = -node.x - nodesizeTmp;
				break
			}
			if (node.getChildrenCount() != 0) {
				this._secondWalk(node.getFirstChild(), level + 1, X
						+ node.modifier, Y + maxsizeTmp
						+ this.config.levelDistance)
			}
			var rightSibling = node.getRightSibling();
			if (rightSibling != null) {
				this._secondWalk(rightSibling, level, X, Y)
			}
		}
	},
	_positionLinks : function() {
		for (var n = 0; n < this.nodes().length; n++) {
			this.nodes()[n].positionChildrenLinks(this.self)
		}
	},
	positionTree : function() {
		this.maxLevelHeight = [];
		this.maxLevelWidth = [];
		this.previousLevelNode = [];
		this._firstWalk(this.root, 0);
		this._secondWalk(this.root, 0, 0, 0);
		this._positionLinks()
	},
	_setLevelHeight : function(node, level) {
		if (this.maxLevelHeight[level] == null) {
			this.maxLevelHeight[level] = 0
		}
		if (this.maxLevelHeight[level] < node.h) {
			this.maxLevelHeight[level] = node.h
		}
	},
	_setLevelWidth : function(node, level) {
		if (this.maxLevelWidth[level] == null) {
			this.maxLevelWidth[level] = 0
		}
		if (this.maxLevelWidth[level] < node.w) {
			this.maxLevelWidth[level] = node.w
		}
	},
	_setNeighbors : function(node, level) {
		node.leftNeighbor = this.previousLevelNode[level];
		if (node.leftNeighbor != null) {
			node.leftNeighbor.rightNeighbor = node
		}
		this.previousLevelNode[level] = node
	},
	getNodeSize : function(node) {
		switch (this.config.orientation) {
		case LayoutTree.O_TOP:
		case LayoutTree.O_BOTTOM:
			return Number(node.w);
		case LayoutTree.O_RIGHT:
		case LayoutTree.O_LEFT:
			return Number(node.h)
		}
		return 0
	},
	_getLeftmost : function(node, level, maxlevel) {
		if (level >= maxlevel) {
			return node
		}
		if (node.getChildrenCount() == 0) {
			return null
		}
		var n = node.getChildrenCount();
		for (var i = 0; i < n; i++) {
			var iChild = node.getChildAt(i);
			var leftmostDescendant = this._getLeftmost(iChild, level + 1,
					maxlevel);
			if (leftmostDescendant != null) {
				return leftmostDescendant
			}
		}
		return null
	},
	toString : function() {
		var s = [];
		this.positionTree();
		for (var i = 0; i < this.nodes().length; i++) {
			s.push(this.nodes()[i])
		}
		return "[" + s.join(",") + "]"
	}
};
LayoutNode = function(id, pid, w, h) {
	this.id = id;
	this.pid = pid;
	this.w = Number(w);
	this.h = Number(h);
	this.siblingIndex = 0;
	this.dbIndex = 0;
	this.level = null;
	this.x = 0;
	this.y = 0;
	this.prelim = 0;
	this.modifier = 0;
	this.leftNeighbor = null;
	this.rightNeighbor = null;
	this.nodeParent = null;
	this.nodeChildren = [];
	this.links = []
};
LayoutNode.prototype = {
	getLevel : function() {
		if (this.nodeParent.id == -1) {
			return 0
		} else {
			return this.nodeParent.getLevel() + 1
		}
	},
	getCenterCoords : function(tree) {
		var x = 0, y = 0;
		x = this.x + (this.w / 2);
		y = this.y + (this.h / 2);
		return {
			x : x,
			y : y
		}
	},
	isAncestorCollapsed : function() {
		if (this.nodeParent.isCollapsed) {
			return true
		} else {
			if (this.nodeParent.id == -1) {
				return false
			} else {
				return this.nodeParent.isAncestorCollapsed()
			}
		}
	},
	setAncestorsExpanded : function() {
		if (this.nodeParent.id == -1) {
			return

		} else {
			this.nodeParent.isCollapsed = false;
			return this.nodeParent.setAncestorsExpanded()
		}
	},
	getChildrenCount : function() {
		if (this.nodeChildren == null) {
			return 0
		} else {
			return this.nodeChildren.length
		}
	},
	getLeftSibling : function() {
		if (this.leftNeighbor != null
				&& this.leftNeighbor.nodeParent == this.nodeParent) {
			return this.leftNeighbor
		} else {
			return null
		}
	},
	getRightSibling : function() {
		if (this.rightNeighbor != null
				&& this.rightNeighbor.nodeParent == this.nodeParent) {
			return this.rightNeighbor
		} else {
			return null
		}
	},
	getChildAt : function(i) {
		return this.nodeChildren[i]
	},
	getChildrenCenter : function(tree) {
		node = this.getFirstChild();
		node1 = this.getLastChild();
		return node.prelim
				+ ((node1.prelim - node.prelim) + tree.getNodeSize(node1)) / 2
	},
	getFirstChild : function() {
		return this.getChildAt(0)
	},
	getLastChild : function() {
		return this.getChildAt(this.getChildrenCount() - 1)
	},
	positionChildrenLinks : function(tree) {
		var s = [];
		var xa = 0, ya = 0, xb = 0, yb = 0, xc = 0, yc = 0, xd = 0, yd = 0;
		var node1 = null;
		switch (tree.config.orientation) {
		case LayoutTree.O_TOP:
			xa = this.x + (this.w / 2);
			ya = this.y + this.h;
			break;
		case LayoutTree.O_BOTTOM:
			xa = this.x + (this.w / 2);
			ya = this.y;
			break;
		case LayoutTree.O_RIGHT:
			xa = this.x;
			ya = this.y + (this.h / 2);
			break;
		case LayoutTree.O_LEFT:
			xa = this.x + this.w;
			ya = this.y + (this.h / 2);
			break
		}
		for (var k = 0; k < this.nodeChildren.length; k++) {
			node1 = this.nodeChildren[k];
			switch (tree.config.orientation) {
			case LayoutTree.O_TOP:
				xd = xc = node1.x + (node1.w / 2);
				yd = node1.y;
				xb = xa;
				switch (tree.config.nodeJustification) {
				case LayoutTree.NJ_TOP:
					yb = yc = yd - tree.config.levelDistance / 2;
					break;
				case LayoutTree.NJ_BOTTOM:
					yb = yc = ya + tree.config.levelDistance / 2;
					break;
				case LayoutTree.NJ_CENTER:
					yb = yc = ya + (yd - ya) / 2;
					break
				}
				break;
			case LayoutTree.O_BOTTOM:
				xd = xc = node1.x + (node1.w / 2);
				yd = node1.y + node1.h;
				xb = xa;
				switch (tree.config.nodeJustification) {
				case LayoutTree.NJ_TOP:
					yb = yc = yd + tree.config.levelDistance / 2;
					break;
				case LayoutTree.NJ_BOTTOM:
					yb = yc = ya - tree.config.levelDistance / 2;
					break;
				case LayoutTree.NJ_CENTER:
					yb = yc = yd + (ya - yd) / 2;
					break
				}
				break;
			case LayoutTree.O_RIGHT:
				xd = node1.x + node1.w;
				yd = yc = node1.y + (node1.h / 2);
				yb = ya;
				switch (tree.config.nodeJustification) {
				case LayoutTree.NJ_TOP:
					xb = xc = xd + tree.config.levelDistance / 2;
					break;
				case LayoutTree.NJ_BOTTOM:
					xb = xc = xa - tree.config.levelDistance / 2;
					break;
				case LayoutTree.NJ_CENTER:
					xb = xc = xd + (xa - xd) / 2;
					break
				}
				break;
			case LayoutTree.O_LEFT:
				xd = node1.x;
				yd = yc = node1.y + (node1.h / 2);
				yb = ya;
				switch (tree.config.nodeJustification) {
				case LayoutTree.NJ_TOP:
					xb = xc = xd - tree.config.levelDistance / 2;
					break;
				case LayoutTree.NJ_BOTTOM:
					xb = xc = xa + tree.config.levelDistance / 2;
					break;
				case LayoutTree.NJ_CENTER:
					xb = xc = xa + (xd - xa) / 2;
					break
				}
				break
			}
			var c = this.getCenterCoords(tree);
			var c1 = node1.getCenterCoords(tree);
			var p = {
				from : this.id,
				to : node1.id,
				fromx : c.x,
				fromy : c.y,
				tox : c1.x,
				toy : c1.y,
				x1 : xa,
				y1 : ya,
				x2 : xb,
				y2 : yb,
				x3 : xc,
				y3 : yc,
				x4 : xd,
				y4 : yd
			};
			s.push(p)
		}
		this.links = s;
		return s
	},
	toString : function() {
		return "{id:" + this.id + ",pid:" + this.pid + ",x:" + this.x + ",y:"
				+ this.y + "}"
	}
};