d3 = function() {
	var d3 = {
		version: "3.0.8"
	},
		d3_window = window;

	function d3_class(ctor, properties) {
		try {
			for (var key in properties) {
				Object.defineProperty(ctor.prototype, key, {
					value: properties[key],
					enumerable: false
				})
			}
		} catch (e) {
			ctor.prototype = properties
		}
	}
	d3.inArray = function(value, array) {
		if (array.indexOf) {
			return array.indexOf(value)
		}
		for (var i = 0, imax = array.length; i < imax; i++) {
			if (array[i] === value) {
				return i
			}
		}
		return -1
	};
	d3.each = function(object, callback) {
		var o = object;
		if (typeof o !== "object" && typeof o !== "array") {
			throw new TypeError("d3.forEach: only allow object and array")
		}
		var thisp = arguments[2];
		if (typeof callback !== "function") {
			throw new TypeError("d3.forEach: no callback or callback is not a callable function")
		}
		for (i in o) {
			callback.call(thisp, i, o[i], o)
		}
	};
	d3.map = function(object) {
		var map = new d3_Map;
		for (var key in object) {
			map.set(key, object[key])
		}
		return map
	};

	function d3_Map() {}
	d3_class(d3_Map, {
		has: function(key) {
			return d3_map_prefix + key in this
		},
		get: function(key) {
			return this[d3_map_prefix + key]
		},
		set: function(key, value) {
			return this[d3_map_prefix + key] = value
		},
		remove: function(key) {
			key = d3_map_prefix + key;
			return key in this && delete this[key]
		},
		keys: function() {
			var keys = [];
			this.forEach(function(key) {
				keys.push(key)
			});
			return keys
		},
		values: function() {
			var values = [];
			this.forEach(function(key, value) {
				values.push(value)
			});
			return values
		},
		entries: function() {
			var entries = [];
			this.forEach(function(key, value) {
				entries.push({
					key: key,
					value: value
				})
			});
			return entries
		},
		forEach: function(f) {
			for (var key in this) {
				if (key.charCodeAt(0) === d3_map_prefixCode) {
					f.call(this, key.substring(1), this[key])
				}
			}
		}
	});
	var d3_map_prefix = "\0",
		d3_map_prefixCode = d3_map_prefix.charCodeAt(0);
	var d3_timer_id = 0,
		d3_timer_byId = {},
		d3_timer_queue = null,
		d3_timer_interval, d3_timer_timeout;
	d3.timer = function(callback, delay, then) {
		if (arguments.length < 3) {
			if (arguments.length < 2) {
				delay = 0
			} else {
				if (!isFinite(delay)) {
					return
				}
			}
			then = Date.now()
		}
		var timer = d3_timer_byId[callback.id];
		if (timer && timer.callback === callback) {
			timer.then = then;
			timer.delay = delay
		} else {
			d3_timer_byId[callback.id = ++d3_timer_id] = d3_timer_queue = {
				callback: callback,
				then: then,
				delay: delay,
				next: d3_timer_queue
			}
		}
		if (!d3_timer_interval) {
			d3_timer_timeout = clearTimeout(d3_timer_timeout);
			d3_timer_interval = 1;
			d3_timer_frame(d3_timer_step)
		}
	};

	function d3_timer_step() {
		var elapsed, now = Date.now(),
			t1 = d3_timer_queue;
		while (t1) {
			elapsed = now - t1.then;
			if (elapsed >= t1.delay) {
				t1.flush = t1.callback(elapsed)
			}
			t1 = t1.next
		}
		var delay = d3_timer_flush() - now;
		if (delay > 24) {
			if (isFinite(delay)) {
				clearTimeout(d3_timer_timeout);
				d3_timer_timeout = setTimeout(d3_timer_step, delay)
			}
			d3_timer_interval = 0
		} else {
			d3_timer_interval = 1;
			d3_timer_frame(d3_timer_step)
		}
	}
	d3.timer.flush = function() {
		var elapsed, now = Date.now(),
			t1 = d3_timer_queue;
		while (t1) {
			elapsed = now - t1.then;
			if (!t1.delay) {
				t1.flush = t1.callback(elapsed)
			}
			t1 = t1.next
		}
		d3_timer_flush()
	};

	function d3_timer_flush() {
		var t0 = null,
			t1 = d3_timer_queue,
			then = Infinity;
		while (t1) {
			if (t1.flush) {
				delete d3_timer_byId[t1.callback.id];
				t1 = t0 ? t0.next = t1.next : d3_timer_queue = t1.next
			} else {
				then = Math.min(then, t1.then + t1.delay);
				t1 = (t0 = t1).next
			}
		}
		return then
	}
	var d3_timer_frame = d3_window.requestAnimationFrame || d3_window.webkitRequestAnimationFrame || d3_window.mozRequestAnimationFrame || d3_window.oRequestAnimationFrame || d3_window.msRequestAnimationFrame ||
	function(callback) {
		setTimeout(callback, 17)
	};
	d3.dispatch = function() {
		var dispatch = new d3_dispatch,
			i = -1,
			n = arguments.length;
		while (++i < n) {
			dispatch[arguments[i]] = d3_dispatch_event(dispatch)
		}
		return dispatch
	};

	function d3_dispatch() {}
	d3_dispatch.prototype.on = function(type, listener) {
		var i = type.indexOf("."),
			name = "";
		if (i > 0) {
			name = type.substring(i + 1);
			type = type.substring(0, i)
		}
		return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener)
	};

	function d3_dispatch_event(dispatch) {
		var listeners = [],
			listenerByName = new d3_Map;

		function event() {
			var z = listeners,
				i = -1,
				n = z.length,
				l;
			while (++i < n) {
				if (l = z[i].on) {
					l.apply(this, arguments)
				}
			}
			return dispatch
		}
		event.on = function(name, listener) {
			var l = listenerByName.get(name),
				i;
			if (arguments.length < 2) {
				return l && l.on
			}
			if (l) {
				l.on = null;
				listeners = listeners.slice(0, i = d3.inArray(l, listeners)).concat(listeners.slice(i + 1));
				listenerByName.remove(name)
			}
			if (listener) {
				listeners.push(listenerByName.set(name, {
					on: listener
				}))
			}
			return dispatch
		};
		return event
	}
	d3.rebind = function(target, source) {
		var i = 1,
			n = arguments.length,
			method;
		while (++i < n) {
			target[method = arguments[i]] = d3_rebind(target, source, source[method])
		}
		return target
	};

	function d3_rebind(target, source, method) {
		return function() {
			var value = method.apply(source, arguments);
			return value === source ? target : value
		}
	}
	d3.geom = {};
	d3.geom.quadtree = function(points, x1, y1, x2, y2) {
		var p, i = -1,
			n = points.length;
		if (arguments.length < 5) {
			if (arguments.length === 3) {
				y2 = y1;
				x2 = x1;
				y1 = x1 = 0
			} else {
				x1 = y1 = Infinity;
				x2 = y2 = -Infinity;
				while (++i < n) {
					p = points[i];
					if (p.x < x1) {
						x1 = p.x
					}
					if (p.y < y1) {
						y1 = p.y
					}
					if (p.x > x2) {
						x2 = p.x
					}
					if (p.y > y2) {
						y2 = p.y
					}
				}
			}
		}
		var dx = x2 - x1,
			dy = y2 - y1;
		if (dx > dy) {
			y2 = y1 + dx
		} else {
			x2 = x1 + dy
		}
		function insert(n, p, x1, y1, x2, y2) {
			if (isNaN(p.x) || isNaN(p.y)) {
				return
			}
			if (n.leaf) {
				var v = n.point;
				if (v) {
					if ((Math.abs(v.x - p.x) + Math.abs(v.y - p.y)) < 0.01) {
						insertChild(n, p, x1, y1, x2, y2)
					} else {
						n.point = null;
						insertChild(n, v, x1, y1, x2, y2);
						insertChild(n, p, x1, y1, x2, y2)
					}
				} else {
					n.point = p
				}
			} else {
				insertChild(n, p, x1, y1, x2, y2)
			}
		}
		function insertChild(n, p, x1, y1, x2, y2) {
			var sx = (x1 + x2) * 0.5,
				sy = (y1 + y2) * 0.5,
				right = p.x >= sx,
				bottom = p.y >= sy,
				i = (bottom << 1) + right;
			n.leaf = false;
			n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
			if (right) {
				x1 = sx
			} else {
				x2 = sx
			}
			if (bottom) {
				y1 = sy
			} else {
				y2 = sy
			}
			insert(n, p, x1, y1, x2, y2)
		}
		var root = d3_geom_quadtreeNode();
		root.add = function(p) {
			insert(root, p, x1, y1, x2, y2)
		};
		root.visit = function(f) {
			d3_geom_quadtreeVisit(f, root, x1, y1, x2, y2)
		};
		d3.each(points, function(k, v) {
			root.add(v)
		});
		return root
	};

	function d3_geom_quadtreeNode() {
		return {
			leaf: true,
			nodes: [],
			point: null
		}
	}
	function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
		if (!f(node, x1, y1, x2, y2)) {
			var sx = (x1 + x2) * 0.5,
				sy = (y1 + y2) * 0.5,
				children = node.nodes;
			if (children[0]) {
				d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy)
			}
			if (children[1]) {
				d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy)
			}
			if (children[2]) {
				d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2)
			}
			if (children[3]) {
				d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2)
			}
		}
	}
	d3.layout = {};
	d3.layout.force = function() {
		var force = {},
			event = d3.dispatch("start", "tick", "end"),
			size = [1, 1],
			drag, alpha, friction = 0.9,
			linkDistance = d3_layout_forceLinkDistance,
			linkStrength = d3_layout_forceLinkStrength,
			charge = -30,
			gravity = 0.1,
			theta = 0.8,
			nodes = [],
			links = [],
			distances, strengths, charges;

		function repulse(node) {
			return function(quad, x1, _, x2) {
				if (quad.point !== node) {
					var dx = quad.cx - node.x,
						dy = quad.cy - node.y,
						dn = 1 / Math.sqrt(dx * dx + dy * dy);
					if ((x2 - x1) * dn < theta) {
						var k = quad.charge * dn * dn;
						node.px -= dx * k;
						node.py -= dy * k;
						return true
					}
					if (quad.point && isFinite(dn)) {
						var k = quad.pointCharge * dn * dn;
						node.px -= dx * k;
						node.py -= dy * k
					}
				}
				return !quad.charge
			}
		}
		force.tick = function() {
			if ((alpha *= 0.99) < 0.005) {
				event.end({
					type: "end",
					alpha: alpha = 0
				});
				return true
			}
			var n = nodes.length,
				m = links.length,
				q, i, o, s, t, l, k, x, y;
			for (i = 0; i < m; ++i) {
				o = links[i];
				s = o.source;
				t = o.target;
				x = t.x - s.x;
				y = t.y - s.y;
				if (l = (x * x + y * y)) {
					l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
					x *= l;
					y *= l;
					t.x -= x * (k = s.weight / (t.weight + s.weight));
					t.y -= y * k;
					s.x += x * (k = 1 - k);
					s.y += y * k
				}
			}
			if (k = alpha * gravity) {
				x = size[0] / 2;
				y = size[1] / 2;
				i = -1;
				if (k) {
					while (++i < n) {
						o = nodes[i];
						o.x += (x - o.x) * k;
						o.y += (y - o.y) * k
					}
				}
			}
			if (charge) {
				d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
				i = -1;
				while (++i < n) {
					if (!(o = nodes[i]).fixed) {
						q.visit(repulse(o))
					}
				}
			}
			i = -1;
			while (++i < n) {
				o = nodes[i];
				if (o.fixed) {
					o.x = o.px;
					o.y = o.py
				} else {
					o.x -= (o.px - (o.px = o.x)) * friction;
					o.y -= (o.py - (o.py = o.y)) * friction
				}
			}
			event.tick({
				type: "tick",
				alpha: alpha
			})
		};
		force.nodes = function(x) {
			if (!arguments.length) {
				return nodes
			}
			nodes = x;
			return force
		};
		force.links = function(x) {
			if (!arguments.length) {
				return links
			}
			links = x;
			return force
		};
		force.size = function(x) {
			if (!arguments.length) {
				return size
			}
			size = x;
			return force
		};
		force.linkDistance = function(x) {
			if (!arguments.length) {
				return linkDistance
			}
			linkDistance = typeof x === "function" ? x : +x;
			return force
		};
		force.distance = force.linkDistance;
		force.linkStrength = function(x) {
			if (!arguments.length) {
				return linkStrength
			}
			linkStrength = typeof x === "function" ? x : +x;
			return force
		};
		force.friction = function(x) {
			if (!arguments.length) {
				return friction
			}
			friction = +x;
			return force
		};
		force.charge = function(x) {
			if (!arguments.length) {
				return charge
			}
			charge = typeof x === "function" ? x : +x;
			return force
		};
		force.gravity = function(x) {
			if (!arguments.length) {
				return gravity
			}
			gravity = +x;
			return force
		};
		force.theta = function(x) {
			if (!arguments.length) {
				return theta
			}
			theta = +x;
			return force
		};
		force.alpha = function(x) {
			if (!arguments.length) {
				return alpha
			}
			x = +x;
			if (alpha) {
				if (x > 0) {
					alpha = x
				} else {
					alpha = 0
				}
			} else {
				if (x > 0) {
					event.start({
						type: "start",
						alpha: alpha = x
					});
					d3.timer(force.tick)
				}
			}
			return force
		};
		force.start = function() {
			var i, j, n = nodes.length,
				m = links.length,
				w = size[0],
				h = size[1],
				neighbors, o;
			for (i = 0; i < n; ++i) {
				(o = nodes[i]).index = i;
				o.weight = 0
			}
			for (i = 0; i < m; ++i) {
				o = links[i];
				if (typeof o.source == "number") {
					o.source = nodes[o.source]
				}
				if (typeof o.target == "number") {
					o.target = nodes[o.target]
				}++o.source.weight;
				++o.target.weight
			}
			for (i = 0; i < n; ++i) {
				o = nodes[i];
				if (isNaN(o.x)) {
					o.x = position("x", w)
				}
				if (isNaN(o.y)) {
					o.y = position("y", h)
				}
				if (isNaN(o.px)) {
					o.px = o.x
				}
				if (isNaN(o.py)) {
					o.py = o.y
				}
			}
			distances = [];
			if (typeof linkDistance === "function") {
				for (i = 0; i < m; ++i) {
					distances[i] = +linkDistance.call(this, links[i], i)
				}
			} else {
				for (i = 0; i < m; ++i) {
					distances[i] = linkDistance
				}
			}
			strengths = [];
			if (typeof linkStrength === "function") {
				for (i = 0; i < m; ++i) {
					strengths[i] = +linkStrength.call(this, links[i], i)
				}
			} else {
				for (i = 0; i < m; ++i) {
					strengths[i] = linkStrength
				}
			}
			charges = [];
			if (typeof charge === "function") {
				for (i = 0; i < n; ++i) {
					charges[i] = +charge.call(this, nodes[i], i)
				}
			} else {
				for (i = 0; i < n; ++i) {
					charges[i] = charge
				}
			}
			function position(dimension, size) {
				var neighbors = neighbor(i),
					j = -1,
					m = neighbors.length,
					x;
				while (++j < m) {
					if (!isNaN(x = neighbors[j][dimension])) {
						return x
					}
				}
				return Math.random() * size
			}
			function neighbor() {
				if (!neighbors) {
					neighbors = [];
					for (j = 0; j < n; ++j) {
						neighbors[j] = []
					}
					for (j = 0; j < m; ++j) {
						var o = links[j];
						neighbors[o.source.index].push(o.target);
						neighbors[o.target.index].push(o.source)
					}
				}
				return neighbors[i]
			}
			return force.resume()
		};
		force.resume = function() {
			return force.alpha(0.1)
		};
		force.stop = function() {
			return force.alpha(0)
		};
		force.drag = function() {
			if (!drag) {
				drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend)
			}
			if (!arguments.length) {
				return drag
			}
			this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag)
		};

		function dragmove(d) {
			d.px = d3.event.x, d.py = d3.event.y;
			force.resume()
		}
		return d3.rebind(force, event, "on")
	};

	function d3_layout_forceDragstart(d) {
		d.fixed |= 2
	}
	function d3_layout_forceDragend(d) {
		d.fixed &= ~6
	}
	function d3_layout_forceMouseover(d) {
		d.fixed |= 4;
		d.px = d.x, d.py = d.y
	}
	function d3_layout_forceMouseout(d) {
		d.fixed &= ~4
	}
	function d3_layout_forceAccumulate(quad, alpha, charges) {
		var cx = 0,
			cy = 0;
		quad.charge = 0;
		if (!quad.leaf) {
			var nodes = quad.nodes,
				n = nodes.length,
				i = -1,
				c;
			while (++i < n) {
				c = nodes[i];
				if (c == null) {
					continue
				}
				d3_layout_forceAccumulate(c, alpha, charges);
				quad.charge += c.charge;
				cx += c.charge * c.cx;
				cy += c.charge * c.cy
			}
		}
		if (quad.point) {
			if (!quad.leaf) {
				quad.point.x += Math.random() - 0.5;
				quad.point.y += Math.random() - 0.5
			}
			var k = alpha * charges[quad.point.index];
			quad.charge += quad.pointCharge = k;
			cx += k * quad.point.x;
			cy += k * quad.point.y
		}
		quad.cx = cx / quad.charge;
		quad.cy = cy / quad.charge
	}
	var d3_layout_forceLinkDistance = 20,
		d3_layout_forceLinkStrength = 1;
	return d3
}();
aight4d3 = function() {
	if (!Date.now) {
		Date.now = function now() {
			return new Date().getTime()
		}
	}
	if (!Function.prototype.bind) {
		Function.prototype.bind = function bind(that) {
			var target = this;
			if (typeof target != "function") {
				throw new TypeError("Function.prototype.bind called on incompatible " + target)
			}
			var args = slice.call(arguments, 1);
			var bound = function() {
					if (this instanceof bound) {
						var F = function() {};
						F.prototype = target.prototype;
						var self = new F;
						var result = target.apply(self, args.concat(slice.call(arguments)));
						if (Object(result) === result) {
							return result
						}
						return self
					} else {
						return target.apply(that, args.concat(slice.call(arguments)))
					}
				};
			return bound
		}
	}
	var call = Function.prototype.call
}();