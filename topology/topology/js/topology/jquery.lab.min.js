(function($) {
    function Laboratory() {}
    $.extend(Laboratory.prototype, {
        topo: new LabTopology(),
        event: new LabEvent(),
        menu: new LabMenu(),
        exp: new LabExport(),
        ui: new LabUI(),
        direct: new LabDirect(),
        itsm: new LabITSM()
    });

    function LabMenu() {}
    $.extend(
        LabMenu.prototype, {
            showContextMenu: function(pageX, pageY) {
                var o = $.topology.contextObj;
                var flag = false;
                var nat = natInfo.filter(function(obj) {
                    return obj.nodeip == o.ipaddress;
                });
                if (o.objectClass) {
                    var index = topoData.config.contextmenu4show[o.objectClass].indexOf(menu_item_nat);
                    if (index > -1) {
                        topoData.config.contextmenu4show[o.objectClass].splice(index, 1);
                    }
                    if (nat.length > 0) {
                        menu_item_nat.children = nat.map(function(obj, idx) {
                            return {
                                id: '5.7.' + idx,
                                text: obj.serverip,
                                action: '$.lab.itsm.natJump(' + obj.topoid + ')',
                                available: true
                            }

                        });
                        topoData.config.contextmenu4show[o.objectClass].push(menu_item_nat);
                    }
                }

                var menuData = $.ctxAdapter.menu();
                if (menuData.length === 0) {
                    return
                }
                var spliceMenuCache = {},
                    spliceMenuIndex = [];
                for (var i = 0, len = menuData.length; i < len; i++) {
                    if (menuData[i].id === "active") {
                        var _action = eval(menuData[i].action);
                        var _menu = _action.call();
                        spliceMenuCache[i] = _menu;
                        spliceMenuIndex.unshift(i)
                    }
                }
                for (var i = 0, len = spliceMenuIndex.length; i < len; i++) {
                    var cacheKey = parseInt(spliceMenuIndex[i]),
                        cacheMnu = spliceMenuCache[cacheKey];
                    menuData.splice(cacheKey, 1);
                    if (cacheMnu != null && cacheMnu.length > 0) {
                        for (var j = 0, cLen = cacheMnu.length; j < cLen; j++) {
                            menuData.splice(cacheKey + j, 0, cacheMnu[j])
                        }
                    }
                }
                $("#svgCanvas").ContextMenu({
                    menu: menuData,
                    mouseButton: "",
                    horizAnimateName: "easeOutBack"
                });
                $("#svgCanvas").ContextMenu("show", pageX, pageY)
            },
            clearContextMenu: function(e) {
                if (e && e.target) {
                    var $target = $(e.target);
                    if ($target.is(".jqCtxMenu") || $target.parents(".jqCtxMenu:first").length) {} else {
                        $("#svgCanvas").ContextMenu("hide")
                    }
                } else {
                    $("#svgCanvas").ContextMenu("hide")
                }
            },
            activeUrl: function() {
                if (!$.lab.menu.testSingleSelected() || $.topology.contextObj == null) {
                    return null
                }
                var ctxObj = $.topology.contextObj,
                    puuid = 1,
                    urlMenu = [],
                    urlItem = null;
                if (ctxObj.option != null && typeof(ctxObj.option["related-view"]) !== "undefined") {
                    var subView = $.topology.views[ctxObj.option["related-view"]];
                    if (subView != null && typeof(subView) !== "undefined") {
                        urlItem = {};
                        urlItem.id = "3." + (puuid++);
                        urlItem.text = subView.name.length > 4 ? (subView.name.substr(0, 4) + "...") : subView.name;
                        urlItem.image = subView.type == "1" ? ctxImg + "/topology/icon/topo-16.png" : ctxImg + "/topology/icon/relation-16.png";
                        var _url = "main.html?type=" + subView.type + "&id=" + subView.id + "&layout=none&fill=1";
                        urlItem.action = "$.lab.direct.openUrl(" + _url + ",_blank," + subView.name + ")";
                        urlItem.separator = true;
                        urlMenu.push(urlItem)
                    }
                }
                if (ctxObj.url != null && ctxObj.url.name.length > 0) {
                    var _url = ctxObj.url;
                    for (var i = 0, len = _url.name.length; i < len; i++) {
                        urlItem = {};
                        urlItem.id = "3." + (puuid++);
                        urlItem.text = _url.name[i].length > 4 ? (_url.name[i].substr(0, 4) + "...") : _url.name[i];
                        urlItem.image = _url.icon[i];
                        urlItem.action = "$.lab.direct.openUrl(" + _url.link[i] + ",_blank," + _url.name[i] + ")";
                        if (urlMenu.length === 0 && i === 0) {
                            urlItem.separator = true
                        }
                        urlMenu.push(urlItem)
                    }
                }
                return urlMenu
            },

            testMainTopo: function() {
                if ($.topology.view.id == '1') {
                    return false;
                }
                return true;
            },

            testAdmin: function() {
                if (curUserId == '1') {
                    return true;
                }
                return false;
            },
            testSelectSymbol: function() {
                var isSymbol = false,
                    selector = $.topology.selector;
                if (selector.size() == 1) {
                    $.topology.contextObj = $.topology.selector.focus();
                    var o = $.topology.contextObj;
                    if ($.topology.isView(o)) {} else {
                        if ($.topology.isSymbol(o)) {
                            isSymbol = true;
                        } else {
                            if ($.topology.isContainer(o)) {
                                isSymbol = true;
                            }
                        }
                    }
                } else {
                    var nodeIds = [].concat($.topology.selector.symbols()).concat($.topology.selector.containers());
                    if (nodeIds.length > 1) {
                        isSymbol = true;
                    }
                }
                return isSymbol;
            },
            testSelectLine: function() {
                var isLine = false,
                    selector = $.topology.selector;
                if (selector.size() == 1) {
                    var o = $.topology.contextObj;
                    if ($.topology.isView(o)) {} else {
                        if ($.topology.isSymbol(o)) {} else {
                            if ($.topology.isContainer(o)) {} else {
                                if ($.topology.isLine(o)) {
                                    isLine = true;
                                } else if ($.topology.isLineseter(o)) {
                                    isLine = true;
                                }
                            }
                        }
                    }
                }
                return isLine;
            },
            testFullScreen: function() {
                return true;
            },
            testAttributePanel: function() {
                var _selector = $.topology.selector;
                if (_selector.size() === 1) {
                    var o = $.topology.contextObj;
                    if ($.topology.isView(o)) {
                        return false
                    } else {
                        if ($.topology.isContainer(o)) {

                        } else {
                            if ($.topology.isLine(o)) {

                            } else if ($.topology.isLineseter(o)) {
                                return false
                            }
                        }
                    }
                    return true
                } else {
                    return false
                }
            },
            testSingleSelected: function() {
                var _selector = $.topology.selector;
                if (_selector.size() === 1) {
                    return true
                } else {
                    return false
                }
            },
            testHasSubTopo: function() {
                if (curTopoLevel < 4) {
                    return true;
                } else {
                    return false;
                }
            },
            testRelaIns: function() {
                var _selector = $.topology.selector;
                if (_selector.size() === 1) {
                    var o = $.topology.contextObj;
                    if ($.topology.isView(o)) {
                        return false
                    } else {
                        if (o.objectType && "auto" == o.objectType) {
                            return true
                        }
                        if (o.instanceId && "" != o.instanceId) {
                            if (o.relaType && "parent" == o.relaType) {
                                return true
                            }
                        }
                    }
                    return false
                } else {
                    return false
                }
            },
            testEvent: function() {
                if ($.lab.menu.testActiveEvent() || $.lab.menu.testHistroyEvent()) {
                    return true
                } else {
                    return false
                }
            },
            testCopySelectedElement: function() {
                var selector = $.topology.selector;
                var obj = $.topology.selector.focus();
                if (obj.objectType == "auto") {
                    return false;
                }
                return selector.size() > 0 && (selector.symbols().length + selector.containers().length) == selector.size()
            },
            testPasteElement: function() {
                return $.topology.clipBoard && $.topology.clipBoard.length > 0
            },
            testActiveEvent: function() {
                var $topo = $.topology,
                    $obj = $topo.contextObj;
                if ($topo.selector.size() === 1 && $obj != null && $obj.eventIds != null && $obj.eventIds.length > 0) {
                    return true
                } else {
                    return false
                }
            },
            testHistroyEvent: function() {
                var $topo = $.topology,
                    $obj = $topo.contextObj;
                if ($topo.selector.size() === 1 && $obj.objectId != null && $.trim($obj.objectId) !== "" && $obj.objectId !== "-1") {
                    return true
                } else {
                    return false
                }
            },
            testSwitchConnectPC: function() {
                if ($.topology.selector.size() === 1 && $.topology.contextObj != null && $.topology.config["global"]["ipaddmgr"] == 1 && ($.topology.contextObj.objectClass == "switch" || $.topology.contextObj.objectClass == "3023")) {
                    return true
                } else {
                    return false
                }
            },
            testDrawLine: function() {
                var _selector = $.topology.selector,
                    test = false;
                if (_selector.size() === 1 && _selector.symbols().length === 1) {
                    test = true
                }
                if (_selector.size() === 2 && _selector.symbols().length === 2) {
                    test = true
                }
                return test
            },
            testLayoutTreeVisible: function() {
                var o = $.topology.contextObj;
                return $.topology.isSymbol(o) || $.topology.isContainer(o)
            },
            testLayoutTreeAvailable: function() {
                var o = $.topology.contextObj || $.topology.selector.focus();
                return $.topology.isSymbol(o) || $.topology.isContainer(o)
            },
            testPasteTarget: function() {
                var target = $.topology.selector.focus();
                if (!target) {
                    return false
                }
                if ($.topology.isView(target) || $.topology.isContainer(target)) {
                    return true
                } else {
                    return false
                }
            },
            testAlignlet: function() {
                var $selector = $.topology.selector,
                    selectedCount = $selector.symbols().length + $selector.containers().length;
                if (selectedCount > 1) {
                    return true
                } else {
                    return false
                }
            },
            testDistributelet: function() {
                var $selector = $.topology.selector,
                    selectedCount = $selector.symbols().length + $selector.containers().length;
                if (selectedCount > 2) {
                    return true
                } else {
                    return false
                }
            },
            testCanvasGridSupport: function() {
                return !!document.createElement("canvas").getContext
            },
            testPolyPoints: function() {
                var obj = $.topology.selector.focus();
                if (obj.points.length > 2) {
                    if (!obj.parent) {
                        return true
                    } else {
                        if (obj.parent.state !== 1) {
                            return true
                        } else {
                            return false
                        }
                    }
                } else {
                    return false
                }
            },
            testHang: function() {
                return $.topology.ui.tooltip4hang.number() > 0
            }
        });

    function LabEvent() {}
    $.extend(LabEvent.prototype, {
        activeAlarm: function() {},
        historyAlarm: function() {},
        speech: function() {}
    });

    function LabITSM() {}
    $.extend(
        LabITSM.prototype, {
            natJump: function(topoId) {
                 if (!topoId || topoId == 'undefined') {
                    layer.msg('找不到NAT拓朴', { icon: 0 });
                 }else{
                    window.location.href = ctx + "/network/topology.do?userid=" + userid + "&displayrule=" + displayrule + '&partConfig=' + encodeURI(encodeURI(JSON.stringify(pConfig))) + "&topoId=" + topoId;
                 }
            },
            backboard: function() {
                var o = $.topology.contextObj;
                var urlStr = ctx + "/network/backboard/view.do?instanceId=" + o.instanceId + "&systemOid=" + o.resourceId + "&ip=" + o.ipaddress;
                ajaxOpenTitleWindow(ctx, "背板", 1024, 600, urlStr);
            },

            telnet: function() {
                var o = $.topology.contextObj;
                var urlStr = ctx + "/network/topology/telnet.do?instanceId=" + o.ipaddress;
                ajaxOpenTitleWindow(ctx, "Telnet", 800, 600, urlStr);
            },

            ping: function() {
                var o = $.topology.contextObj;
                var urlStr = ctx + "/network/topology/ping.do?instanceId=" + o.ipaddress;
                ajaxOpenTitleWindow(ctx, "Ping", 800, 600, urlStr);
            },

            ssh: function() {
                var o = $.topology.contextObj;
                var urlStr = ctx + "/network/topology/ssh.do?instanceId=" + o.ipaddress;
                ajaxOpenTitleWindow(ctx, "SSH", 800, 600, urlStr);
            },

            snmp: function() {
                var o = $.topology.contextObj;
                var urlStr = ctx + "/network/topology/snmp.do?instanceId=" + o.instanceId;
                ajaxOpenTitleWindow(ctx, "SNMP TEST", 800, 600, urlStr);
            },
            downloadsnmp: function() {
                var o = $.topology.contextObj;
                var urlStr = ctx + "/network/topology/snmpinfo.do?instanceId=" + o.instanceId;
                loadingwindow(ctx, 200, 50, '加载中...')

                $.ajax({
                    type: "get",
                    url: urlStr,
                    dataType: "json",
                    timeout: 60000, // 超时时间设置，单位毫秒
                    success: function(content) {
                        opentitlewindow("下载完成", 400, 180, "<div class='pleaselogin' style='margin:20px'>请登录到服务器/opt/tomcat/snmp目录下查看</div>" +
                            "<div class='pleaselogin' style='margin:20px'>或<a href =\"" + ctx + "/network/topology/snmpinfodownload.do?instanceId=" + o.instanceId + "\">下载</a>到本地查看</div>");
                        closeLodingWindow();
                    },
                    error: function(XMLHttpRequest, textStatus, errorThrown) {
                        if (textStatus == 'timeout') {
                            closeLodingWindow();
                            layer.msg("您的操作请求已经超时", { icon: 0 });
                        } else {
                            closeLodingWindow();
                            layer.msg("系统异常，请联系管理员", { icon: 0 });
                        }
                    }
                })
            },
            infoTableAddr: function() {
                var o = $.topology.contextObj;
                var urlStr = ctx + "/network/topology/info/addressTable.do?instanceId=" + o.instanceId;
                ajaxOpenTitleWindow(ctx, "地址表", 1024, 600, urlStr);
            },
            infoTableRouter: function() {
                var o = $.topology.contextObj;
                var urlStr = ctx + "/network/topology/info/routerTable.do?instanceId=" + o.instanceId;
                ajaxOpenTitleWindow(ctx, "路由表", 1024, 600, urlStr);
            },
            infoTableARP: function() {
                var o = $.topology.contextObj;
                var urlStr = ctx + "/network/topology/info/arpTable.do?instanceId=" + o.instanceId;
                ajaxOpenTitleWindow(ctx, "ARP表", 1024, 600, urlStr);
            },
            interfacesList: function() {
                var o = $.topology.contextObj;
                var urlStr = ctx + "/network/topology/interfacesList.do?instanceId=" + o.instanceId;
                ajaxOpenTitleWindow(ctx, "接口一览", 1024, 600, urlStr);
            },
            overview: function() {
                var o = $.topology.contextObj;
                var urlStr = ctx + "/network/topology/resourceOverview.do";
                ajaxOpenTitleWindow(ctx, "资源一览", 1024, 600, urlStr);
            },
            detailInfo: function() {
                var ctxObj = $.topology.contextObj,
                    kpis = ctxObj && ctxObj.kpis,
                    objectClass = ctxObj && ctxObj.objectClass,
                    context = $.topology.config.context[objectClass],
                    information = context && context["INFORMATION"];
                configs = $.topology.config.kpi[objectClass], kpiNames = null, cvrNames = null, data = [];
                if (information) {
                    kpiNames = information.kpis.split(",");
                    cvrNames = information.converters.split(",")
                }
                if (!kpis || !kpiNames) {
                    layer.msg("不存在设备信息", { icon: 0 });
                    return
                }
                var $table = $("<table/>").addClass("pfwindowforms"),
                    $content = $("<div/>").addClass("detailInfo").append($("<div/>").addClass("body").append($table)).append($("<div/>"));
                $.each(kpiNames, function(index, kpiName) {
                    var val = kpis[kpiName],
                        cvrName = cvrNames[index],
                        cvrCfg = $.topology.ui.converterConfig[cvrName],
                        cvr = cvrCfg ? $.converter[cvrCfg.func] : null,
                        $parent = $("<td width=\"380px\"/>");
                    $("<tr/>").append($("<td/>").addClass("pflabel").append(configs[kpiName].zhname)).append($parent).appendTo($table);
                    data.push({
                        parent: $parent,
                        value: val,
                        kpiName: kpiName,
                        converter: cvr
                    })
                });
                $.each(data, function(index, kpiInfo) {
                    var cvr = kpiInfo.converter,
                        val = kpiInfo.value,
                        $parent = kpiInfo.parent;
                    if (val == null || val === "") {
                        $parent.html("")
                    } else {
                        if ($.isFunction(cvr)) {
                            cvr.call(
                                $.converter, {
                                    value: val,
                                    unit: configs[kpiInfo.kpiName].unit
                                }, kpiInfo.parent)
                        } else {
                            $parent.html(val)
                        }
                    }
                })
                opentitlewindow($.topology.isSymbol(ctxObj) ? "设备信息" : "链路信息", 500, 310, $content.html());
            },
            setLinkWeight: function() {},
            linkWeight: function() {},
            hangInfo: function() {
                var $table = $("<table/>").addClass("pfwindowform"),
                    $content = $("<div/>").addClass("hangInfo").append($("<div/>").addClass("body").append($table));
                $.each(["显示节点指标", "显示连线指标", "显示指标名称", "免遮挡处理"], function(i, zh) {
                    var $tr = $("<tr/>").append($("<td/>").append("<span class=\"pflabel\">" + zh + "</span>")).appendTo($table),
                        $chk = $("<input/>").attr({ type: "checkbox" }).addClass("switch").addClass("switch" + i).appendTo($("<td style='width:210px;'/>").addClass("value-field").appendTo($tr));
                });
                var $tr = $("<tr/>").addClass("hangpsttr").append($("<td/>").append("<span class=\"pflabel\">节点指标位置</span>")).appendTo($table),
                    $td = $("<td/>").addClass("value-field").appendTo($tr),
                    $select = $("<select style='width:80px;' class='hangpst'><option value='1'>右</option><option value='2'>下</option><option value='3'>左</option><option value='4'>上</option></select>").appendTo($td);

                openwindow("指标挂载", 400, 366, $content.html(), function() {
                    $.topology.view.option["node-hang-display"] = $.topology.ui.tooltip4hang.isOpen(1) ? 1 : 0;
                    $.topology.view.option["line-hang-display"] = $.topology.ui.tooltip4hang.isOpen(2) ? 1 : 0;
                    $.topology.view.option["hang-name-display"] = $.topology.ui.tooltip4hang.isShowLabel() ? 1 : 0;
                    var nodeHangAdapter = $.topology.view.option["node-hang-adapter"] = $.topology.ui.tooltip4hang.isNodeAdapter() ? 1 : 0;
                    if (nodeHangAdapter) {
                        delete $.topology.view.option["node-hang-position"]
                    } else {
                        $.topology.view.option["node-hang-position"] = $.topology.ui.tooltip4hang.getNodeHangPos()
                    }
                    recoverFn();
                    closeWindow();
                }, function() {
                    recoverFn();
                    closeWindow();
                });
                var recoverFn = function() {
                    var isNodeHang = $.topology.view.option["node-hang-display"] == 1,
                        isLineHang = $.topology.view.option["line-hang-display"] == 1,
                        isShowLabel = $.topology.view.option["hang-name-display"] == 1,
                        isNodeAdapter = $.topology.view.option["node-hang-adapter"] == 1,
                        method = null;
                    method = isNodeHang ? "open" : "close";
                    $.topology.ui.tooltip4hang[method](1);
                    method = isLineHang ? "open" : "close";
                    $.topology.ui.tooltip4hang[method](2);
                    method = isShowLabel ? "showLabel" : "hideLabel";
                    $.topology.ui.tooltip4hang[method]();
                    $.topology.ui.tooltip4hang.setNodeAdapter(
                        isNodeAdapter, !isNodeAdapter);
                    if (!isNodeAdapter) {
                        $.topology.ui.tooltip4hang.setNodeHangPos($select.val())
                    }
                };

                var switchs = $(".switch");
                $(".switch" + 0).iphoneStyle({
                    onChange: function(chk, checked) {
                        var method = checked ? "open" : "close";
                        $.topology.ui.tooltip4hang[method](1)
                    }
                });
                $(".switch" + 1).iphoneStyle({
                    onChange: function(chk, checked) {
                        var method = checked ? "open" : "close";
                        $.topology.ui.tooltip4hang[method](2)
                    }
                });
                $(".switch" + 2).iphoneStyle({
                    onChange: function(chk, checked) {
                        var method = checked ? "showLabel" : "hideLabel";
                        $.topology.ui.tooltip4hang[method]()
                    }
                });
                $(".switch" + 3).iphoneStyle({
                    onChange: function(chk, checked) {
                        var method = checked ? "hide" : "show";
                        $(".hangpsttr")[method]();
                        $.topology.ui.tooltip4hang.setNodeAdapter(checked);
                        if (!checked) {
                            $.topology.ui.tooltip4hang.setNodeHangPos($(".hangpst").val())
                        }
                    }
                });
                $(".hangpst").change(function() {
                    $.topology.ui.tooltip4hang.setNodeHangPos($(this).val())
                });
                $(".switch" + 0).prop("checked", $.topology.view.option["node-hang-display"] == 1);
                $(".switch" + 1).prop("checked", $.topology.view.option["line-hang-display"] == 1);
                $(".switch" + 2).prop("checked", $.topology.view.option["hang-name-display"] == 1);
                $(".switch" + 3).prop("checked", $.topology.view.option["node-hang-adapter"] == 1);
                if ($(".switch" + 3).prop("checked")) {
                    $(".hangpsttr").hide()
                } else {
                    $(".hangpst").val($.topology.view.option["node-hang-position"] || 1)
                }
                setTimeout(function() {
                    $.each(switchs, function() {
                        $(this).iphoneStyle("refresh")
                    })
                }, 1)
            }
        });

    function LabExport() {
        this.$downloadWindow = null
    }
    $.extend(
        LabExport.prototype, {
            exportJpg: function() {
                var svgCode = $.topology.graphEngine.code();
                $.lab.exp._export($.topology.graphEngine.code(), "jpg", false)
            },
            exportPng: function() {
                var svgCode = $.topology.graphEngine.code();
                $.lab.exp._export($.topology.graphEngine.code(), "png", false)
            },
            exportPdf: function() {
                var svgCode = $.topology.graphEngine.code();
                $.lab.exp._export($.topology.graphEngine.code(), "pdf", false)
            },
            exportThumb: function() {
                var svgCode = $.topology.graphEngine.code();
                $.lab.exp._export($.topology.graphEngine.code(), "png", true)
            },
            svgXml: function() {
                var $div = $("<div id='xmlWidget'>").append($("<div/>").attr("id", "codeContainer").css("margin", "10px").text($.topology.graphEngine.code()));
                openwindow("图形脚本", 600, 550, $div.html(),
                    function() {
                        var elem = $("#codeContainer")[0];
                        if (document.body.createTextRange) {
                            var range = document.body.createTextRange();
                            range.moveToElementText(elem);
                            range.moveEnd("character", 0);
                            range.moveStart("character", 0);
                            range.select()
                        } else {
                            if (window.getSelection) {
                                var selection = window.getSelection(),
                                    range = document.createRange();
                                range.selectNodeContents(elem);
                                selection.removeAllRanges();
                                selection.addRange(range)
                            }
                        }
                        console.log($("#codeContainer").html())
                        closeWindow();
                    });
            },
            _export: function(code, format, isThumb) {
                if (!isThumb) {
                    loadingwindow(ctx, 200, 50, "正在导出...")
                    var urlStr = ctx + "/network/topology/createPNG.do";
                    $.ajax({
                        url: urlStr,
                        timeout: 60000, // 超时时间设置，单位毫秒
                        type: "POST",
                        data: {
                            id: $.topology.view.id,
                            svgCode: code,
                            format: format
                        },
                        dataType: "json",
                        success: function(data, textStatus, XMLHttpRequest) {
                            closeLodingWindow();
                            var content = '<table id="gridAndSnapTab" class="pfwindowforms"><tr><td class="pflabel">拓扑图导出成功！</td><td class="value-field">' + "<a href='" + ctx + "/topoImgs/" + $.topology.view.id + "." + format + "' target='_blank' style='color:#5faee3' onclick='closeWindow();'>打开</a>" + '</td></tr></table>';
                            opentitlewindow("导出成功", 400, 180, content, "")
                        },
                        error: function(XMLHttpRequest, textStatus, errorThrown) {
                            closeLodingWindow();
                            layer.msg("系统异常，请联系管理员", { icon: 0 });
                        }
                    })
                } else {
                    //var str=$(code);
                    //$(str).find('.j-nat-device').remove();
                    var urlStr = ctx + "/network/topology/createPNG.do";
                    $.ajax({
                        url: urlStr,
                        timeout: 60000, // 超时时间设置，单位毫秒
                        type: "POST",
                        data: {
                            id: $.topology.view.id,
                            svgCode: code, //str[1].innerHTML
                            format: format
                        },
                        dataType: "json",
                        success: function(data, textStatus, XMLHttpRequest) {},
                        error: function(XMLHttpRequest, textStatus, errorThrown) {
                            layer.msg("系统异常，请联系管理员", { icon: 0 });
                        }
                    })
                }
            }
        });

    function LabDirect() {}
    $.extend(
        LabDirect.prototype, {
            gotoSys: function(_window, page, param) {
                var url = page + "?";
                for (var i in param) {
                    url += i + "=" + param[i] + "&"
                }(_window ? _window : window).location = url.substr(
                    0, url.length - 1)
            },
            openMainLink: function(element) {
                if (element.option != null && typeof(element.option["related-view"]) !== "undefined") {
                    var subView = $.topology.views[element.option["related-view"]];
                    if (subView != null && typeof(subView) !== "undefined") {
                        var _url = "main.html?type=" + subView.type + "&id=" + subView.id + "&layout=none&fill=1";
                        $.lab.direct.openUrl(_url, "_blank", subView.name)
                    }
                } else {
                    if (element.url != null && element.url.name.length > 0) {
                        $.lab.direct.openUrl(element.url.link[0], "_blank", element.url.name[0])
                    }
                }
            },
            popupWindow: function(url, title, options) {
                var _options = {
                    "width": 800,
                    "height": 600,
                    "location": "yes",
                    "menubar": "no",
                    "resizable": "yes",
                    "scrollbars": "yes",
                    "status": "no",
                    "titlebar": "no",
                    "toolbar": "no"
                };
                if (options !== null && $.isPlainObject(options)) {
                    _options = $.extend(_options, options)
                }
                _options.left = (screen.width - _options.width) / 2;
                _options.top = (screen.height - _options.height) / 2;
                title = title && title.replace(/[ -/:-@\[-`{-~]/g, "_");
                window.open(url, title, "width=" + _options.width + ",height=" + _options.height + ",left=" + _options.left + ",top=" + _options.top + ",status=" + _options.status + ",location=" + _options.location + ",menubar=" + _options.menubar + ",resizable=" + _options.resizable + ",scrollbars=" + _options.scrollbars + ",titlebar=" + _options.titlebar + ",toolbar=" + _options.toolbar)
            },
            addView: function() {},
            gotoMain: function() {},
            gotoEdit: function() {},
            exit: function() {},
            addLink: function(line, srcObjectId, dstObjectId) {},
            modifyLink: function(line, id) {}
        });

    function LabUI() {}
    $.extend(
        LabUI.prototype, {
            fullScreen: function() {
                try {
                    $.each(["north", "south", "west"], function() {
                        $.topology.ui.innerLayout.close(this);
                        $.topology.ui.outerLayout.close(this)
                    })
                } catch (e) {
                    return
                }
            },
            unfullScreen: function() {
                try {
                    $.each(["north", "south", "west"], function() {
                        $.topology.ui.innerLayout.open(this);
                        $.topology.ui.outerLayout.open(this)
                    })
                } catch (e) {
                    return
                }
            },
            formatPainter: function() {},
            layoutControl: function(queryParams) {
                var param = queryParams["layout"] || "nswe",
                    keys = {
                        n: "north",
                        s: "south",
                        w: "west",
                        e: "east"
                    },
                    status = {
                        north: "open",
                        south: "open",
                        west: "open",
                        east: "close"
                    };
                if (param === "none") {
                    $.each(keys, function(key, value) {
                        status[value] = "close"
                    })
                } else {
                    if ($.type(param) === "string") {
                        $.each(keys, function(key, value) {
                            if (param.indexOf(key) < 0) {
                                status[value] = "close"
                            }
                        })
                    }
                }
                $.each(status, function(direc, method) {
                    try {
                        $.topology.ui.outerLayout[method](direc);
                        $.topology.ui.innerLayout[method](direc)
                    } catch (e) {}
                })
            },
            eagleEyeDisplayToggle: function() {
                var eagleEye = $.topology.ui.eagleEye;
                if (!eagleEye) {
                    return
                }
                if (eagleEye.isOpen() && eagleEye.visible()) {
                    eagleEye.close()
                } else {
                    eagleEye.open()
                }
            },
            canvasGridToggle: function() {
                $.topology.graphEngine.canvasGrid.toggle()
            },
            gridAndSnap: function() {
                var isSupportGrid = $.topology.graphEngine.canvasGrid.isSupport(),
                    isGridShow = $.topology.graphEngine.canvasGrid.isShow(),
                    gridColor = $.topology.graphEngine.canvasGrid.gridColor(),
                    gridSnapping = $.topology.config.gridSnapping;
                $.topology.graphEngine.canvasGrid.gridColor(gridColor);
                $.topology.graphEngine.canvasGrid.toggle(!isGridShow);
                $.topology.config.gridSnapping = true;
                //开关屏蔽掉弹框
                /*var isSupportGrid = $.topology.graphEngine.canvasGrid.isSupport(),
                    isGridShow = $.topology.graphEngine.canvasGrid.isShow(),
                    gridColor = $.topology.graphEngine.canvasGrid.gridColor(),
                    gridSnapping = $.topology.config.gridSnapping;
                var html = [];
                html.push('<table id="gridAndSnapTab" class="pfwindowform">');
                html.push("<tr style='display:none'>");
                html.push('<td class="pflabel">吸附</td>');
                html.push('<td class="value-field">');
                html.push('<input id="snapSwitch" type="checkbox" class="switch" />');
                html.push("</td>");
                html.push('<td class="help-field"></td>');
                html.push("</tr>");
                html.push("<tr>");
                html.push('<td class="pflabel">网格</td>');
                html.push('<td class="value-field">');
                html.push('<input id="gripSwitch" type="checkbox" class="switch" />');
                html.push("</td>");
                html.push('<td class="help-field"></td>');
                html.push("</tr>");
                html.push("<tr>");
                html.push('<td class="pflabel">网格颜色</td>');
                html.push('<td class="value-field">');
                html.push('<input id="grid_color" type="text" class="color-picker proptext" />');
                html.push("</td>");
                html.push('<td class="help-field"></td>');
                html.push("</tr>");
                html.push("</table>");
                openwindow("网格", 400, 260, html.join(""), function() {
                    saveSettings()
                    closeWindow();
                }, function() {
                    closeWindow();
                })
                var $gc = $("#grid_color"),
                    $gs = $("#gripSwitch"),
                    $ss = $("#snapSwitch");
                if (!isSupportGrid) {
                    $gs.attr("disabled", "disabled");
                    $gc.attr("disabled", "disabled")
                }
                setColorValue($gc, gridColor);
                initColorPicker($gc);
                initSwitchs("#gridAndSnapTab .switch");
                setTimeout(function() {
                    $gs.attr("checked", isGridShow).iphoneStyle("refresh");
                    $ss.attr("checked", gridSnapping).iphoneStyle("refresh")
                }, 750);

                function initSwitchs(selector) {
                    $(selector).iphoneStyle({
                        onChange: function(chk, checked) {
                            var id = chk.attr("id");
                            if (id === "gripSwitch") {
                                isGridShow = checked
                            } else {
                                if (id === "snapSwitch") {
                                    gridSnapping = checked
                                }
                            }
                        }
                    })
                }

                function setColorValue($ele, backgroundColor) {
                    var rgb = $.color.color2rgb(backgroundColor);
                    var fontColor = getFontColor(rgb);
                    $ele.val(backgroundColor).animate({
                        "background-color": backgroundColor,
                        "color": fontColor
                    }, 1000);

                    function getFontColor(rgb) {
                        return rgb[0] * 0.299 + rgb[1] * 0.587 + rgb[2] * 0.114 < 192 ? "#fff" : "#000"
                    }
                }

                function initColorPicker($input) {
                    $input.unbind("click").click(

                        function() {
                            opentitlewindow("拾色器", 360, 280, "<div id='colorPickerWidget'></div>", "")
                            var ele = $(this),
                                _color = ele.val();
                            $("#colorPickerWidget").ColorPicker({
                                flat: true,
                                color: _color,
                                onSubmit: function(hsb, hex, rgb, el) {
                                    gridColor = "#" + hex;
                                    setColorValue(ele, gridColor);
                                    closeWindow();
                                },
                                onBeforeShow: function() {
                                    $(this).ColorPickerSetColor(_color)
                                }
                            })
                        })
                }

                function saveSettings() {
                    $.topology.graphEngine.canvasGrid.gridColor(gridColor);
                    $.topology.graphEngine.canvasGrid.toggle(isGridShow);
                    $.topology.config.gridSnapping = gridSnapping;
                }*/
            },
            setViewDragSelect: function() {
                var _ui = $.topology.ui;
                _ui.viewDragAction = _ui.VIEW_DRAG_ACTION_SELECT;
                _ui.menuSwitch.moveOrSelect(_ui.VIEW_DRAG_ACTION_SELECT)
            },
            setViewDragMove: function() {
                var _ui = $.topology.ui;
                _ui.viewDragAction = _ui.VIEW_DRAG_ACTION_MOVE;
                _ui.menuSwitch.moveOrSelect(_ui.VIEW_DRAG_ACTION_MOVE)
            },
            shortcutBook: function() {
                var shortList = null,
                    _table = "<table class='pair-table'><tr>";
                if ($.topology.status === "SHOW") {
                    shortList = [{
                        "keyboard": "Ctrl + F",
                        "label": "搜索",
                        "used": true
                    }, {
                        "keyboard": "Ctrl + A",
                        "label": "全选",
                        "used": true
                    }, {
                        "keyboard": "Ctrl + Shift + A",
                        "label": "按类型选择",
                        "used": true
                    }, {
                        "keyboard": "Ctrl + R",
                        "label": "中心位置",
                        "used": true
                    }, {
                        "keyboard": "Ctrl + Left(←)",
                        "label": "导航栏",
                        "used": true
                    }, {
                        "keyboard": "Ctrl + Up(↑)",
                        "label": "菜单栏",
                        "used": true
                    }, {
                        "keyboard": "Ctrl + Down(↓)",
                        "label": "告警栏",
                        "used": true
                    }]
                } else {
                    shortList = [{
                        "keyboard": "Ctrl + F",
                        "label": "搜索",
                        "used": true
                    }, {
                        "keyboard": "Ctrl + C",
                        "label": "复制",
                        "used": true
                    }, {
                        "keyboard": "Ctrl + X",
                        "label": "剪切",
                        "used": false
                    }, {
                        "keyboard": "Ctrl + V",
                        "label": "粘贴",
                        "used": true
                    }, {
                        "keyboard": "Del",
                        "label": "删除",
                        "used": true
                    }, {
                        "keyboard": "Ctrl + Z",
                        "label": "撤销",
                        "used": false
                    }, {
                        "keyboard": "Ctrl + Y",
                        "label": "重做",
                        "used": false
                    }, {
                        "keyboard": "Ctrl + S",
                        "label": "保存",
                        "used": true
                    }, {
                        "keyboard": "Ctrl + E",
                        "label": "编辑属性",
                        "used": true
                    }, {
                        "keyboard": "Ctrl + A",
                        "label": "全选",
                        "used": true
                    }, {
                        "keyboard": "Ctrl + Shift + A",
                        "label": "按类型选择",
                        "used": true
                    }, {
                        "keyboard": "Ctrl + [",
                        "label": "上移一层",
                        "used": false
                    }, {
                        "keyboard": "Ctrl + Shift + [",
                        "label": "置于顶层",
                        "used": false
                    }, {
                        "keyboard": "Ctrl + ]",
                        "label": "下移一层",
                        "used": false
                    }, {
                        "keyboard": "Ctrl + Shift + ]",
                        "label": "置于底层",
                        "used": false
                    }, {
                        "keyboard": "Alt + Ctrl + W",
                        "label": "浏览模式",
                        "used": false
                    }, {
                        "keyboard": "Shift + Left(←)",
                        "label": "向左移动",
                        "used": true
                    }, {
                        "keyboard": "Shift + Right(→)",
                        "label": "向右移动",
                        "used": true
                    }, {
                        "keyboard": "Shift + Up(↑)",
                        "label": "向上移动",
                        "used": true
                    }, {
                        "keyboard": "Shift + Down(↓)",
                        "label": "向下移动",
                        "used": true
                    }, {
                        "keyboard": "Left(←)",
                        "label": "向左微调",
                        "used": true
                    }, {
                        "keyboard": "Right(→)",
                        "label": "向右微调",
                        "used": true
                    }, {
                        "keyboard": "Up(↑)",
                        "label": "向上微调",
                        "used": true
                    }, {
                        "keyboard": "Down(↓)",
                        "label": "向下微调",
                        "used": true
                    }, {
                        "keyboard": "Alt + Ctrl + T",
                        "label": "顶端对齐",
                        "used": true
                    }, {
                        "keyboard": "Alt + Ctrl + M",
                        "label": "中部对齐",
                        "used": true
                    }, {
                        "keyboard": "Alt + Ctrl + B",
                        "label": "底端对齐",
                        "used": true
                    }, {
                        "keyboard": "Alt + Ctrl + L",
                        "label": "左侧对齐",
                        "used": true
                    }, {
                        "keyboard": "Alt + Ctrl + C",
                        "label": "居中对齐",
                        "used": true
                    }, {
                        "keyboard": "Alt + Ctrl + R",
                        "label": "右侧对齐",
                        "used": true
                    }]
                }
                for (var i = 0, len = shortList.length; i < len; i++) {
                    if (shortList[i].used) {
                        _table += "<td class='label-field'>" + shortList[i].keyboard + "</td><td class='value-field'>" + shortList[i].label + "</td>"
                    } else {
                        _table += "<td class='label-field'><font color='#bcbcbc'>" + shortList[i].keyboard + "</font></td><td class='value-field'><font color='#bcbcbc'>" + shortList[i].label + "</font></td>"
                    }
                    if (i % 2 === 1) {
                        _table += "</tr><tr>"
                    }
                }
                opentitlewindow("快捷键一览", 520, 302, _table, "")
            },
            toggleResourceMessage: function(cfg, on) {
                var status = $.topology.ui.tooltip4msg.status();
                on = $.type(on) === "boolean" ? on : !status;
                if (on != status) {
                    if (on) {
                        $.topology.view.option["resource-message"] = 1;
                        $.topology.changed.view = true;
                        $.topology.ui.navMenu.navmenu("setDisabled", cfg.id, true);
                        $.topology.ui.tooltip4msg.init(function() {
                            $.topology.ui.navMenu.navmenu("setDisabled", cfg.id, false);
                            $.topology.ui.navMenu.navmenu("setText", cfg.id, "关闭资源变更")
                        })
                    } else {
                        $.topology.view.option["resource-message"] = 0;
                        $.topology.changed.view = true;
                        $.topology.ui.tooltip4msg.destory();
                        $.topology.ui.navMenu.navmenu("setText", cfg.id, "开启资源变更")
                    }
                } else {
                    $.topology.ui.navMenu.navmenu("setText", cfg.id, (on ? "关闭" : "开启") + "资源变更")
                }
            }
        });

    function LabTopology() {}
    $.extend(
        LabTopology.prototype, {
            saveTopo: function() {
                if (!$.topology.isChanged()) {
                    layer.msg("未修改，无须保存", { icon: 0 });
                    return
                }
                loadingwindow(ctx, 200, 50, '正在保存...')
                $.topology.saveTopo();
            },
            addSub: function() {
                if ($.topology.isChanged()) {
                    layer.msg("请先保存", { icon: 0 });
                    return
                }
                var title = "新建子拓扑";
                var width = 480;
                var height = 240;
                var urlStr = ctx + "/network/topology/addTopologyInfo.do?parentId=" + $.topology.view.id;
                var title = name;
                $.ajax({
                    type: "get",
                    timeout: 60000, // 超时时间设置，单位毫秒
                    url: urlStr,
                    dataType: "html",
                    success: function(content) {
                        openwindow(title, width, height, content, function() {
                            if (!$('#topoInfo').valid()) {
                                return;
                            }
                            var parentId = $("input[name='parentId']").val();
                            var topoType = $("input[name='topoType']").val();
                            var name = $("input[name='name']").val();

                            // 发送到子拓扑
                            var nodeIds = [].concat($.topology.selector.symbols()).concat($.topology.selector.containers());
                            var nodesData = [],
                                node;
                            String.prototype.replaceAll = function(FindText, RepText) {
                                regExp = new RegExp(FindText, "g");
                                return this.replace(regExp, RepText);
                            }
                            for (var i = 0; i < nodeIds.length; i++) {
                                node = $.topology.find(nodeIds[i], "symbol|container");
                                if (node) {
                                    var str = node.serialize().replaceAll(',', '@_@');
                                    nodesData.push(str)
                                }
                            }

                            $.ajax({
                                type: "POST",
                                url: ctx + "/network/addSub.do?&" + _csrf + "=" + _csrftoken,
                                dataType: "json",
                                timeout: 60000, // 超时时间设置，单位毫秒
                                data: {
                                    topoId: parentId,
                                    topoName: name,
                                    topoType: topoType,
                                    nodes: nodesData
                                },
                                success: function(msg) {
                                    window.location.href = ctx + "/network/topology.do?topoId=" + msg.topoId;
                                },
                                error: function(XMLHttpRequest, textStatus, errorThrown) {
                                    layer.msg("系统异常，请联系管理员", { icon: 0 });
                                }
                            });
                            closeWindow();
                        })
                    },
                    error: function(XMLHttpRequest, textStatus, errorThrown) {
                        layer.msg("系统异常，请联系管理员", { icon: 0 });
                    }
                })
            },
            sendToSub: function() {
                if ($.topology.isChanged()) {
                    layer.msg("请先保存拓扑内容!", { icon: 0 });
                    return
                }
                loadingwindow(ctx, 200, 50, '加载中...')
                var urlStr = ctx + "/network/loadChildTopo.do?id=" + $.topology.view.id;
                var title = "发送到子拓扑";
                $.ajax({
                    type: "get",
                    url: urlStr,
                    dataType: "html",
                    timeout: 60000, // 超时时间设置，单位毫秒
                    success: function(content) {
                        closeLodingWindow();
                        openwindow(title, 450, 480, content, function() {
                            if (nosubTopo) {
                                closeWindow();
                                return;
                            }
                            if (selectedTopoId == -1) {
                                layer.msg("请选择要发送到的子拓扑", { icon: 0 });
                                return;
                            }

                            loadingwindow(ctx, 200, 50, '发送中...')
                            // 发送到子拓扑
                            var nodeIds = [].concat($.topology.selector.symbols()).concat($.topology.selector.containers());
                            var nodesData = [],
                                node;
                            for (var i = 0; i < nodeIds.length; i++) {
                                node = $.topology.find(nodeIds[i], "symbol|container");
                                if (node) {
                                    nodesData.push(node.serialize())
                                }
                            }
                            var url = ctx + "/network/sendToSub.do?random=" + Math.random() + "&" + _csrf + "=" + _csrftoken;
                            $.ajax({
                                type: "Post",
                                timeout: 60000, // 超时时间设置，单位毫秒
                                url: url,
                                data: {
                                    topoId: $.topology.view.id,
                                    subTopoId: selectedTopoId,
                                    nodes: nodesData
                                },
                                dataType: "json",
                                success: function(content) {
                                    closeLodingWindow();
                                },
                                error: function(XMLHttpRequest, textStatus, errorThrown) {
                                    closeLodingWindow();
                                    layer.msg("系统异常，请联系管理员", { icon: 0 });
                                }
                            })
                            closeWindow();
                        }, function() {
                            closeWindow();
                        })
                    },
                    error: function(XMLHttpRequest, textStatus, errorThrown) {
                        closeLodingWindow();
                        layer.msg("系统异常，请联系管理员", { icon: 0 });
                    }
                })
            },
            copySelectedElement: function() {
                if ($.lab.menu.testCopySelectedElement()) {
                    var nodeIds = [].concat(
                        $.topology.selector.symbols()).concat(
                        $.topology.selector.containers());
                    var nodes = [],
                        node;
                    for (var i = 0; i < nodeIds.length; i++) {
                        node = $.topology.find(nodeIds[i], "symbol|container");
                        if (node) {
                            nodes.push(node)
                        }
                    }
                    $.topology.clipBoard = nodes
                }
            },
            pasteElement: function(isCentered) {
                var $topo = $.topology;
                var cb = $topo.clipBoard;
                if (!cb.length) {
                    return
                }
                var pasted = copyNodes(cb);
                var nodeIconBBox = $topo.getNodesIconBBox(pasted),
                    dx, dy;
                if (isCentered) {
                    var viewport = $topo.view.viewport();
                    var centerX = viewport.x + viewport.width / 2,
                        centerY = viewport.y + viewport.height / 2;
                    dx = centerX - nodeIconBBox.minX - nodeIconBBox.width / 2;
                    dy = centerY - nodeIconBBox.minY - nodeIconBBox.height / 2
                } else {
                    var lastClickPoint = $topo.lastClickPoint;
                    var point = $topo.graphEngine.canvas.coordinateConvert.page2Canvas(lastClickPoint.x, lastClickPoint.y);
                    dx = point.x - nodeIconBBox.minX;
                    dy = point.y - nodeIconBBox.minY
                }
                var viewBox = $topo.view.getViewBox();
                var nodesBbox = $topo.getNodesBBox(pasted);
                if (nodesBbox.minX + dx < viewBox.x) {
                    dx = viewBox.x - nodesBbox.minX
                } else {
                    if (nodesBbox.maxX + dx > viewBox.x + viewBox.width) {
                        dx = viewBox.x + viewBox.width - nodesBbox.maxX
                    }
                }
                if (nodesBbox.minY + dy < viewBox.y) {
                    dy = viewBox.y - nodesBbox.minY
                } else {
                    if (nodesBbox.maxY + dy > viewBox.y + viewBox.height) {
                        dy = viewBox.y + viewBox.height - nodesBbox.maxY
                    }
                }
                $topo.view.moveNodes(pasted, dx, dy);
                var nodeIds = [];
                for (var i = 0; i < pasted.length; i++) {
                    nodeIds.push(pasted[i].id)
                }
                $topo.selector.select(nodeIds);
                return;

                function copyNodes(nodes) {
                    var pasted = [];
                    var nodeMap = {},
                        newNodeMap = {},
                        lineMap = {},
                        newLineMap = {},
                        nodeIdMap = {},
                        lineIdMap = {};
                    var node;
                    for (var i = 0; i < nodes.length; i++) {
                        node = nodes[i];
                        nodeMap[node.id] = node;
                        if ($topo.isContainer(node)) {
                            for (var nid in node.children) {
                                nodeMap[nid] = node.children[nid]
                            }
                        }
                    }
                    var newNode;
                    for (var id in nodeMap) {
                        node = nodeMap[id];
                        if ($topo.isSymbol(node)) {
                            newNode = copySymbol(node)
                        } else {
                            newNode = copyContainer(node)
                        }
                        newNode.add();
                        newNodeMap[newNode.id] = newNode;
                        nodeIdMap[id] = newNode.id
                    }
                    var nodeParent;
                    for (var id in nodeMap) {
                        node = nodeMap[id];
                        if (node.parent && nodeMap[node.parent.id]) {
                            nodeParent = newNodeMap[nodeIdMap[node.parent.id]];
                            newNode = newNodeMap[nodeIdMap[id]];
                            newNode.parent = nodeParent;
                            newNode.visible = nodeParent.isExpand;
                            $topo.graphEngine.coverage.dropNode(newNode);
                            nodeParent.children[newNode.id] = newNode;
                            newNode.change()
                        }
                    }
                    var line, lines;
                    for (var id in nodeMap) {
                        node = nodeMap[id];
                        if ($topo.isSymbol(node)) {
                            lines = node.lines
                        } else {
                            lines = node.lineseters
                        }
                        for (var lid in lines) {
                            line = lines[lid];
                            lineMap[lid] = line
                        }
                    }
                    var newLine;
                    var srcNode, dstNode, newSrcNode, newDstNode;
                    for (var id in lineMap) {
                        line = lineMap[id];
                        if ($topo.isLine(line)) {
                            newLine = copyLine(line)
                        } else {
                            newLine = copyLineseter(line)
                        }
                        srcNode = line.srcNode;
                        dstNode = line.dstNode;
                        if (srcNode) {
                            if (nodeIdMap[srcNode.id]) {
                                newSrcNode = newNodeMap[nodeIdMap[srcNode.id]]
                            } else {
                                newSrcNode = srcNode
                            }
                            newLine.srcNode = newSrcNode;
                            if ($topo.isSymbol(newSrcNode)) {
                                newSrcNode.lines[newLine.id] = newLine
                            } else {
                                newSrcNode.lineseters[newLine.id] = newLine
                            }
                        }
                        if (dstNode) {
                            if (nodeIdMap[dstNode.id]) {
                                newDstNode = newNodeMap[nodeIdMap[dstNode.id]]
                            } else {
                                newDstNode = dstNode
                            }
                            newLine.dstNode = newDstNode;
                            if ($topo.isSymbol(newDstNode)) {
                                newDstNode.lines[newLine.id] = newLine
                            } else {
                                newDstNode.lineseters[newLine.id] = newLine
                            }
                        }
                        newLine.updateNodePosition();
                        newLine.refreshName();
                        newLine.add();
                        newLineMap[newLine.id] = newLine;
                        lineIdMap[id] = newLine.id
                    }
                    var lineParent;
                    for (var id in lineMap) {
                        line = lineMap[id];
                        if (line.parent && lineMap[line.parent.id]) {
                            if (lineMap[line.parent.id]) {
                                lineParent = newLineMap[lineIdMap[line.parent.id]]
                            } else {
                                lineParent = $topo.find(id, "lineseter")
                            }
                            if (lineParent) {
                                newLine = newLineMap[lineIdMap[id]];
                                newLine.parent = lineParent;
                                lineParent.children[newLine.id] = newLine;
                                newLine.change()
                            }
                        }
                    }
                    for (var id in newNodeMap) {
                        pasted.push(newNodeMap[id])
                    }
                    return pasted
                }

                function copySymbol(node) {
                    var copy = $topo.createSymbol();
                    copy.name = node.name;
                    copy.x = node.x;
                    copy.y = node.y;
                    copy.objectId = node.objectId;
                    copy.objectClass = node.objectClass;
                    copy.instanceId = node.instanceId;
                    copy.option = $.extend({}, node.option);
                    delete copy.option["related-view"];
                    copy.style = $.extend({}, node.style);
                    return copy
                }

                function copyContainer(node) {
                    var copy = $topo.createContainer();
                    copy.name = node.name;
                    copy.x = node.x;
                    copy.y = node.y;
                    copy.expandX = node.expandX;
                    copy.expandY = node.expandY;
                    copy.isExpand = node.isExpand;
                    copy.objectId = node.objectId;
                    copy.objectClass = node.objectClass;
                    copy.instanceId = node.instanceId;
                    copy.option = $.extend({}, node.option);
                    copy.style = $.extend({}, node.style);
                    return copy
                }

                function copyLine(line) {
                    var copy = $topo.createLine();
                    copy.name = line.name;
                    copy.x1 = line.x1;
                    copy.y1 = line.y1;
                    copy.x2 = line.x2;
                    copy.y2 = line.y2;
                    copy.path = line.path;
                    copy.points = [].concat(line.points);
                    copy.objectId = line.objectId;
                    copy.objectClass = line.objectClass;
                    copy.instanceId = line.instanceId;
                    copy.visible = line.visible;
                    copy.option = $.extend({}, line.option);
                    copy.style = $.extend({}, line.style);
                    return copy
                }

                function copyLineseter(line) {
                    var copy = $topo.createLineseter();
                    copy.name = line.name;
                    copy.x1 = line.x1;
                    copy.y1 = line.y1;
                    copy.x2 = line.x2;
                    copy.y2 = line.y2;
                    copy.path = line.path;
                    copy.points = [].concat(line.points);
                    copy.objectId = line.objectId;
                    copy.objectClass = line.objectClass;
                    copy.instanceId = line.instanceId;
                    copy.isExpand = line.isExpand;
                    copy.isPermit = line.isPermit;
                    copy.visible = line.visible;
                    copy.state = line.state;
                    copy.option = $.extend({}, line.option);
                    copy.style = $.extend({}, line.style);
                    return copy
                }
            },
            pasteElementInCenter: function() {
                $.lab.topo.pasteElement(true)
            },
            selectAllNodes: function() {
                var nodeIds = [],
                    shapes = $.topology.shapes,
                    symbols = shapes.symbols,
                    containers = shapes.containers;
                for (var id in symbols) {
                    nodeIds.push(id)
                }
                for (var id in containers) {
                    nodeIds.push(id)
                }
                $.topology.selector.select(nodeIds)
            },
            addResource: function(data) {
                loadingwindow(ctx, 200, 50, '加载中...')
                var urlStr = ctx + "/network/topology/addElement.do";
                var title = "添加设备";
                $.ajax({
                    type: "get",
                    url: urlStr,
                    timeout: 60000, // 超时时间设置，单位毫秒
                    dataType: "html",
                    success: function(content) {
                        closeLodingWindow();
                        openwindow(title, 500, 540, content, function() {
                            loadingwindow(ctx, 200, 50, '加载中...')
                            var discoveryUrl = ctx + "/network/topology/doDiscovery.do";
                            $.ajax({
                                type: "get",
                                url: discoveryUrl,
                                timeout: 300000, // 超时时间设置，单位毫秒
                                data: $("#addElement_property").serialize(),
                                dataType: "json",
                                success: function(content) {
                                    closeLodingWindow();
                                    if (content.result == 7 || content.result == 0) {
                                        var nodetemp = {}
                                        nodetemp.instanceId = content.instanceId;
                                        nodetemp.resourceId = content.resourceId;
                                        nodetemp.object_class = content.object_class;
                                        nodetemp.id = content.instanceId;
                                        nodetemp.name = content.name;
                                        nodetemp.instanceName = content.name;
                                        // 判断当前拓扑是否已存在相同自动发现节点
                                        var tempInstanceId = nodetemp.instanceId;
                                        var $shapes = $.topology.shapes
                                        var flag = false;
                                        $.each($shapes, function(type, objs) {
                                            $.each(objs, function(id, obj) {
                                                if (obj.objectType == "auto" && obj.instanceId == tempInstanceId) {
                                                    flag = true;
                                                }
                                            })
                                        })
                                        if (flag) {
                                            layer.msg("当前拓扑已存在相同节点", { icon: 0 });
                                            return;
                                        }

                                        var data = $.lab.topo.treeNode2SymbolData(nodetemp);
                                        var x = 20,
                                            y = 40;
                                        $.extend(data, {
                                            "x": x,
                                            "y": y,
                                            "objectType": "auto",
                                            "parentId": -1
                                        });
                                        var symbol = $.topology.createSymbol(data);
                                        symbol.add();
                                        symbol.edgeDetect();
                                        var symbols = [];
                                        symbols.push(symbol);
                                        $.topology.selector.select(symbol.id);
                                        closeWindow();
                                        $.topology.saveTopo();
                                    } else {
                                        closeLodingWindow();
                                        layer.msg("设备添加失败:" + content.errorMsg, { icon: 2 });
                                    }
                                },
                                error: function(XMLHttpRequest, textStatus, errorThrown) {
                                    closeLodingWindow();
                                    layer.msg("系统异常，请联系管理员", { icon: 0 });
                                }
                            })
                        }, function() {
                            closeWindow();
                        })
                    },
                    error: function(XMLHttpRequest, textStatus, errorThrown) {
                        closeLodingWindow();
                        layer.msg("系统异常，请联系管理员", { icon: 0 });
                    }
                })
            },
            addContainer: function(data) {
                var icon = $.topology.getIcon("container");
                if (!icon) {
                    return
                }
                var x = 20,
                    y = 40;
                data = data || {};
                data.id = null;
                data = $.extend({
                    "name": "新容器",
                    "x": x,
                    "y": y,
                    "parentId": -1,
                    "style": {
                        "icon": icon.path,
                        "icon-width": icon.width,
                        "icon-height": icon.height
                    }
                }, data);
                var container = $.topology.createContainer(data);
                container.add();
                $.topology.selector.select(container.id);
                return container
            },
            addVitualSymbol: function() {
                var icon = $.topology.getIcon("symbol");
                if (!icon) {
                    return
                }
                var x = 20,
                    y = 40;
                var symbol = $.topology.createSymbol({
                    "name": "新节点",
                    "x": x,
                    "y": y,
                    "parentId": -1,
                    "objectClass": "icon",
                    "objectType": "icon",
                    "style": {
                        "icon": icon.path,
                        "icon-width": icon.width,
                        "icon-height": icon.height
                    }
                });
                symbol.add();
                $.topology.selector.select(symbol.id)
            },
            addIconAsVitualSymbol: function(path, x, y, width, height) {
                var symbol = $.topology.createSymbol({
                    "name": "新节点",
                    "x": x,
                    "y": y,
                    "parentId": -1,
                    "objectClass": "icon",
                    "objectType": "icon",
                    "style": {
                        "icon": path,
                        "icon-width": width,
                        "icon-height": height
                    }
                });
                symbol.add();
                $.topology.selector.select(symbol.id)
            },

            addPolygon: function() {
                // TODO
            },
            addRect: function() {
                // TODO
            },
            addCircle: function() {
                // TODO
            },
            treeNode2SymbolData: function(treeNode) {
                var data = {};
                data.name = treeNode.instanceName;
                data.objectClass = treeNode["object_class"];
                var icon = $.topology.getIcon(data.objectClass);
                if (!icon) {
                    icon = $.topology.getIcon("symbol")
                }
                data.style = {
                    "icon": icon.path,
                    "icon-width": icon.width,
                    "icon-height": icon.height
                };

                data.objectId = treeNode.id
                data.instanceId = treeNode["instanceId"];
                data.resourceId = treeNode["resourceId"];
                data.isDbclick = true;
                data.dbclickType = "resource";
                data.dbclickRes = treeNode["instanceId"];
                return data
            },
            importSymbols: function() {
                // 导入
            },
            removeSymbolsFromContainer: function() {
                var $topology = $.topology,
                    selector = $topology.selector,
                    symbols = selector.symbols();
                if (selector.size() == 0 || (selector.size() != symbols.length)) {
                    return
                }
                var id, symbol;
                for (var k in symbols) {
                    id = symbols[k];
                    symbol = $topology.find(id);
                    if (symbol && symbol.parent) {
                        symbol.parent.removeChild(symbol, true)
                    }
                }
            },
            selectElemtByCondition: function() {
                var isShowPage = $.topology.status === "SHOW";
                opentitlewindow("批量选择", 420, 280, "<div id='selectElemtByConditionWidget'></div>")
                $("#selectElemtByConditionWidget").empty().append(
                    $("<div/>").attr("id", "conditionContent")).append(
                    $("<div style='text-align:center;padding:8px 0 0 0;'>" + "<input id='selectElemtSubmit' type='button' value=' 确 定 ' />&nbsp;&nbsp;" + "<input id='selectElemtCancel' type='button' value=' 取 消 ' />" + "</div>"));
                var tabHtml = [];
                tabHtml.push('<div id="conditionTabs">');
                tabHtml.push("<ul>");
                tabHtml.push('<li><a href="#conditionTabs-0">按网元类型</a></li>');
                if (!isShowPage) {
                    tabHtml.push('<li><a href="#conditionTabs-1">按元素类型</a></li>')
                }
                tabHtml.push("</ul>");
                tabHtml.push('<div id="conditionTabs-0" class="conditionTabs"></div>');
                if (!isShowPage) {
                    tabHtml.push('<div id="conditionTabs-1" class="conditionTabs"></div>')
                }
                tabHtml.push("</div>");
                $("#conditionContent").append(tabHtml.join(""));
                var $topo = $.topology;
                var _s = $.topology.shapes;
                var ocs = $topo.getAllObjectClass();
                var optionsHtml = [],
                    o;
                for (var i = 0; i < ocs.length; i++) {
                    o = $topo.getObjectClassInfo(ocs[i]);
                    o && optionsHtml.push('<label title="' + o.name + '"><input class="sebc0" value="' + o.id + '" type="checkbox">' + o.name + "</label>")
                }
                $("#conditionTabs-0").append(optionsHtml.join(""));
                if (!isShowPage) {
                    optionsHtml = [];
                    ocs = [];
                    if (!$.isEmptyObject(_s.symbols)) {
                        ocs.push({
                            id: "symbol",
                            name: "节点"
                        })
                    }
                    if (!$.isEmptyObject(_s.containers)) {
                        ocs.push({
                            id: "container",
                            name: "容器"
                        })
                    }
                    if (!$.isEmptyObject(_s.lines)) {
                        ocs.push({
                            id: "line",
                            name: "连线"
                        })
                    }
                    if (!$.isEmptyObject(_s.lineseters)) {
                        ocs.push({
                            id: "lineseter",
                            name: "线组器"
                        })
                    }
                    for (var i = 0; i < ocs.length; i++) {
                        o = ocs[i];
                        o && optionsHtml.push('<label title="' + o.name + '"><input class="sebc1" value="' + o.id + '" type="checkbox">' + o.name + "</label>")
                    }
                    $("#conditionTabs-1").append(
                        optionsHtml.join(""))
                }
                var $tabs = $("#conditionTabs").tabs();
                $("#selectElemtSubmit").click(

                    function() {
                        ocs = [];
                        var active = $tabs.tabs("option", "active");
                        var $checked = $(".sebc" + active + ":checked");
                        $.each(
                            $checked,
                            function(i, n) {
                                ocs.push($(n).val())
                            });
                        var ids = [];
                        if (active == 0) {
                            var ocsMap = {},
                                ocTmp;
                            for (var i = 0; i < ocs.length; i++) {
                                ocsMap[ocs[i]] = true
                            }
                            for (var type in _s) {
                                var es = _s[type];
                                for (var id in es) {
                                    ocTmp = es[id].getObjectClass();
                                    if (ocsMap[ocTmp]) {
                                        ids.push(id)
                                    }
                                }
                            }
                        } else {
                            if (active == 1) {
                                for (var i in ocs) {
                                    var es = _s[ocs[i] + "s"];
                                    if (es) {
                                        for (var id in es) {
                                            ids.push(id)
                                        }
                                    }
                                }
                            }
                        }
                        $topo.selector.select(ids);
                        closeWindow();
                    });
                $("#selectElemtCancel").click(function() {
                    closeWindow();
                })
            },
            elementExpandCollapseToggle: function() {
                var $topology = $.topology,
                    selector = $topology.selector,
                    contextObj = $topology.contextObj;
                if (!contextObj) {
                    return
                }
                if ($topology.isContainer(contextObj)) {
                    if (!contextObj.isPermit) {
                        return
                    }
                    if (contextObj.isExpand) {
                        contextObj.collapse()
                    } else {
                        contextObj.expand()
                    }
                    contextObj.change();
                    selector.refresh()
                } else {
                    if ($topology.isLine(contextObj)) {
                        var parent = contextObj.parent;
                        if (parent) {
                            parent.show()
                        }
                    } else {
                        if ($topology.isLineseter(contextObj)) {
                            contextObj.expand();
                            if ($topology.selector.contains(contextObj.id)) {
                                $.topology.selector.reset()
                            }
                        }
                    }
                }
            },
            realDeleteElement: function() {
                var topology = $.topology,
                    selector = topology.selector,
                    symbolIds = selector.symbols(),
                    lineIds = selector.lines(),
                    containerIds = selector.containers();
                if (selector.size() == 0 || (selector.size() == 1 && topology.isView(selector.focus()))) {
                    layer.msg("请先选择要删除的对象", { icon: 0 });
                    return
                }
                var title = "提示";
                var content = "当前操作不可恢复，是否确认删除？";
                openquestionwindow(title, content, function() {
                    $.lab.topo.deleteElement();
                    $.topology.saveTopo();
                    $.lab.topo.initResTree($("#resource_partitioning_tree_0"), 0, function() {});
                    location.reload();
                    closeWindow();
                })
            },
            initResTree: function() {

            },

            removeElement: function() {
                var topology = $.topology,
                    selector = topology.selector,
                    symbolIds = selector.symbols(),
                    lineIds = selector.lines(),
                    containerIds = selector.containers();

                $.lab.topo.deleteElement();
                // TODO 移除
                if (!obj) { // 默认处理
                    obj = {
                        success: function(data, textStatus, XMLHttpRequest) {
                            closeLodingWindow();
                            layer.msg("保存成功", { icon: 1 });
                            $.topology.changed = {
                                "view": false,
                                "alarmTfr": false,
                                "add": [],
                                "modify": [],
                                "delete": []
                            };
                            $.lab.exp.exportThumb(); // 保存新图片
                            $.topology.ui.eagleEye.init();
                            $.lab.topo.stateRefresh();
                        },
                        error: function(XMLHttpRequest, textStatus, errorThrown) {
                            layer.msg("保存拓扑图失败, " + $.converter.requestError(XMLHttpRequest, textStatus), { icon: 2 });
                        }
                    }
                }
                $.ajax({
                    url: ctx + "/network/removeElemet.do",
                    method: "POST",
                    timeout: 60000, // 超时时间设置，单位毫秒
                    data: encodeURI("&topoId=" + $.topology.view.id + "&topoData=" + $.topology.serialize() + "&" + _csrf + "=" + _csrftoken),
                    dataType: "json",
                    success: obj.success,
                    error: obj.error
                });
            },

            deleteElement: function() {
                var topology = $.topology,
                    selector = topology.selector,
                    symbolIds = selector.symbols(),
                    lineIds = selector.lines(),
                    containerIds = selector.containers();
                if (selector.size() == 0 || (selector.size() == 1 && topology.isView(selector.focus()))) {
                    return
                }
                var ids, id, obj;
                ids = lineIds;
                for (var k in ids) {
                    id = ids[k];
                    obj = topology.find(id);
                    if (obj) {
                        obj.remove()
                    }
                }
                ids = symbolIds;
                for (var k in ids) {
                    id = ids[k];
                    obj = topology.find(id);
                    if (obj) {
                        obj.remove()
                    }
                }
                ids = containerIds;
                for (var k in ids) {
                    id = ids[k];
                    obj = topology.find(id);
                    if (obj) {
                        obj.remove()
                    }
                }
                selector.reset()
            },
            fontWeight: function(e) {
                if ($.lab.menu.testSelectSymbol()) {
                    var nodeIds = [].concat($.topology.selector.symbols()).concat($.topology.selector.containers());
                    for (var i = 0; i < nodeIds.length; i++) {
                        var node = $.topology.find(nodeIds[i], "symbol|container");
                        if (node) {
                            var o = node;
                            if (o.style["font-weight"] == "bold") {
                                o.style["font-weight"] = "normal";
                            } else {
                                o.style["font-weight"] = "bold";
                            }
                            $.isFunction(o.change) && o.change(true, false);
                        }
                    }
                    $.topology.selector.refresh()
                }
            },
            fontItalic: function(e) {
                var nodeIds = [].concat($.topology.selector.symbols()).concat($.topology.selector.containers());
                for (var i = 0; i < nodeIds.length; i++) {
                    var node = $.topology.find(nodeIds[i], "symbol|container");
                    if (node) {
                        var o = node;
                        if (o.style["font-style"] == "italic") {
                            o.style["font-style"] = "normal";
                        } else {
                            o.style["font-style"] = "italic";
                        }
                        $.isFunction(o.change) && o.change(true, false);
                    }
                }
                $.topology.selector.refresh()
            },
            fontDecoration: function(e) {
                if ($.lab.menu.testSelectSymbol()) {
                    var nodeIds = [].concat($.topology.selector.symbols()).concat($.topology.selector.containers());
                    for (var i = 0; i < nodeIds.length; i++) {
                        var node = $.topology.find(nodeIds[i], "symbol|container");
                        if (node) {
                            var o = node;
                            if (o.style["text-decoration"] == "underline") {
                                o.style["text-decoration"] = "none";
                            } else {
                                o.style["text-decoration"] = "underline";
                            }
                            $.isFunction(o.change) && o.change(true, false);
                        }
                    }
                    $.topology.selector.refresh()
                }
            },
            fontAlign: function(e) {
                if ($.lab.menu.testSelectSymbol()) {
                    var nodeIds = [].concat($.topology.selector.symbols()).concat($.topology.selector.containers());
                    for (var i = 0; i < nodeIds.length; i++) {
                        var node = $.topology.find(nodeIds[i], "symbol|container");
                        if (node) {
                            var o = node;
                            if (o.style["text-align"] != $(e.target).attr("value")) {
                                o.style["text-align"] = $(e.target).attr("value");
                            }
                            $.isFunction(o.change) && o.change(true, false);
                        }
                    }
                    $.topology.selector.refresh()
                }
            },
            fontColor: function(e) {
                if ($.lab.menu.testSelectSymbol()) {
                    var nodeIds = [].concat($.topology.selector.symbols()).concat($.topology.selector.containers());
                    opentitlewindow("拾色器", 360, 280, "<div id='colorPickerWidget'></div>", "")
                    $("#colorPickerWidget").ColorPicker({
                        flat: true,
                        color: "#000", // TODO 初始值
                        onSubmit: function(hsb, hex, rgb, el) {
                            for (var i = 0; i < nodeIds.length; i++) {
                                var node = $.topology.find(nodeIds[i], "symbol|container");
                                if (node) {
                                    var o = node;
                                    gridColor = "#" + hex;
                                    o.style["font-color"] = gridColor;
                                    $.isFunction(o.change) && o.change(true, false);
                                }
                            }
                            $.topology.selector.refresh()
                            closeWindow();
                        },
                        onBeforeShow: function() {
                            $(this).ColorPickerSetColor(_color)
                        }
                    })
                }
            },
            fontFamily: function(e) {
                if ($.lab.menu.testSelectSymbol()) {
                    var nodeIds = [].concat($.topology.selector.symbols()).concat($.topology.selector.containers());
                    for (var i = 0; i < nodeIds.length; i++) {
                        var node = $.topology.find(nodeIds[i], "symbol|container");
                        if (node) {
                            var o = node;
                            o.style["font-family"] = $(e.target).attr("value");
                            $.isFunction(o.change) && o.change(true, false);
                        }
                    }
                    $.topology.selector.refresh()
                    $("#mxPopupMenu").hide();
                }
            },
            fontSize: function(e) {
                if ($.lab.menu.testSelectSymbol()) {
                    var nodeIds = [].concat($.topology.selector.symbols()).concat($.topology.selector.containers());
                    for (var i = 0; i < nodeIds.length; i++) {
                        var node = $.topology.find(nodeIds[i], "symbol|container");
                        if (node) {
                            var o = node;
                            o.style["font-size"] = $(e.target).attr("value");
                            $.isFunction(o.change) && o.change(true, false);
                        }
                    }
                    $.topology.selector.refresh()
                    $("#mxPopupMenu").hide();
                }
            },
            lineWeight: function(e) {
                if ($.lab.menu.testSelectLine()) {
                    var o = $.topology.contextObj;
                    o.style.weight = $(e.target).attr("value");
                    $.isFunction(o.change) && o.change();
                    $.topology.selector.refresh()
                    $("#mxPopupMenu").hide();
                }
            },
            lineStyle: function(e) {
                if ($.lab.menu.testSelectLine()) {
                    var o = $.topology.contextObj;
                    o.style.dashed = $(e.target).attr("value");
                    $.isFunction(o.change) && o.change();
                    $.topology.selector.refresh();
                    $("#mxPopupMenu").hide();
                }
            },
            itemAttributePanel: function() {
                var instanceId = null;
                var type = null,
                    selector = $.topology.selector;
                if (selector.size() == 1) {
                    var o = $.topology.contextObj;
                    if ($.topology.isView(o)) {
                        type = "view"
                    } else {
                        type = o.objectClass;
                        instanceId = o.instanceId;
                        if ($.topology.isSymbol(o)) {
                            if (o.objectType == "auto") {
                                type = "resource"
                            } else
                                type = "node"
                        } else {
                            if ($.topology.isContainer(o)) {
                                type = "container"
                            } else {
                                if ($.topology.isLine(o)) {
                                    if (o.objectType == "auto") {
                                        type = "link"
                                    } else {
                                        type = "line"
                                    }
                                } else if ($.topology.isLineseter(o)) {
                                    type = "line"
                                }
                            }
                        }
                    }
                }
                loadingwindow(ctx, 200, 50, '加载中...')
                var urlStr = ctx + "/network/topology/ElementProperty.do?instanceId=" + instanceId + "&elementType=" + type + "&dbclickRes=" + o.dbclickRes + "&dbclickType=" + o.dbclickType + "&metricId=" + o.metricId;
                var title = "属性";
                $.ajax({
                    type: "get",
                    url: urlStr,
                    timeout: 60000, // 超时时间设置，单位毫秒
                    dataType: "html",
                    success: function(content) {
                        closeLodingWindow();
                        openwindow(title, 600, 630, content, function() {
                            var temp = $.lab.topo.saveItemAttribute();
                            if (temp && temp != "valid") {
                                closeWindow();
                            }
                        }, function() {
                            closeWindow();
                        })
                    },
                    error: function(XMLHttpRequest, textStatus, errorThrown) {
                        closeLodingWindow();
                        layer.msg("系统异常，请联系管理员", { icon: 0 });
                    }
                })
            },
            itemAssociatedDevice: function() {
                var type = null,
                    selector = $.topology.selector;
                if (selector.size() == 1) {
                    var o = $.topology.contextObj;
                    if ($.topology.isView(o)) {
                        type = "view"
                    } else {
                        var instanceId = o.id;
                        if ($.topology.isChanged()) {
                            openquestionwindow('提示', '需要先保存绘图才能关联设备，确定要保存吗？', function() {
                                closeWindow();
                                loadingwindow(ctx, 200, 50, '正在保存...');
                                $.topology.saveTopo(null, function() {
                                    AssociateDevice(instanceId);
                                });

                            });
                        } else {
                            AssociateDevice(instanceId);
                        }
                    }
                }
            },
            saveItemAttribute: function() {},
            forceLayout: function() {
                var force = $.topology.layout.force;
                opentitlewindow("力学布局", 480, 260, testPanelHtml["layout_force.html"]);
                var steps = {
                    friction: 0.05,
                    linkDistance: 1,
                    linkStrength: 0.05,
                    charge: 10,
                    gravity: 0.05,
                    theta: 0.05
                };
                $("#forceLayout-linkDistance").spinner({
                    step: steps["linkDistance"]
                });
                $("#forceLayout-charge").spinner({
                    step: steps["charge"]
                });
                initSettingValue();
                $("#forceLayout-cancel").click(function() {
                    closeWindow();
                });
                $("#forceLayout-reset").click(function() {
                    resetSettingValue()
                });
                $("#forceLayout-submit").click(function() {
                    if (!isNumber($("#forceLayout-linkDistance").val())) {
                        layer.msg('请输入正确的数字格式', { icon: 0 });
                        return;
                    }
                    if ($("#forceLayout-linkDistance").val() < 0 || $("#forceLayout-linkDistance").val() > 9999) {
                        layer.msg('超出布局运算范围，请输入0-9999之间的数字进行布局', { icon: 0 });
                        return;
                    }
                    if (!isNumber($("#forceLayout-charge").val())) {
                        layer.msg('请输入正确的数字格式', { icon: 0 });
                        return;
                    }
                    if ($("#forceLayout-charge").val() < 0 || $("#forceLayout-charge").val() > 9999) {
                        layer.msg('超出布局运算范围，请输入0-9999之间的数字进行布局', { icon: 0 });
                        return;
                    }
                    writeSettingValue();
                    closeWindow();
                    doForceLayout()
                });

                function isNumber(value) {
                    var patrn = /^(-)?\d+(\.\d+)?$/;
                    if (patrn.exec(value) == null || value == "") {
                        return false
                    } else {
                        return true
                    }
                }

                function initSettingValue() {
                    $("friction,linkDistance,linkStrength,charge,gravity,theta".split(",")).each(

                        function(i, v) {
                            if (v === "charge") {
                                var _charge = Number(force.getOption("charge"));
                                _charge = _charge > 0 ? -_charge : Math.abs(_charge);
                                $("#forceLayout-charge").val(_charge)
                            } else {
                                $("#forceLayout-" + v).val(
                                    force.getOption(v))
                            }
                        })
                }

                function resetSettingValue() {
                    force.resetSetting();
                    initSettingValue()
                }

                function writeSettingValue() {
                    $("friction,linkDistance,linkStrength,charge,gravity,theta".split(",")).each(

                        function(i, v) {
                            var value = Number($("#forceLayout-" + v).val(), 10);
                            if (v === "charge") {
                                value = value > 0 ? -value : Math.abs(value)
                            }
                            force.setOption(v, value)
                        })
                }

                function doForceLayout() {
                    force.on("start", function() {
                        loadingwindow(ctx, 300, 50, '正在布局，点击图片停止')
                        $(".loadingimg").bind("click", function() {
                            force.stop();
                        })
                    });
                    force.on("end", function() {
                        closeLodingWindow();
                        $.topology.saveTopo()
                    });
                    force.start()
                }
            },
            treeLayoutTop: function() {
                $.topology.layout.tree.setOption("orientation", 0);
                $.lab.topo.treeLayout()
            },
            treeLayoutRight: function() {
                $.topology.layout.tree.setOption("orientation", 2);
                $.lab.topo.treeLayout()
            },
            treeLayoutBottom: function() {
                $.topology.layout.tree.setOption("orientation", 1);
                $.lab.topo.treeLayout()
            },
            treeLayoutLeft: function() {
                $.topology.layout.tree.setOption("orientation", 3);
                $.lab.topo.treeLayout()
            },
            treeLayout: function() {
                console.log("treeLayout is running...")
                var root;
                var contextObj = $.topology.contextObj;
                console.log("treeLayout contextObj:" + contextObj)
                if (contextObj) {
                    root = contextObj
                } else {
                    if ($.topology.selector.focus()) {
                        root = $.topology.selector.focus()
                    }
                }
                if (root && root.parent) {
                    root = root.parent
                }
                if (!$.topology.isSymbol(root) && !$.topology.isContainer(root)) {
                    console.log("treeLayout return 1")
                    return
                }
                var tree = $.topology.layout.tree;
                loadingwindow(ctx, 300, 90, '正在初始化')
                opentitlewindow("树形布局", 480, 320, testPanelHtml["layout_tree.html"]);
                closeLodingWindow();
                var steps = {
                    levelDistance: 5,
                    siblingDistance: 5,
                    subtreeDistance: 5
                };
                for (var k in steps) {
                    $("#treeLayout-" + k).spinner({
                        step: steps[k]
                    })
                }
                initSettingValue();
                $("#treeLayout-cancel").click(function() {
                    closeWindow();
                });
                $("#treeLayout-reset").click(function() {
                    resetSettingValue()
                });

                function isNumber(value) {
                    var patrn = /^(-)?\d+(\.\d+)?$/;
                    if (patrn.exec(value) == null || value == "") {
                        return false
                    } else {
                        return true
                    }
                }
                $("#treeLayout-submit").click(function() {
                    if (!isNumber($("#treeLayout-levelDistance").val())) {
                        layer.msg('请输入正确的数字格式', { icon: 0 });
                        return;
                    }
                    if ($("#treeLayout-levelDistance").val() < 0 || $("#treeLayout-levelDistance").val() > 9999) {
                        layer.msg('超出布局运算范围，请输入0-9999之间的数字进行布局', { icon: 0 });
                        return;
                    }
                    if (!isNumber($("#treeLayout-siblingDistance").val())) {
                        layer.msg('请输入正确的数字格式', { icon: 0 });
                        return;
                    }
                    if ($("#treeLayout-siblingDistance").val() < 0 || $("#treeLayout-siblingDistance").val() > 9999) {
                        layer.msg('超出布局运算范围，请输入0-9999之间的数字进行布局', { icon: 0 });
                        return;
                    }
                    if (!isNumber($("#treeLayout-subtreeDistance").val())) {
                        layer.msg('请输入正确的数字格式', { icon: 0 });
                        return;
                    }
                    if ($("#treeLayout-subtreeDistance").val() < 0 || $("#treeLayout-subtreeDistance").val() > 9999) {
                        layer.msg('超出布局运算范围，请输入0-9999之间的数字进行布局', { icon: 0 });
                        return;
                    }
                    writeSettingValue();
                    closeWindow();
                    doLayout()
                });

                function initSettingValue() {
                    $("orientation,levelDistance,siblingDistance,subtreeDistance".split(",")).each(
                        function(i, v) {
                            $("#treeLayout-" + v).val(
                                tree.getOption(v))
                        })
                }

                function resetSettingValue() {
                    tree.resetSetting();
                    initSettingValue()
                }

                function writeSettingValue() {
                    $("orientation,levelDistance,siblingDistance,subtreeDistance".split(",")).each(

                        function(i, v) {
                            var value = Number($("#treeLayout-" + v).val(), 10);
                            tree.setOption(v, value)
                        })
                }

                function doLayout() {
                    tree.root(root);
                    tree.start()
                }
            },
            collapseAllContainer: function() {
                var s = $.topology.shapes;
                for (var id in s.containers) {
                    var container = s.containers[id];
                    if (container.isExpand) {
                        container.collapse()
                    }
                }
            },
            collapseAllLineseter: function() {
                var s = $.topology.shapes;
                for (var id in s.lineseters) {
                    var lineseter = s.lineseters[id];
                    if (lineseter.isExpand) {
                        lineseter.collapse()
                    }
                }
            },
            drawStraightLink: function() {
                var $topology = $.topology,
                    selector = $topology.selector,
                    symbols = selector.symbols(),
                    symbolsLength = symbols.length,
                    dl = $topology.graphEngine.drawStraightLink;
                if (selector.size() == 1 && symbolsLength == 1) {
                    dl.init($topology);
                    var from = selector.focus();
                    if ($topology.isSymbol(from)) {
                        dl.start();
                        dl.setFromNode(from)
                    }
                } else {
                    if (selector.size() == 2 && symbolsLength == 2) {
                        dl.init($topology);
                        var from = selector.focus();
                        if ($topology.isSymbol(from)) {
                            dl.start();
                            dl.setFromNode(from);
                            var toid = from.id == symbols[0] ? symbols[1] : symbols[0];
                            var to = $topology.find(toid);
                            if ($topology.isSymbol(to)) {
                                dl.setToNode(to)
                            }
                        }
                    }
                }
            },
            drawStraightLine: function() {
                var $topology = $.topology,
                    selector = $topology.selector,
                    symbols = selector.symbols(),
                    symbolsLength = symbols.length,
                    dl = $topology.graphEngine.drawStraightLine;
                if (selector.size() == 1 && symbolsLength == 1) {
                    dl.init($topology);
                    var from = selector.focus();
                    if ($topology.isSymbol(from)) {
                        dl.start();
                        dl.setFromNode(from)
                    }
                } else {
                    if (selector.size() == 2 && symbolsLength == 2) {
                        dl.init($topology);
                        var from = selector.focus();
                        if ($topology.isSymbol(from)) {
                            dl.start();
                            dl.setFromNode(from);
                            var toid = from.id == symbols[0] ? symbols[1] : symbols[0];
                            var to = $topology.find(toid);
                            if ($topology.isSymbol(to)) {
                                dl.setToNode(to)
                            }
                        }
                    }
                }
            },
            drawCurveLine: function() { // liyang曲线
                var $topology = $.topology,
                    selector = $topology.selector,
                    symbols = selector.symbols(),
                    symbolsLength = symbols.length,
                    dl = $topology.graphEngine.drawCurveLine;

                if (selector.size() == 0 || symbolsLength == 0) {
                    layer.msg('请先选择节点', { icon: 0 });
                } else if (selector.size() == 1 && symbolsLength == 1) { // 选中一个节点
                    // 连其他
                    dl.init($topology);
                    var from = selector.focus();
                    if ($topology.isSymbol(from)) {
                        dl.start();
                        dl.setFromNode(from)
                    }
                } else {
                    // 选中两个节点 直接连
                    if (selector.size() == 2 && symbolsLength == 2) {
                        dl.init($topology);
                        var from = selector.focus();
                        if ($topology.isSymbol(from)) {
                            dl.start();
                            dl.setFromNode(from);
                            var toid = from.id == symbols[0] ? symbols[1] : symbols[0];
                            var to = $topology.find(toid);
                            if ($topology.isSymbol(to)) {
                                dl.setToNode(to)
                            }
                        }
                    } else {
                        layer.msg('最多选俩个节点', { icon: 0 });
                    }
                }
            },
            moveSelected: function(dx, dy) {
                var $topo = $.topology,
                    nodeIds = [].concat(
                        $topo.selector.symbols()).concat(
                        $topo.selector.containers()),
                    nodes = [];
                if (!nodeIds.length) {
                    return
                }
                dx = Number(dx, 10);
                dy = Number(dy, 10);
                var node;
                for (var i = 0; i < nodeIds.length; i++) {
                    node = $topo.find(nodeIds[i], "symbol|container");
                    node && nodes.push(node)
                }
                var viewBox = $topo.view.getViewBox();
                var nodesBbox = getNodesMaxBBox(nodes);
                if (nodesBbox.minX + dx < viewBox.x) {
                    dx = viewBox.x - nodesBbox.minX
                } else {
                    if (nodesBbox.maxX + dx > viewBox.x + viewBox.width) {
                        dx = viewBox.x + viewBox.width - nodesBbox.maxX
                    }
                }
                if (nodesBbox.minY + dy < viewBox.y) {
                    dy = viewBox.y - nodesBbox.minY
                } else {
                    if (nodesBbox.maxY + dy > viewBox.y + viewBox.height) {
                        dy = viewBox.y + viewBox.height - nodesBbox.maxY
                    }
                }
                $topo.view.moveNodes(nodes, dx, dy);
                $topo.view.moveNodesStop(nodes);
                $topo.selector.refresh();

                function getNodesMaxBBox(nodes) {
                    var bbox, bboxs = [],
                        o;
                    for (var i = 0; i < nodes.length; i++) {
                        o = nodes[i];
                        bbox = $.extend({}, o.getBBox());
                        if (o.parent) {
                            var parentPadding = o.parent.getExpandPadding();
                            bbox.minX -= parentPadding.left;
                            bbox.minY -= parentPadding.top;
                            bbox.maxX += parentPadding.right;
                            bbox.maxY += parentPadding.bottom
                        }
                        bboxs.push(bbox)
                    }
                    return $topo.getMaxBBox(bboxs)
                }
            },
            horiLeftAlign: function() {
                $.lab.topo._horiAlign("left")
            },
            horiCenterAlign: function() {
                $.lab.topo._horiAlign("center")
            },
            horiRightAlign: function() {
                $.lab.topo._horiAlign("right")
            },
            vertTopAlign: function() {
                $.lab.topo._vertAlign("top")
            },
            vertMiddleAlign: function() {
                $.lab.topo._vertAlign("middle")
            },
            vertBottomAlign: function() {
                $.lab.topo._vertAlign("bottom")
            },
            _horiAlign: function(type) {
                var $topo = $.topology,
                    $selector = $topo.selector,
                    $ge = $topo.graphEngine,
                    $animation = $ge.animation,
                    selectedSymbols = $selector.symbols(),
                    selectedContainers = $selector.containers(),
                    focus = $selector.focus(),
                    isSymbolFocus = $topo.isSymbol(focus),
                    baseX = 0,
                    dur = 400,
                    lineseterExpandMap = {};
                switch (type) {
                    case "left":
                        if (isSymbolFocus) {
                            baseX = focus.x
                        } else {
                            baseX = focus.isExpand ? focus.expandX : focus.x
                        }
                        break;
                    case "center":
                        if (isSymbolFocus) {
                            baseX = focus.x + parseInt(focus.style["icon-width"]) / 2
                        } else {
                            baseX = focus.isExpand ? (focus.expandX + focus.expandWidth / 2) : (focus.x + parseInt(focus.style["icon-width"]) / 2)
                        }
                        break;
                    case "right":
                        if (isSymbolFocus) {
                            baseX = focus.x + parseInt(focus.style["icon-width"])
                        } else {
                            baseX = focus.isExpand ? (focus.expandX + focus.expandWidth) : (focus.x + parseInt(focus.style["icon-width"]))
                        }
                        break
                }
                var symbol = null,
                    container = null,
                    i = 0,
                    len = 0,
                    x = 0,
                    offsetX = 0;
                for (i = 0, len = selectedSymbols.length; i < len; i++) {
                    if (selectedSymbols[i] === focus.id) {
                        continue
                    }
                    symbol = $topo.find(selectedSymbols[i], "symbol");
                    collapseSymbolLineseter(symbol);
                    if (type === "left") {
                        x = baseX
                    } else {
                        if (type === "center") {
                            x = baseX - parseInt(symbol.style["icon-width"]) / 2
                        } else {
                            if (type === "right") {
                                x = baseX - parseInt(symbol.style["icon-width"])
                            }
                        }
                    }
                    offsetX = x - symbol.x;
                    $animation.move(symbol, offsetX, 0, dur)
                }
                for (i = 0, len = selectedContainers.length; i < len; i++) {
                    if (selectedContainers[i] === focus.id) {
                        continue
                    }
                    container = $topo.find(selectedContainers[i], "container");
                    if (container.isExpand) {
                        var children = container.children;
                        for (var sid in children) {
                            var child = children[sid];
                            collapseSymbolLineseter(child)
                        }
                    }
                    if (type === "left") {
                        x = baseX
                    } else {
                        if (type === "center") {
                            x = baseX - (container.isExpand ? container.expandWidth : parseInt(container.style["icon-width"])) / 2
                        } else {
                            if (type === "right") {
                                x = baseX - (container.isExpand ? container.expandWidth : parseInt(container.style["icon-width"]))
                            }
                        }
                    }
                    offsetX = x - (container.isExpand ? container.expandX : container.x);
                    $animation.move(container, offsetX, 0, dur)
                }
                var lazy = true;
                var majorVer = Number($.browser.version.split(".")[0]);
                if ($.browser.msie && (majorVer <= 8)) {
                    lazy = false
                }
                if (lazy) {
                    var reExpandLazy = 200 * (selectedSymbols.length + selectedContainers.length);
                    setTimeout(function() {
                        if (lineseterExpandMap) {
                            for (var lid in lineseterExpandMap) {
                                o = $topo.find(lid);
                                if (!o) {
                                    continue
                                }
                                o.expand()
                            }
                        }
                    }, (reExpandLazy < 1000 ? 1200 : reExpandLazy))
                }
                $topo.graphEngine.selector.resize();

                function collapseSymbolLineseter(symbol) {
                    if (!symbol) {
                        return
                    }
                    lines = symbol.lines;
                    for (var k in lines) {
                        line = lines[k];
                        if (line.state == 1 && $.topology.isLineseter(line)) {
                            if (line.isExpand) {
                                lineseterExpandMap[line.id] = line.isExpand;
                                line.collapse()
                            }
                        }
                    }
                }
            },
            _vertAlign: function(type) {
                var $topo = $.topology,
                    $selector = $topo.selector,
                    $ge = $topo.graphEngine,
                    $animation = $ge.animation,
                    selectedSymbols = $selector.symbols(),
                    selectedContainers = $selector.containers(),
                    focus = $selector.focus(),
                    isSymbolFocus = $topo.isSymbol(focus),
                    baseY = 0,
                    dur = 400,
                    lineseterExpandMap = {};
                switch (type) {
                    case "top":
                        if (isSymbolFocus) {
                            baseY = focus.y
                        } else {
                            baseY = focus.isExpand ? focus.expandY : focus.y
                        }
                        break;
                    case "middle":
                        if (isSymbolFocus) {
                            baseY = focus.y + parseInt(focus.style["icon-height"]) / 2
                        } else {
                            baseY = focus.isExpand ? (focus.expandY + focus.expandHeight / 2) : (focus.y + parseInt(focus.style["icon-height"]) / 2)
                        }
                        break;
                    case "bottom":
                        if (isSymbolFocus) {
                            baseY = focus.y + parseInt(focus.style["icon-height"])
                        } else {
                            baseY = focus.isExpand ? (focus.expandY + focus.expandHeight) : (focus.y + parseInt(focus.style["icon-height"]))
                        }
                        break
                }
                var symbol = null,
                    container = null,
                    i = 0,
                    len = 0,
                    y = 0,
                    offsetY = 0;
                for (i = 0, len = selectedSymbols.length; i < len; i++) {
                    if (selectedSymbols[i] === focus.id) {
                        continue
                    }
                    symbol = $topo.find(selectedSymbols[i], "symbol");
                    collapseSymbolLineseter(symbol);
                    if (type === "top") {
                        y = baseY
                    } else {
                        if (type === "middle") {
                            y = baseY - parseInt(symbol.style["icon-height"]) / 2
                        } else {
                            if (type === "bottom") {
                                y = baseY - parseInt(symbol.style["icon-height"])
                            }
                        }
                    }
                    offsetY = y - symbol.y;
                    $animation.move(symbol, 0, offsetY, dur)
                }
                for (i = 0, len = selectedContainers.length; i < len; i++) {
                    if (selectedContainers[i] === focus.id) {
                        continue
                    }
                    container = $topo.find(selectedContainers[i], "container");
                    if (container.isExpand) {
                        var children = container.children;
                        for (var sid in children) {
                            var child = children[sid];
                            collapseSymbolLineseter(child)
                        }
                    }
                    if (type === "top") {
                        y = baseY
                    } else {
                        if (type === "middle") {
                            y = baseY - (container.isExpand ? container.expandHeight : parseInt(container.style["icon-height"])) / 2
                        } else {
                            if (type === "bottom") {
                                y = baseY - (container.isExpand ? container.expandHeight : parseInt(container.style["icon-height"]))
                            }
                        }
                    }
                    offsetY = y - (container.isExpand ? container.expandY : container.y);
                    $animation.move(container, 0, offsetY, dur)
                }
                var lazy = true;
                var majorVer = Number($.browser.version.split(".")[0]);
                if ($.browser.msie && (majorVer <= 8)) {
                    lazy = false
                }
                if (lazy) {
                    var reExpandLazy = 200 * (selectedSymbols.length + selectedContainers.length);
                    setTimeout(function() {
                        if (lineseterExpandMap) {
                            for (var lid in lineseterExpandMap) {
                                o = $topo.find(lid);
                                if (!o) {
                                    continue
                                }
                                o.expand()
                            }
                        }
                    }, (reExpandLazy < 1000 ? 1200 : reExpandLazy))
                }
                $topo.graphEngine.selector.resize();

                function collapseSymbolLineseter(symbol) {
                    if (!symbol) {
                        return
                    }
                    lines = symbol.lines;
                    for (var k in lines) {
                        line = lines[k];
                        if (line.state == 1 && $.topology.isLineseter(line)) {
                            if (line.isExpand) {
                                lineseterExpandMap[line.id] = line.isExpand;
                                line.collapse()
                            }
                        }
                    }
                }
            },
            horiDistribute: function() {
                var $topo = $.topology,
                    $selector = $topo.selector,
                    $ge = $topo.graphEngine,
                    $animation = $ge.animation,
                    element = null,
                    elements = [],
                    ids = [].concat($selector.symbols()).concat(
                        $selector.containers()),
                    minX = 0,
                    maxX = 0,
                    sizeX = 0,
                    spaceX = 0,
                    addX = 0,
                    offsetX = 0,
                    usedSpace = 0,
                    dur = 400,
                    lineseterExpandMap = {};
                for (var i = 0, len = ids.length; i < len; i++) {
                    element = $topo.find(ids[i], "symbol|container");
                    if ($topo.isSymbol(element)) {
                        collapseSymbolLineseter(element)
                    } else {
                        if (element.isExpand) {
                            var children = element.children;
                            for (var sid in children) {
                                var child = children[sid];
                                collapseSymbolLineseter(child)
                            }
                        }
                    }
                    usedSpace += parseInt(element.style["icon-width"]);
                    elements.push(element)
                }
                elements.sort(function(a, b) {
                    return (a.x - b.x)
                });
                minX = elements[0].x;
                maxX = elements[elements.length - 1].x + parseInt(elements[elements.length - 1].style["icon-width"]);
                sizeX = maxX - minX;
                spaceX = parseInt((sizeX - usedSpace) / (elements.length - 1));
                addX = minX;
                for (var i = 0, len = elements.length; i < len; i++) {
                    addX += i === 0 ? 0 : spaceX;
                    offsetX = addX - elements[i].x;
                    addX += parseInt(elements[i].style["icon-width"]);
                    $animation.move(elements[i], offsetX, 0, dur)
                }
                var lazy = true;
                var majorVer = Number($.browser.version.split(".")[0]);
                if ($.browser.msie && (majorVer <= 8)) {
                    lazy = false
                }
                if (lazy) {
                    var reExpandLazy = 200 * ids.length;
                    setTimeout(function() {
                        if (lineseterExpandMap) {
                            for (var lid in lineseterExpandMap) {
                                o = $topo.find(lid);
                                if (!o) {
                                    continue
                                }
                                o.expand()
                            }
                        }
                    }, (reExpandLazy < 1000 ? 1200 : reExpandLazy))
                }
                $topo.graphEngine.selector.resize();

                function collapseSymbolLineseter(symbol) {
                    if (!symbol) {
                        return
                    }
                    lines = symbol.lines;
                    for (var k in lines) {
                        line = lines[k];
                        if (line.state == 1 && $.topology.isLineseter(line)) {
                            if (line.isExpand) {
                                lineseterExpandMap[line.id] = line.isExpand;
                                line.collapse()
                            }
                        }
                    }
                }
            },
            vertDistribute: function() {
                var $topo = $.topology,
                    $selector = $topo.selector,
                    $ge = $topo.graphEngine,
                    $animation = $ge.animation,
                    element = null,
                    elements = [],
                    ids = [].concat($selector.symbols()).concat(
                        $selector.containers()),
                    minY = 0,
                    maxY = 0,
                    sizeY = 0,
                    spaceY = 0,
                    addY = 0,
                    offsetY = 0,
                    usedSpace = 0,
                    dur = 400,
                    lineseterExpandMap = {};
                for (var i = 0, len = ids.length; i < len; i++) {
                    element = $topo.find(ids[i], "symbol|container");
                    if ($topo.isSymbol(element)) {
                        collapseSymbolLineseter(element)
                    } else {
                        if (element.isExpand) {
                            var children = element.children;
                            for (var sid in children) {
                                var child = children[sid];
                                collapseSymbolLineseter(child)
                            }
                        }
                    }
                    usedSpace += parseInt(element.style["icon-height"]);
                    elements.push(element)
                }
                elements.sort(function(a, b) {
                    return (a.y - b.y)
                });
                minY = elements[0].y;
                maxY = elements[elements.length - 1].y + parseInt(elements[elements.length - 1].style["icon-height"]);
                sizeY = maxY - minY;
                spaceY = parseInt((sizeY - usedSpace) / (elements.length - 1));
                addY = minY;
                for (var i = 0, len = elements.length; i < len; i++) {
                    addY += i === 0 ? 0 : spaceY;
                    offsetY = addY - elements[i].y;
                    addY += parseInt(elements[i].style["icon-height"]);
                    $animation.move(elements[i], 0, offsetY, dur)
                }
                var lazy = true;
                var majorVer = Number($.browser.version.split(".")[0]);
                if ($.browser.msie && (majorVer <= 8)) {
                    lazy = false
                }
                if (lazy) {
                    var reExpandLazy = 200 * ids.length;
                    setTimeout(function() {
                        if (lineseterExpandMap) {
                            for (var lid in lineseterExpandMap) {
                                o = $topo.find(lid);
                                if (!o) {
                                    continue
                                }
                                o.expand()
                            }
                        }
                    }, (reExpandLazy < 1000 ? 1200 : reExpandLazy))
                }
                $topo.graphEngine.selector.resize();

                function collapseSymbolLineseter(symbol) {
                    if (!symbol) {
                        return
                    }
                    lines = symbol.lines;
                    for (var k in lines) {
                        line = lines[k];
                        if (line.state == 1 && $.topology.isLineseter(line)) {
                            if (line.isExpand) {
                                lineseterExpandMap[line.id] = line.isExpand;
                                line.collapse()
                            }
                        }
                    }
                }
            },
            rightAnglePolyLine: function() {
                var $selector = $.topology.selector,
                    $ge = $.topology.graphEngine,
                    element = null,
                    ids = [].concat($selector.lines()).concat(
                        $selector.lineseters());
                for (var i = 0, len = ids.length; i < len; i++) {
                    element = $.topology.find(ids[i], "line|lineseter");
                    element.rightAngle().changePath(); // 改变角度_改变路径
                    element.change()
                }
            },
            rightAngleCurveLine: function() {
                var $selector = $.topology.selector,
                    $ge = $.topology.graphEngine,
                    element = null,
                    ids = [].concat($selector.lines()).concat(
                        $selector.lineseters());
                for (var i = 0, len = ids.length; i < len; i++) {
                    element = $.topology.find(ids[i], "line|lineseter");
                    element.rightCurveAngle().changePath(); // 改变角度_改变路径
                    element.change() // 更新拖动点
                }
            },
            viewPositionReset: function() {
                var view = $.topology.view,
                    scale = view.scale(),
                    bbox = view.getBBox(),
                    width = bbox.width,
                    height = bbox.height;
                view.scale(scale, -width / 2, -height / 2, true)
            },
            viewOrigiZoom: function() {
                $.topology.view.origiZoom()
            },
            viewFitToCanvas: function() {
                $.topology.view.fitToCanvas()
            },
            viewZoomIn: function() {
                var view = $.topology.view,
                    scale = view.scale(),
                    width = view.getContainerWidth(),
                    height = view.getContainerHeight(),
                    zoomStep = 1.2;
                view.scale(scale * zoomStep, width / 2, height / 2)
            },
            viewZoomOut: function() {
                var view = $.topology.view,
                    scale = view.scale(),
                    width = view.getContainerWidth(),
                    height = view.getContainerHeight(),
                    zoomStep = 1.2;
                view.scale(scale / zoomStep, width / 2, height / 2)
            },
            viewRefresh: function() {},
            stateRefresh: function() {},
            viewNameReflush: function(viewName) {
                var $title = $("#topoTitle"),
                    $container = $title.parent().parent(),
                    view = $.topology.view,
                    style = view && view.style,
                    $ge = $.topology.graphEngine,
                    viewOpts = $ge && $ge.options && $ge.options.view,
                    viewName = viewName != null ? viewName : (view && view.name);
                if (!style || !viewOpts) {
                    return
                }
                var textDisplay = style ? style["text-display"] : viewOpts["text-display"];
                if (!$title.data("topoTitleInited")) {
                    $title.data("topoTitleInited", true);
                    $container.draggable({
                        distance: 3,
                        containment: $("#svgCanvas"),
                        stop: function() {
                            var $this = $(this),
                                svgWidth = $("#svgCanvas").width(),
                                left = $this.position().left;
                            $(this).data("titleLeft", left).data("svgWidth", svgWidth)
                        }
                    })
                }
                if (textDisplay == "1") {
                    $title.html(viewName);
                    if ($container.is(":hidden")) {
                        $container.stop(true, false).css({
                            top: "-30px"
                        }).show().animate({
                            top: "0px"
                        }, 500, function() {
                            $(this).addClass("fixedTop")
                        })
                    }
                    var $svg = $("#svgCanvas"),
                        titleLeft = $container.data("titleLeft"),
                        svgWidth = $container.data("svgWidth"),
                        left = 0;
                    if (titleLeft != null && titleLeft != null) {
                        left = parseInt(titleLeft * $svg.width() / svgWidth)
                    } else {
                        left = parseInt($svg.width() - $container.outerWidth()) / 2
                    }
                    left = left < 0 ? 0 : left;
                    $container.css({
                        left: left + "px"
                    })
                } else {
                    if ($container.is(":visible")) {
                        $container.stop(true, false).removeClass("fixedTop").animate({
                            top: "-35px"
                        }, 300, function() {
                            $(this).hide()
                        })
                    }
                }
                return $title
            }
        });
    $.lab = new Laboratory()
})(jQuery);