(function($) {
	function SVGHandler() {
		this._settings = [];
		this._uuid = new Date().getTime();
		this._support = detectSVG();
		this._supportNative = isSupportNativeSVG();
		this._supportPlugin = isSupportPluginSVG();
		this._defaultContainer = "topology.svg";

		function detectSVG() {
			return isSupportNativeSVG() || isSupportPluginSVG()
		}

		function isSupportNativeSVG() {
			return !!document.createElementNS && !! document.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGRect
		}

		function isSupportPluginSVG() {
			try {
				return !!$.browser.msie && !! (window.ActiveXObject && new ActiveXObject("Adobe.SVGCtl"))
			} catch (e) {
				return false
			}
		}
	}

	function isArray(obj) {
		return (obj && obj.constructor == Array)
	}
	var PROP_NAME = "svgwrapper";

	$.extend(SVGHandler.prototype, {
		svgNS: "http://www.w3.org/2000/svg",
		xlinkNS: "http://www.w3.org/1999/xlink",
		markerClassName: "hasSVG",
		_wrapperClass: SVGWrapper,
		_attrNames: {
			class_: "class",
			in_: "in",
			alignmentBaseline: "alignment-baseline",
			baselineShift: "baseline-shift",
			clipPath: "clip-path",
			clipRule: "clip-rule",
			colorInterpolation: "color-interpolation",
			colorInterpolationFilters: "color-interpolation-filters",
			colorRendering: "color-rendering",
			dominantBaseline: "dominant-baseline",
			enableBackground: "enable-background",
			fillOpacity: "fill-opacity",
			fillRule: "fill-rule",
			floodColor: "flood-color",
			floodOpacity: "flood-opacity",
			fontFamily: "font-family",
			fontSize: "font-size",
			fontSizeAdjust: "font-size-adjust",
			fontStretch: "font-stretch",
			fontStyle: "font-style",
			fontVariant: "font-variant",
			fontWeight: "font-weight",
			glyphOrientationHorizontal: "glyph-orientation-horizontal",
			glyphOrientationVertical: "glyph-orientation-vertical",
			horizAdvX: "horiz-adv-x",
			horizOriginX: "horiz-origin-x",
			imageRendering: "image-rendering",
			letterSpacing: "letter-spacing",
			lightingColor: "lighting-color",
			markerEnd: "marker-end",
			markerMid: "marker-mid",
			markerStart: "marker-start",
			stopColor: "stop-color",
			stopOpacity: "stop-opacity",
			strikethroughPosition: "strikethrough-position",
			strikethroughThickness: "strikethrough-thickness",
			strokeDashArray: "stroke-dasharray",
			strokeDashOffset: "stroke-dashoffset",
			strokeLineCap: "stroke-linecap",
			strokeLineJoin: "stroke-linejoin",
			strokeMiterLimit: "stroke-miterlimit",
			strokeOpacity: "stroke-opacity",
			strokeWidth: "stroke-width",
			textAnchor: "text-anchor",
			textDecoration: "text-decoration",
			textRendering: "text-rendering",
			underlinePosition: "underline-position",
			underlineThickness: "underline-thickness",
			vertAdvY: "vert-adv-y",
			vertOriginY: "vert-origin-y",
			wordSpacing: "word-spacing",
			writingMode: "writing-mode"
		},
		_attachSVG: function(container, settings) {
			var svg = (container.namespaceURI == this.svgNS ? container : null);
			var container = (svg ? null : container);
			if ($(container || svg).hasClass(
			this.markerClassName)) {
				return
			}
			if (typeof settings == "string") {
				settings = {
					loadURL: settings
				}
			} else {
				if (typeof settings == "function") {
					settings = {
						onLoad: settings
					}
				}
			}
			$(container || svg).addClass(this.markerClassName);
			if (this._supportNative) {
				if (!svg) {
					svg = document.createElementNS(this.svgNS, "svg");
					svg.setAttribute("version", "1.1");
					if (container.clientWidth > 0) {
						svg.setAttribute("width", container.clientWidth)
					}
					if (container.clientHeight > 0) {
						svg.setAttribute("height", container.clientHeight)
					}
					container.appendChild(svg)
				}
				this._afterLoad(container, svg, settings || {})
			} else {
				if (this._supportPlugin) {
					if (!container.id) {
						container.id = "svg" + (this._uuid++)
					}
					this._settings[container.id] = settings;
					container.innerHTML = '<embed type="image/svg+xml" width="100%" ' + 'height="100%" src="' + (settings.initPath || "") + this._defaultContainer + '" wmode="transparent" />'
				} else {
					container.innerHTML = '<p class="svg_error">加载SVG对象出错</p>'
				}
			}
		},
		_registerSVG: function() {
			for (var i = 0, len = document.embeds.length; i < len; i++) {
				var container = document.embeds[i].parentNode;
				if (!$(container).hasClass(
				$.svg.markerClassName) || $.data(container, PROP_NAME)) {
					continue
				}
				var svg = null;
				try {
					svg = document.embeds[i].getSVGDocument()
				} catch (e) {
					setTimeout($.svg._registerSVG, 250);
					return
				}
				svg = (svg ? svg.documentElement : null);
				if (svg) {
					$.svg._afterLoad(container, svg)
				}
			}
		},
		_afterLoad: function(container, svg, settings) {
			var settings = settings || this._settings[container.id];
			this._settings[container ? container.id : ""] = null;
			var wrapper = new this._wrapperClass(svg, container);
			$.data(container || svg, PROP_NAME, wrapper);
			try {
				if (settings.loadURL) {
					wrapper.load(settings.loadURL, settings)
				}
				if (settings.settings) {
					wrapper.configure(settings.settings)
				}
				if (settings.onLoad && !settings.loadURL) {
					settings.onLoad.apply(container || svg, [wrapper])
				}
			} catch (e) {
				$.error(e)
			}
		},
		_getSVG: function(container) {
			container = (typeof container == "string" ? $(container)[0] : (container.jquery ? container[0] : container));
			return $.data(container, PROP_NAME)
		},
		_destroySVG: function(container) {
			var $container = $(container);
			if (!$container.hasClass(this.markerClassName)) {
				return
			}
			$container.removeClass(this.markerClassName);
			if (container.namespaceURI != this.svgNS) {
				$container.empty()
			}
			$.removeData(container, PROP_NAME)
		},
		isSVGElem: function(node) {
			return (node.nodeType == 1 && node.namespaceURI == $.svg.svgNS)
		}
	});

	function SVGWrapper(svg, container) {
		this._svg = svg;
		this._container = container
	}
	$.extend(SVGWrapper.prototype, {
		_width: function() {
			return (this._container ? this._container.clientWidth : this._svg.width)
		},
		_height: function() {
			return (this._container ? this._container.clientHeight : this._svg.height)
		},
		_args: function(values, names, optSettings) {
			names.splice(0, 0, "element");
			names.splice(names.length, 0, "settings");
			var args = {};
			var offset = 0;
			if (values[0] != null && values[0].jquery) {
				values[0] = values[0][0]
			}
			if (values[0] != null && (typeof values[0] != "object" || !values[0].nodeName)) {
				args["element"] = null;
				offset = 1
			}
			for (var i = 0, len = values.length; i < len; i++) {
				args[names[i + offset]] = values[i]
			}
			if (optSettings) {
				$.each(optSettings, function(i, value) {
					if (typeof args[value] == "object") {
						args.settings = args[value];
						args[value] = null
					}
				})
			}
			return args
		},
		root: function() {
			return this._svg
		},
		createPath: function() {
			return new SVGPath()
		},
		createText: function() {
			return new SVGText()
		},
		configure: function(settings, clear) {
			if (!node.nodeName) {
				clear = settings;
				settings = node;
				node = this._svg
			}
			if (clear) {
				for (var i = node.attributes.length - 1; i >= 0; i--) {
					var attr = node.attributes.item(i);
					if (!(attr.nodeName == "onload" || attr.nodeName == "version" || attr.nodeName.substring(0, 5) == "xmlns")) {
						node.attributes.removeNamedItem(attr.nodeName)
					}
				}
			}
			for (var attrName in settings) {
				node.setAttribute($.svg._attrNames[attrName] || attrName, settings[attrName])
			}
			return this
		},
		getElementById: function(id) {
			return this._svg.ownerDocument.getElementById(id)
		},
		change: function(element, settings) {
			if (element) {
				for (var name in settings) {
					if (settings[name] == null) {
						element.removeAttribute($.svg._attrNames[name] || name)
					} else {
						element.setAttribute(
						$.svg._attrNames[name] || name, settings[name])
					}
				}
			}
			return this
		},
		title: function(element, text, settings) {
			var args = this._args(arguments, ["text"]);
			var node = this._makeNode(args.element, "title", args.settings || {});
			node.appendChild(this._svg.ownerDocument.createTextNode(args.text));
			return node
		},
		describe: function(element, text, settings) {
			var args = this._args(arguments, ["text"]);
			var node = this._makeNode(args.element, "desc", args.settings || {});
			node.appendChild(this._svg.ownerDocument.createTextNode(args.text));
			return node
		},
		style: function(element, styles, settings) {
			var args = this._args(arguments, ["styles"]);
			var node = this._makeNode(args.element, "style", $.extend({
				type: "text/css"
			}, args.settings || {}));
			node.appendChild(this._svg.ownerDocument.createTextNode(args.styles));
			if ($.browser.opera) {
				$("head").append('<style type="text/css">' + args.styles + "</style>")
			}
			return node
		},
		script: function(element, script, type, settings) {
			var args = this._args(arguments, ["script", "type"], ["type"]);
			var node = this._makeNode(args.element, "script", $.extend({
				type: args.type || "text/javascript"
			}, args.settings || {}));
			node.appendChild(this._svg.ownerDocument.createTextNode(this._escapeXML(args.script)));
			if (!$.browser.mozilla) {
				$.globalEval(args.script)
			}
			return node
		},
		defs: function(element, id, settings) {
			var args = this._args(arguments, ["id"], ["id"]);
			return this._makeNode(args.element, "defs", $.extend((args.id ? {
				id: args.id
			} : {}), args.settings || {}))
		},
		use: function(element, x, y, width, height, ref, settings) {
			var args = this._args(arguments, ["x", "y", "width", "height", "ref"]);
			if (typeof args.x == "string") {
				args.ref = args.x;
				args.settings = args.y;
				args.x = args.y = args.width = args.height = null
			}
			var node = this._makeNode(args.element, "use", $.extend({
				x: args.x,
				y: args.y,
				width: args.width,
				height: args.height
			}, args.settings || {}));
			node.setAttributeNS($.svg.xlinkNS, "href", args.ref);
			return node
		},
		mask: function(element, id, x, y, width, height, settings) {
			var args = this._args(arguments, ["id", "x", "y", "width", "height"]);
			return this._makeNode(args.element, "mask", $.extend({
				id: args.id,
				x: args.x,
				y: args.y,
				width: args.width,
				height: args.height
			}, args.settings || {}))
		},
		svg: function(element, x, y, width, height, vx, vy, vwidth, vheight, settings) {
			var args = this._args(arguments, ["x", "y", "width", "height", "vx", "vy", "vwidth", "vheight"], ["vx"]);
			var sets = $.extend({
				x: args.x,
				y: args.y,
				width: args.width,
				height: args.height
			}, (args.vx != null ? {
				viewBox: args.vx + " " + args.vy + " " + args.vwidth + " " + args.vheight
			} : {}));
			return this._makeNode(args.element, "svg", $.extend(sets, args.settings || {}))
		},
		group: function(element, id, settings) {
			var args = this._args(arguments, ["id"], ["id"]);
			return this._makeNode(args.element, "g", $.extend({
				id: args.id
			}, args.settings || {}))
		},
		link: function(element, ref, settings) {
			var args = this._args(arguments, ["ref"]);
			var node = this._makeNode(args.element, "a", args.settings);
			node.setAttributeNS($.svg.xlinkNS, "href", args.ref);
			return node
		},
		image: function(element, x, y, width, height, ref, settings) {
			var args = this._args(arguments, ["x", "y", "width", "height", "ref"]);
			var node = this._makeNode(args.element, "image", $.extend({
				x: args.x,
				y: args.y,
				width: args.width,
				height: args.height
			}, args.settings || {}));
			try {
				node.setAttributeNS($.svg.xlinkNS, "href", args.ref)
			} catch (err) {}
			return node
		},
		path: function(element, path, settings) {
			var args = this._args(arguments, ["path"]);
			return this._makeNode(args.element, "path", $.extend({
				d: (args.path.path ? args.path.path() : args.path)
			}, args.settings || {}))
		},
		rect: function(element, x, y, width, height, rx, ry, settings) {
			var args = this._args(arguments, ["x", "y", "width", "height", "rx", "ry"], ["rx"]);
			return this._makeNode(args.element, "rect", $.extend({
				x: args.x,
				y: args.y,
				width: args.width,
				height: args.height
			}, (args.rx ? {
				rx: args.rx,
				ry: args.ry
			} : {}), args.settings || {}))
		},
		circle: function(element, cx, cy, r, settings) {
			var args = this._args(arguments, ["cx", "cy", "r"]);
			return this._makeNode(args.element, "circle", $.extend({
				cx: args.cx,
				cy: args.cy,
				r: args.r
			}, args.settings || {}))
		},
		ellipse: function(element, cx, cy, rx, ry, settings) {
			var args = this._args(arguments, ["cx", "cy", "rx", "ry"]);
			return this._makeNode(args.element, "ellipse", $.extend({
				cx: args.cx,
				cy: args.cy,
				rx: args.rx,
				ry: args.ry
			}, args.settings || {}))
		},
		line: function(element, x1, y1, x2, y2, settings) {
			var args = this._args(arguments, ["x1", "y1", "x2", "y2"]);
			return this._makeNode(args.element, "line", $.extend({
				x1: args.x1,
				y1: args.y1,
				x2: args.x2,
				y2: args.y2
			}, args.settings || {}))
		},
		polyline: function(element, points, settings) {
			var args = this._args(arguments, ["points"]);
			return this._poly(args.element, "polyline", args.points, args.settings)
		},
		polygon: function(element, points, settings) {
			var args = this._args(arguments, ["points"]);
			return this._poly(args.element, "polygon", args.points, args.settings)
		},
		_poly: function(element, name, points, settings) {
			var ps = "";
			for (var i = 0, len = points.length; i < len; i++) {
				ps += points[i].join() + " "
			}
			return this._makeNode(element, name, $.extend({
				points: $.trim(ps)
			}, settings || {}))
		},
		text: function(element, x, y, value, settings) {
			var args = this._args(arguments, ["x", "y", "value"]);
			if (typeof args.x == "string" && arguments.length < 4) {
				args.value = args.x;
				args.settings = args.y;
				args.x = args.y = null
			}
			return this._text(args.element, "text", args.value, $.extend({
				x: (args.x && isArray(args.x) ? args.x.join(" ") : args.x),
				y: (args.y && isArray(args.y) ? args.y.join(" ") : args.y)
			}, args.settings || {}))
		},
		textpath: function(element, pathId, value, settings) {
			var args = this._args(arguments, ["path", "value"]);
			var node = this._text(args.element, "textPath", args.value, args.settings || {});
			node.setAttributeNS($.svg.xlinkNS, "href", args.pathId);
			return node
		},
		_text: function(element, name, value, settings) {
			var node = this._makeNode(element, name, settings);
			if (typeof value == "string") {
				node.appendChild(node.ownerDocument.createTextNode(value))
			} else {
				for (var i = 0, len = value._parts.length; i < len; i++) {
					var part = value._parts[i];
					if (part[0] == "tspan") {
						var child = this._makeNode(node, part[0], part[2]);
						child.appendChild(node.ownerDocument.createTextNode(part[1]));
						node.appendChild(child)
					} else {
						if (part[0] == "tref") {
							var child = this._makeNode(node, part[0], part[2]);
							child.setAttributeNS($.svg.xlinkNS, "href", part[1]);
							node.appendChild(child)
						} else {
							if (part[0] == "textpath") {
								var set = $.extend({}, part[2]);
								set.href = null;
								var child = this._makeNode(
								node, part[0], set);
								child.setAttributeNS(
								$.svg.xlinkNS, "href", part[2].href);
								child.appendChild(node.ownerDocument.createTextNode(part[1]));
								node.appendChild(child)
							} else {
								node.appendChild(node.ownerDocument.createTextNode(part[1]))
							}
						}
					}
				}
			}
			return node
		},
		radialGradient: function(element, id, stops, cx, cy, r, fx, fy, settings) {
			var args = this._args(arguments, ["id", "stops", "cx", "cy", "r", "fx", "fy"], ["cx"]);
			var sets = $.extend({
				id: args.id
			}, (args.cx != null ? {
				cx: args.cx,
				cy: args.cy,
				r: args.r,
				fx: args.fx,
				fy: args.fy
			} : {}));
			return this._gradient(args.element, "radialGradient", $.extend(sets, args.settings || {}), args.stops)
		},
		linearGradient: function(element, id, stops, x1, y1, x2, y2, settings) {
			var args = this._args(arguments, ["id", "stops", "x1", "y1", "x2", "y2"], ["x1"]);
			var sets = $.extend({
				id: args.id
			}, (args.x1 != null ? {
				x1: args.x1,
				y1: args.y1,
				x2: args.x2,
				y2: args.y2
			} : {}));
			return this._gradient(args.element, "linearGradient", $.extend(sets, args.settings || {}), args.stops)
		},
		_gradient: function(element, name, settings, stops) {
			var node = this._makeNode(element, name, settings);
			for (var i = 0, len = stops.length; i < len; i++) {
				var stop = stops[i];
				this._makeNode(node, "stop", $.extend({
					offset: stop[0],
					stopColor: stop[1]
				}, (stop[2] != null ? {
					stopOpacity: stop[2]
				} : {})))
			}
			return node
		},
		filter: function(element, id, x, y, width, height, settings) {
			var args = this._args(arguments, ["id", "x", "y", "width", "height"]);
			return this._makeNode(args.element, "filter", $.extend({
				id: args.id,
				x: args.x,
				y: args.y,
				width: args.width,
				height: args.height
			}, args.settings || {}))
		},
		merge: function(element, result, refs, settings) {
			var args = this._args(arguments, ["result", "refs"]);
			var node = this._makeNode(args.element, "feMerge", $.extend({
				result: args.result
			}, args.settings || {}));
			for (var i = 0, len = args.refs.length; i < len; i++) {
				this._makeNode(node, "feMergeNode", {
					in_: args.refs[i]
				})
			}
		},
		composite: function(element, result, operator, in1, in2, k1, k2, k3, k4, settings) {
			var args = this._args(arguments, ["result", "operator", "in1", "in2", "k1", "k2", "k3", "k4"], ["k1"]);
			var sets = $.extend({
				result: args.result,
				operator: args.operator,
				"in": args.in1,
				in2: args.in2
			}, (args.k1 != null ? {
				k1: args.k1,
				k2: args.k2,
				k3: args.k3,
				k4: args.k4
			} : {}));
			return this._makeNode(args.element, "feComposite", $.extend(sets, args.settings || {}))
		},
		colorMatrix: function(element, result, in1, type, values, settings) {
			var args = this._args(arguments, ["result", "in1", "type", "values"]);
			var sets = $.extend({
				result: args.result,
				in_: args.in1,
				type: args.type
			}, (args.values != null ? {
				values: args.values
			} : {}));
			return this._makeNode(args.element, "feColorMatrix", $.extend(sets, args.settings || {}))
		},
		gaussianBlur: function(element, result, in1, stdDevX, stdDevY, settings) {
			var args = this._args(arguments, ["result", "in1", "stdDevX", "stdDevY"], ["stdDevY"]);
			return this._makeNode(args.element, "feGaussianBlur", $.extend({
				result: args.result,
				in_: args.in1,
				stdDeviation: args.stdDevX + (args.stdDevY ? " " + args.stdDevY : "")
			}, args.settings || {}))
		},
		offset: function(element, result, in1, dx, dy, settings) {
			var args = this._args(arguments, ["result", "in1", "dx", "dy"]);
			return this._makeNode(args.element, "feOffset", $.extend({
				result: args.result,
				in_: args.in1,
				dx: args.dx,
				dy: args.dy
			}, args.settings || {}))
		},
		pointLight: function(element, result, x, y, z, settings) {
			var args = this._args(arguments, ["result", "x", "y", "z"]);
			return this._makeNode(args.element, "fePointLight", $.extend({
				result: args.result,
				x: args.x,
				y: args.y,
				z: args.z
			}, args.settings || {}))
		},
		specularLighting: function(element, result, in1, surfaceScale, specularConstant, specularExponent, settings) {
			var args = this._args(arguments, ["result", "in1", "surfaceScale", "specularConstant", "specularExponent"], ["surfaceScale", "specularConstant", "specularExponent"]);
			return this._makeNode(
			args.element, "feSpecularLighting", $.extend({
				result: args.result,
				in_: args.in1,
				surfaceScale: args.surfaceScale,
				specularConstant: args.specularConstant,
				specularExponent: args.specularExponent
			}, args.settings || {}))
		},
		blend: function(element, result, mode, in1, in2, settings) {
			var args = this._args(arguments, ["result", "mode", "in1", "in2"]);
			return this._makeNode(args.element, "feBlend", $.extend({
				result: args.result,
				mode: args.mode,
				in_: args.in1,
				in2: args.in2
			}, args.settings || {}))
		},
		turbulence: function(element, result, type, baseFreq, octaves, settings) {
			var args = this._args(arguments, ["result", "type", "baseFreq", "octaves"], ["octaves"]);
			return this._makeNode(args.element, "feTurbulence", $.extend({
				result: args.result,
				type: args.type,
				baseFrequency: args.baseFreq,
				numOctaves: args.octaves
			}, args.settings || {}))
		},
		_makeNode: function(element, name, settings) {
			element = element || this._svg;
			var node = this._svg.ownerDocument.createElementNS(
			$.svg.svgNS, name);
			for (var name in settings) {
				var value = settings[name];
				if (value != null && (typeof value != "string" || value != "")) {
					node.setAttribute($.svg._attrNames[name] || name, value)
				}
			}
			element.appendChild(node);
			return node
		},
		add: function(element, node) {
			var args = this._args(arguments, ["node"]);
			var svg = this;
			args.element = args.element || this._svg;
			try {
				if (!$.svg._support) {
					throw "the browser is not support SVG!"
				}
				args.element.appendChild(args.node.cloneNode(true))
			} catch (e) {
				args.node = (args.node.jquery ? args.node : $(args.node));
				args.node.each(function() {
					var child = svg._cloneAsSVG(this);
					if (child) {
						args.element.appendChild(child)
					}
				})
			}
			return this
		},
		_cloneAsSVG: function(node) {
			var newNode = null;
			if (node.nodeType == 1) {
				newNode = this._svg.ownerDocument.createElementNS($.svg.svgNS, this._checkName(node.nodeName));
				for (var i = 0, len = node.attributes.length; i < len; i++) {
					var attr = node.attributes.item(i);
					if (attr.nodeName != "xmlns" && attr.nodeValue) {
						if (attr.prefix == "xlink") {
							newNode.setAttributeNS(
							$.svg.xlinkNS, attr.localName, attr.nodeValue)
						} else {
							newNode.setAttribute(this._checkName(attr.nodeName), attr.nodeValue)
						}
					}
				}
				for (var i = 0, len = node.childNodes.length; i < len; i++) {
					var child = this._cloneAsSVG(node.childNodes[i]);
					if (child) {
						newNode.appendChild(child)
					}
				}
			} else {
				if (node.nodeType == 3) {
					if ($.trim(node.nodeValue)) {
						newNode = this._svg.ownerDocument.createTextNode(node.nodeValue)
					}
				} else {
					if (node.nodeType == 4) {
						if ($.trim(node.nodeValue)) {
							try {
								newNode = this._svg.ownerDocument.createCDATASection(node.nodeValue)
							} catch (e) {
								newNode = this._svg.ownerDocument.createTextNode(node.nodeValue.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"))
							}
						}
					}
				}
			}
			return newNode
		},
		_checkName: function(name) {
			name = (name.substring(0, 1) >= "A" && name.substring(0, 1) <= "Z" ? name.toLowerCase() : name);
			return (name.substring(0, 4) == "svg:" ? name.substring(4) : name)
		},
		load: function(url, settings) {
			settings = (typeof settings == "boolean" ? {
				addTo: settings
			} : (typeof settings == "function" ? {
				onLoad: settings
			} : settings || {}));
			if (!settings.addTo) {
				this.clear(false)
			}
			var size = [this._svg.getAttribute("width"), this._svg.getAttribute("height")];
			var wrapper = this;
			var reportError = function(message) {
					message = "error: " + message;
					if (settings.onLoad) {
						settings.onLoad.apply(wrapper._container, [
						wrapper, message])
					} else {
						wrapper.text(null, 10, 20, message)
					}
				};
			var loadXML4IE = function(data) {
					var xml = new ActiveXObject("Microsoft.XMLDOM");
					xml.validateOnParse = false;
					xml.resolveExternals = false;
					xml.async = false;
					xml.loadXML(data);
					if (xml.parseError.errorCode != 0) {
						reportError(xml.parseError.reason);
						return null
					}
					return xml
				};
			var loadSVG = function(data) {
					if (!data) {
						return
					}
					if (data.documentElement.nodeName != "svg") {
						var errors = data.getElementsByTagName("parsererror");
						var messages = (errors.length ? errors[0].getElementsByTagName("div") : []);
						reportError(!errors.length ? "???" : (messages.length ? messages[0] : errors[0]).firstChild.nodeValue);
						return
					}
					var attrs = {};
					for (var i = 0, len = data.documentElement.attributes.length; i < len; i++) {
						var attr = data.documentElement.attributes.item(i);
						if (!(attr.nodeName == "version" || attr.nodeName.substring(0, 5) == "xmlns")) {
							attrs[attr.nodeName] = attr.nodeValue
						}
					}
					wrapper.configure(attrs, true);
					var nodes = data.documentElement.childNodes;
					for (var i = 0, len = nodes.length; i < len; i++) {
						try {
							if ($.svg._support) {
								throw "The browser is not support SVG!"
							}
							wrapper._svg.appendChild(nodes[i].cloneNode(true))
						} catch (e) {
							wrapper.add(null, nodes[i])
						}
					}
					if (!settings.changeSize) {
						wrapper.configure({
							width: size[0],
							height: size[1]
						})
					}
					if (settings.onLoad) {
						settings.onLoad.apply(wrapper._container, [wrapper])
					}
				};
			if (url.match("<svg")) {
				loadSVG($.browser.msie ? loadXML4IE(url) : new DOMParser().parseFromString(url, "text/xml"))
			} else {
				$.ajax({
					url: url,
					timeout : 10000, //超时时间设置，单位毫秒
					dataType: ($.browser.msie ? "text" : "xml"),
					success: function(xml) {
						loadSVG($.browser.msie ? loadXML4IE(xml) : xml)
					},
					error: function(http, message, exc) {
						reportError(message + (exc ? " " + exc.message : ""))
					}
				})
			}
			return this
		},
		remove: function(element) {
			if (element && element.parentNode) {
				element.parentNode.removeChild(element)
			}
			return this
		},
		clear: function(attrsToo) {
			if (attrsToo) {
				this.configure({}, true)
			}
			while (this._svg.firstChild) {
				this._svg.removeChild(this._svg.firstChild)
			}
			return this
		},
		toSVG: function(element) {
			element = element || this._svg;
			return (typeof XMLSerializer == "undefined" ? this._toSVG(element) : new XMLSerializer().serializeToString(element))
		},
		_toSVG: function(element) {
			var svgDoc = "";
			if (!element) {
				return svgDoc
			}
			if (element.nodeType == 3) {
				svgDoc = element.nodeValue;
				svgDoc = $.string.escapeHTML(svgDoc)
			} else {
				if (element.nodeType == 4) {
					svgDoc = "<![CDATA[" + element.nodeValue + "]]>"
				} else {
					svgDoc = "<" + element.nodeName;
					if (element.attributes) {
						for (var i = 0, len = element.attributes.length; i < len; i++) {
							var attr = element.attributes.item(i);
							if (!($.trim(attr.nodeValue) == "" || attr.nodeValue.match(/^\[object/) || attr.nodeValue.match(/^function/))) {
								svgDoc += " " + (attr.namespaceURI == $.svg.xlinkNS ? "xlink:" : "") + attr.nodeName + '="' + attr.nodeValue + '"'
							}
						}
					}
					if (element.firstChild) {
						svgDoc += ">";
						var child = element.firstChild;
						while (child) {
							svgDoc += this._toSVG(child);
							child = child.nextSibling
						}
						svgDoc += "</" + element.nodeName + ">"
					} else {
						svgDoc += "/>"
					}
				}
			}
			return svgDoc
		},
		_escapeXML: function(text) {
			text = text.replace(/&/g, "&amp;");
			text = text.replace(/</g, "&lt;");
			text = text.replace(/>/g, "&gt;");
			return text
		}
	});

	function SVGPath() {
		this._path = ""
	}
	$.extend(SVGPath.prototype, {
		reset: function() {
			this._path = "";
			return this
		},
		move: function(x, y, relative) {
			relative = (isArray(x) ? y : relative);
			return this._coords((relative ? "m" : "M"), x, y)
		},
		line: function(x, y, relative) {
			relative = (isArray(x) ? y : relative);
			return this._coords((relative ? "l" : "L"), x, y)
		},
		horiz: function(x, relative) {
			this._path += (relative ? "h" : "H") + (isArray(x) ? x.join(" ") : x);
			return this
		},
		vert: function(y, relative) {
			this._path += (relative ? "v" : "V") + (isArray(y) ? y.join(" ") : y);
			return this
		},
		curveC: function(x1, y1, x2, y2, x, y, relative) {
			relative = (isArray(x1) ? y1 : relative);
			return this._coords((relative ? "c" : "C"), x1, y1, x2, y2, x, y)
		},
		smoothC: function(x2, y2, x, y, relative) {
			relative = (isArray(x2) ? y2 : relative);
			return this._coords((relative ? "s" : "S"), x2, y2, x, y)
		},
		curveQ: function(x1, y1, x, y, relative) {
			relative = (isArray(x1) ? y1 : relative);
			return this._coords((relative ? "q" : "Q"), x1, y1, x, y)
		},
		smoothQ: function(x, y, relative) {
			relative = (isArray(x) ? y : relative);
			return this._coords((relative ? "t" : "T"), x, y)
		},
		_coords: function(cmd, x1, y1, x2, y2, x3, y3) {
			if (isArray(x1)) {
				for (var i = 0, len = x1.length; i < len; i++) {
					var cs = x1[i];
					this._path += (i == 0 ? cmd : " ") + cs[0] + "," + cs[1] + (cs.length < 4 ? "" : " " + cs[2] + "," + cs[3] + (cs.length < 6 ? "" : " " + cs[4] + "," + cs[5]))
				}
			} else {
				this._path += cmd + x1 + "," + y1 + (x2 == null ? "" : " " + x2 + "," + y2 + (x3 == null ? "" : " " + x3 + "," + y3))
			}
			return this
		},
		close: function() {
			this._path += "z";
			return this
		},
		path: function() {
			return this._path
		}
	});
	SVGPath.prototype.moveTo = SVGPath.prototype.move;
	SVGPath.prototype.lineTo = SVGPath.prototype.line;
	SVGPath.prototype.horizTo = SVGPath.prototype.horiz;
	SVGPath.prototype.vertTo = SVGPath.prototype.vert;
	SVGPath.prototype.curveCTo = SVGPath.prototype.curveC;
	SVGPath.prototype.smoothCTo = SVGPath.prototype.smoothC;

	function SVGText() {
		this._parts = []
	}
	$.extend(SVGText.prototype, {
		reset: function() {
			this._parts = [];
			return this
		},
		string: function(value) {
			this._parts[this._parts.length] = ["text", value];
			return this
		},
		span: function(value, settings) {
			this._parts[this._parts.length] = ["tspan", value, settings];
			return this
		},
		path: function(pathId, value, settings) {
			this._parts[this._parts.length] = ["textpath", value, $.extend({
				href: pathId
			}, settings || {})];
			return this
		}
	});
	$.fn.svg = function(options) {
		var otherArgs = Array.prototype.slice.call(arguments, 1);
		if (typeof options == "string" && options == "get") {
			return $.svg["_" + options + "SVG"].apply($.svg, [this[0]].concat(otherArgs))
		}
		return this.each(function() {
			if (typeof options == "string") {
				$.svg["_" + options + "SVG"].apply($.svg, [this].concat(otherArgs))
			} else {
				$.svg._attachSVG(this, options || {})
			}
		})
	};
	$.svg = new SVGHandler()
})(jQuery);