///命名空间包定义
var Package;
if (Package && (typeof Package != "object" || Package.NAME)) {
    throw new Error("命名空间已经存在!")
}
Package = {};
Package.NAME = "Package";
Package.VERSION = 0.1;
Package.EXPORT = ["importPackage"];
Package.EXPORT_OK = ["createPackage", "packages", "globalNamespace"];
Package.globalNamespace = this;
Package.packages = {
    "Package": Package
};
Package.createPackage = function(name, version) {
    if (!name) {
        throw new Error("请输入要创建的包名!")
    }
    if (name.charAt(0) == "." || name.charAt(name.length - 1) == "." || name.indexOf("..") != -1) {
        throw new Error("非法的包命名: " + name)
    }
    var parts = name.split(".");
    var container = Package.globalNamespace;
    for (var i = 0; i < parts.length; i++) {
        var part = parts[i];
        if (!container[part]) {
            container[part] = {}
        } else {
            if (typeof container[part] != "object") {
                var n = parts.slice(0, i).join(".");
                throw new Error(n + " 已经存在并且不是一个对象!")
            }
        }
        container = container[part]
    }
    var namespace = container;
    if (namespace.NAME) {
        return
    }
    namespace.NAME = name;
    if (version) {
        namespace.VERSION = version
    }
    Package.packages[name] = namespace;
    return namespace
};
Package.importPackage = function(from) {
    if (typeof from == "string") {
        from = Package.packages[from]
    }
    if (!from || typeof from != "object") {
        throw new Error("请输入要导入的包")
    }
    var to = Package.globalNamespace;
    var symbols = [];
    var firstsymbol = 1;
    if (arguments.length > 1 && typeof arguments[1] == "object") {
        if (arguments[1] != null) {
            to = arguments[1]
        }
        firstsymbol = 2
    }
    for (var a = firstsymbol; a < arguments.length; a++) {
        symbols.push(arguments[a])
    }
    if (symbols.length == 0) {
        if (from.EXPORT) {
            for (var i = 0; i < from.EXPORT.length; i++) {
                var s = from.EXPORT[i];
                to[s] = from[s]
            }
            return
        } else {
            if (!from.EXPORT_OK) {
                for (var s in from) {
                    to[s] = from[s]
                }
                return
            }
        }
    }
    var allowed = null;
    if (from.EXPORT || from.EXPORT_OK) {
        allowed = {};
        if (from.EXPORT) {
            for (var i = 0; i < from.EXPORT.length; i++) {
                allowed[from.EXPORT[i]] = true
            }
        }
        if (from.EXPORT_OK) {
            for (var i = 0; i < from.EXPORT_OK.length; i++) {
                allowed[from.EXPORT_OK[i]] = true
            }
        }
    }
    for (var i = 0; i < symbols.length; i++) {
        var s = symbols[i];
        if (!(s in from)) {
            throw new Error(s + " 未定义!")
        }
        if (allowed && !(s in allowed)) {
            throw new Error(s + " 导入失败!")
        }
        to[s] = from[s]
    }
};
Package.p = Package.createPackage;
Package.i = Package.importPackage;
// /定义topology类
Package.p("hy.topology");
// /hy.topology.Topology
hy.topology.Topology = function() {
    this.status = null;
    this.permission = -1; // 许可
    this.views = null;
    this.view = null;
    this.shapes = null;
    this.events = null;
    this.graphEngine = null;
    this.ui = null;
    this.clipBoard = []; // 剪贴板
    this.changed = null;
    this.contextObj = null;
    this.layout = null;
    this.doPool = null;
    this.xhrPool = null;
    this.callback = null;
    this.config = null;
    this._uuid = null; // 时间
    this.init.apply(this, arguments)
};
hy.topology.Topology.prototype = {
    // 初始化
    saveTopo: function(obj, callback) { // liyang 保存topo
        if (!obj) { // 默认处理
            obj = {
                success: function(data, textStatus, XMLHttpRequest) {
                    //$.lab.exp.exportThumb()
                    closeLodingWindow();
                    layer.msg("保存成功", { icon: 1 });
                    $.topology.changed = {
                        "view": false,
                        "alarmTfr": false,
                        "add": [],
                        "modify": [],
                        "delete": []
                    };
                    $.lab.exp.exportThumb(); //保存新图片
                    $.topology.ui.eagleEye.init();
                    // $.lab.topo.stateRefresh();
                    if (callback) {
                        callback();
                    }
                },
                error: function(XMLHttpRequest, textStatus, errorThrown) {
                    layer.msg("保存拓扑图失败, " + $.converter.requestError(XMLHttpRequest, textStatus), { icon: 2 });
                }
            }
        }
        $.ajax({
            url: ctx + "/network/saveData.do",
            timeout: 60000, //超时时间设置，单位毫秒
            method: "POST",
            data: {"topoData":this.serialize() ,"_csrf":_csrftoken},
            dataType: "json",
            success: obj.success,
            error: obj.error
        });
    },
    init: function() { // 初始化拓扑
        this.views = {}; // 视图
        this.shapes = { // 形状
            "symbols": {},
            "containers": {},
            "lines": {},
            "lineseters": {}
        };
        this.changed = { // 改变
            "view": false,
            "alarmTfr": false,
            "add": [],
            "modify": [],
            "delete": []
        };
        this.events = {};
        this.ui = {};
        this.ui.VIEW_DRAG_ACTION_SELECT = "select";
        this.ui.VIEW_DRAG_ACTION_MOVE = "move";
        this.ui.viewDragAction = this.ui.VIEW_DRAG_ACTION_SELECT;
        this.lastClickPoint = null;
        this.config = {
            global: null,
            plugin: null,
            context: null,
            status: null,
            kpi: null,
            graph: null,
            objectClass: null,
            gridSnapping: true
        };
        this.xhrPool = {
            kpiXhr: null,
            eventXhr: null,
            availabilityXhr: null,
            searchXhr: null
        };
        this.loadGlobalConfig(); // 加载全局配置
        this.loadObjectClassConfig(); // 加载对象
        this.selector.init(this); // 初始化选取器
        this.floator.init(this); // 初始化floator
        this._uuid = new Date().getTime(); // 获取时间
    },
    reset: function(callback) {
        this.selector.reset();
        var $topo = this;
        this.graphEngine.reset(function() {
            $topo.permission = -1;
            $topo.view = null;
            $topo.shapes = {
                "symbols": {},
                "containers": {},
                "lines": {},
                "lineseters": {}
            };
            $topo.changed = {
                "view": false,
                "alarmTfr": false,
                "add": [],
                "modify": [],
                "delete": []
            };
            $topo.events = {};
            $topo.contextObj = null;
            $topo.doPool = null;
            $topo.ui.viewDragAction = $topo.ui.VIEW_DRAG_ACTION_SELECT;
            if (typeof callback === "function") {
                callback()
            }
        })
    },
    loadGlobalConfig: function() { // 加载全局配置
        this.config["global"] = topoData.config.global
    },
    loadPluginConfig: function(topo) {
        this.config["plugin"] = topoData.config.plugin
    },
    loadContextConfig: function(objClses) {
        this.config["context"] = topoData.config.context
    },
    loadGraphConfig: function() {
        this.config["graph"] = topoData.config.graph
    },
    loadKpiConfig: function(type) {
        this.config["kpi"] = topoData.config.kpi
    },
    iconConfig: function() {
        return topoData.config.icon
    },
    validatePermission: function(vid, callback) {
        if (!vid) {
            return
        }
    },
    validateAddViewPermission: function(callback) {},
    loadViews: function(options) {
        options = options || {};
        var __views = topoData.views,
            __view = null,
            $topo = $.topology;
        for (var i = 0, len = __views.length; i < len; i++) {
            __view = __views[i];
            $topo.views[__view.id] = __view
        }
        if (options.success && $.isFunction(options.success)) {
            options.success.apply(this, null)
        }
    },
    loadTopo: function(vid, callback) {
        var $topo = this;
        if (!vid) {
            return
        }
        var _data = topoData.view[vid],
            shapes = $topo.shapes;


        $topo.view = new hy.topology.model.View(_data.view);
        for (var i = 0, len = _data.symbols.length; i < len; i++) {
            var node = _data.symbols[i],
                type = String(node.type);
            switch (type) {
                case "1":
                    shapes.containers[node.id] = new hy.topology.model.Container(node);
                    break;
                case "0":
                default:
                    shapes.symbols[node.id] = new hy.topology.model.Symbol(node);
                    break
            }
        }
        for (var i = 0, len = _data.lines.length; i < len; i++) {
            var line = _data.lines[i],
                type = String(line.type);
            switch (type) {
                case "1":
                    shapes.lineseters[line.id] = new hy.topology.model.Lineseter(line);
                    break;
                case "0":
                default:
                    shapes.lines[line.id] = new hy.topology.model.Line(line);
                    break
            }
        }
        if ($topo.config.global["screen_adapter"] === "fill") {
            $topo.view.option["adapter"] = "1"
        }

        $topo._drawTopo();

        var lineseters = shapes.lineseters,
            lineseter, _f_isSymbol = $topo.isSymbol,
            _f_findLines = $topo.findLines;
        for (var id in lineseters) {
            lineseter = lineseters[id];
            if (!lineseter) {
                continue
            }
            if (lineseter.state == 1) {
                lineseter.collapse()
            }
            var isSrcSymbol = _f_isSymbol.call($topo, lineseter.srcNode),
                isDstSymbol = _f_isSymbol.call($topo, lineseter.dstNode);
            if (lineseter.state == 2 && (isSrcSymbol || isDstSymbol)) {
                var _symbolNode = isSrcSymbol ? lineseter.srcNode : lineseter.dstNode;
                var _containerNode = isSrcSymbol ? lineseter.dstNode : lineseter.srcNode;
                for (var cid in _containerNode.children) {
                    var symbolInCtn = _containerNode.children[cid];
                    var subLines = _f_findLines.call($topo, symbolInCtn, _symbolNode);
                    for (var i = 0, len = subLines.length; i < len; i++) {
                        var subLine = subLines[i];
                        lineseter.children[subLine.id] = subLine
                    }
                }
            }
        }
        $topo.changed = {
            "view": false,
            "alarmTfr": false,
            "add": [],
            "modify": [],
            "delete": []
        };
        // if ($topo.status == "SHOW") {
        $topo.graphEngine.bindTopologyShowEvents()
        // }
        if (callback.success && $.isFunction(callback.success)) {
            callback.success.apply(this, null)
        }
    },
    loadKpi: function(callback) {
        var _data = topoData.kpi[$.topology.view.id],
            shapes = $.topology.shapes,
            element = null,
            elementsIdExistKpi = [];
        for (var id in _data) {
            for (var name in shapes) {
                element = shapes[name][id];
                if (element) {
                    break
                } else {
                    continue
                }
            }
            if (element) {
                if (!element.kpis) {
                    element.kpis = _data[id]
                } else {
                    if ($.isEmptyObject(element.kpis)) {
                        element.kpis = _data[id]
                    } else {
                        element.kpis = $.extend(true, element.kpis, _data[id])
                    }
                }
            }
            elementsIdExistKpi.push(id)
        }
        var ids = "," + elementsIdExistKpi.join(",") + ",",
            dontClearAttr = ["EventTotal", "EventLevel", "Availability"];
        for (var name in shapes) {
            if (name === "containers" || name === "lineseters") {
                continue
            }
            for (var id in shapes[name]) {
                element = shapes[name][id];
                var reg = RegExp("," + id + ",", "g");
                if (ids.search(reg) === -1 && element.kpis) {
                    for (var kpiName in element.kpis) {
                        if ($.inArray(kpiName, dontClearAttr) === -1) {
                            element.kpis[kpiName] = null
                        }
                    }
                }
            }
        }
        $.topology._lineKpiMapping();
        if (callback.success && $.isFunction(callback.success)) {
            callback.success.apply(this, null)
        }
        if (callback.complete && $.isFunction(callback.complete)) {
            callback.complete.apply(this, null)
        }
    },
    loadEvent: function(filterIds, callback) {
        var _data = topoData.event[$.topology.view.id],
            shapes = $.topology.shapes,
            element = null,
            elementsIdExistEvent = [];
        if (filterIds && $.isArray(filterIds)) {
            for (var i = 0, len = filterIds.length; i < len; i++) {
                delete _data.events[filterIds[i]]
            }
        }
        $.topology.events = _data.events;
        for (var id in _data.symbolEventIds) {
            var obj = shapes.symbols[id],
                isSymbol = true;
            if (obj) {
                element = obj
            } else {
                element = shapes.containers[id];
                isSymbol = false
            }
            if (!element) {
                continue
            }
            if ($.inArray(_data.symbolEventIds[id][0], filterIds) !== -1) {
                element.eventIds = [];
                if (!element.kpis) {
                    element.kpis = {}
                }
                // element.kpis["EventTotal"] = null;
                element.kpis["EventLevel"] = null;
                elementsIdExistEvent.push(id)
            } else {
                element.eventIds = _data.symbolEventIds[id];
                if (!element.kpis) {
                    element.kpis = {}
                }
                // element.kpis["EventTotal"] = element.eventIds.length !== 0 ?
                // element.eventIds.length : null;
                element.kpis["EventLevel"] = _data.symbolEventStatus[id];
                elementsIdExistEvent.push(id)
            }
        }
        for (var id in _data.lineEventIds) {
            var obj = shapes.lines[id],
                isLine = true;
            if (obj) {
                element = obj
            } else {
                element = shapes.lineseters[id];
                isLine = false
            }
            if (!element) {
                continue
            }
            if ($.inArray(_data.lineEventIds[id][0], filterIds) !== -1) {
                element.eventIds = [];
                if (!element.kpis) {
                    element.kpis = {}
                }
                // element.kpis["EventTotal"] = null;
                element.kpis["EventLevel"] = null;
                elementsIdExistEvent.push(id)
            } else {
                element.eventIds = _data.lineEventIds[id];
                if (!element.kpis) {
                    element.kpis = {}
                }
                // element.kpis["EventTotal"] = element.eventIds.length !== 0 ?
                // element.eventIds.length : null;
                element.kpis["EventLevel"] = _data.lineEventStatus[id];
                elementsIdExistEvent.push(id)
            }
        }
        var ids = "," + elementsIdExistEvent.join(",") + ",";
        for (var name in shapes) {
            for (var id in shapes[name]) {
                element = shapes[name][id];
                var reg = RegExp("," + id + ",", "g");
                if (ids.search(reg) === -1) {
                    element.eventIds = null;
                    if (element.kpis) {
                        // element.kpis["EventTotal"] = null;
                        element.kpis["EventLevel"] = null
                    }
                }
            }
        }
        $.topology.eventTransmit();
        $.topology.eventRender();
        if (callback.success && $.isFunction(callback.success)) {
            callback.success.apply(this, null)
        }
        if (callback.complete && $.isFunction(callback.complete)) {
            callback.complete.apply(this, null)
        }
    },
    loadStatus: function(callback) {
        var idArr = [],
            ajaxArr = [],
            $path = $.project.path,
            $status = $.topology.config.status;
        $.topology.clearStatus();
        $.each($status, function(_id, cfg) {
            if (cfg.binding && cfg.callback) {
                idArr.push(_id);
                var _data = {
                    statusId: _id,
                    viewId: $.topology.view.id
                };
                if (cfg.params) {
                    $.each(cfg.params, function(key, val) {
                        _data[key] = val
                    })
                }
                ajaxArr.push($.ajax({
                    url: $path + cfg.binding,
                    timeout: 60000, //超时时间设置，单位毫秒
                    type: "POST",
                    data: _data,
                    dataType: "json"
                }))
            }
        });
        $.when(ajaxArr).then(function(jqXhrArr) {
                var _callbackData = {};
                $.each(idArr, function(i, _id) {
                    jqXhrArr[i].success(function(data, textStatus, XMLHttpRequest) {
                        if (data.success) {
                            _callbackData[_id] = data && data.data ? data.data : null;
                            eval($status[_id].callback).call(this, _id, _callbackData[_id]);
                            if (i === idArr.length - 1 && callback.success && $.isFunction(callback.success)) {
                                callback.success.apply(this, [_callbackData])
                            }
                        }
                    })
                })
            },
            function() {
                if (callback.error && $.isFunction(callback.error)) {
                    callback.error.apply()
                }
            })
    },
    clearStatus: function() {
        var $shapes = $.topology.shapes,
            isClearAll = arguments.length === 0,
            clearCode = null;
        if (!isClearAll && arguments[0] && $.isArray(arguments[0])) {
            clearCode = arguments[0]
        } else {
            isClearAll = true
        }
        $.each($shapes, function(type, objs) {
            $.each(objs, function(id, obj) {
                if (isClearAll) {
                    obj.status = {}
                } else {
                    $.each(clearCode, function(i, code) {
                        delete obj.status[code]
                    })
                }
            })
        })
    },
    isChanged: function() {
        var changed = this.changed,
            changedCount = changed["add"].length + changed["modify"].length + changed["delete"].length;
        return changed.view || changedCount > 0
    },
    serialize: function() {
        var cache = "{",
            topo = $.topology;
        if (topo.changed["view"]) {
            cache += '"view":' + topo.view.serialize() + ","
        } else {
            cache += '"view":{"id":"' + topo.view.id + '"},'
        }
        var isModifyAlarmTfr = topo.changed.alarmTfr,
            addSymbols = "[",
            addLines = "[",
            modifySymbols = "[",
            modifyLines = "[",
            deleteSymbols = [],
            deleteLines = [],
            id = null,
            name = null;
        if (!isModifyAlarmTfr && (topo.changed["add"].length > 0 || topo.changed["delete"].length > 0)) {
            isModifyAlarmTfr = true
        }
        for (name in topo.shapes) {
            var type = {
                "symbols": "s",
                "containers": "s",
                "lines": "l",
                "lineseters": "l"
            }[name] || "";
            if (type === "") {
                continue
            }
            for (id in topo.shapes[name]) {
                if ($.inArray(id, topo.changed["add"]) !== -1) {
                    if (type === "s") {
                        addSymbols += topo.shapes[name][id].serialize() + ","
                    } else {
                        if (type === "l") {
                            addLines += topo.shapes[name][id].serialize() + ","
                        }
                    }
                } else {
                    if ($.inArray(id, topo.changed["modify"]) !== -1) {
                        if (type === "s") {
                            modifySymbols += topo.shapes[name][id].serialize() + ","
                        } else {
                            if (type === "l") {
                                modifyLines += topo.shapes[name][id].serialize() + ","
                            }
                        }
                    }
                }
            }
        }
        addSymbols = addSymbols.length === 1 ? "[]" : (addSymbols.substr(0, addSymbols.length - 1) + "]");
        addLines = addLines.length === 1 ? "[]" : (addLines.substr(0, addLines.length - 1) + "]");
        modifySymbols = modifySymbols.length === 1 ? "[]" : (modifySymbols.substr(0, modifySymbols.length - 1) + "]");
        modifyLines = modifyLines.length === 1 ? "[]" : (modifyLines.substr(0, modifyLines.length - 1) + "]");
        var deleteElement = topo.changed["delete"],
            o;
        for (var i in deleteElement) {
            o = deleteElement[i];
            if (o && o.id) {
                if (topo.isSymbol(o) || topo.isContainer(o)) {
                    deleteSymbols.push(o.id)
                } else {
                    if (topo.isLine(o) || topo.isLineseter(o)) {
                        deleteLines.push(o.id)
                    }
                }
            }
        }
        cache += '"symbols":{';
        cache += '"add":' + addSymbols + ',"modify":' + modifySymbols + ',"delete":[' + deleteSymbols.join(",") + "]";
        cache += '},"lines":{';
        cache += '"add":' + addLines + ',"modify":' + modifyLines + ',"delete":[' + deleteLines + "]";
        cache += '},"alarmTfr":' + (isModifyAlarmTfr ? 1 : 0) + "}";

        return cache
    },
    find: function(id, exp) {
        var obj = null,
            types = [],
            _shapes = $.topology.shapes;
        if (!exp || $.trim(exp) === "") {
            types = ["symbol", "container", "line", "lineseter"]
        } else {
            types = exp.toLowerCase().split("|")
        }
        for (var i = 0, len = types.length; i < len; i++) {
            for (var key in _shapes[types[i] + "s"]) {
                if (key == id) {
                    obj = _shapes[types[i] + "s"][key];
                    break
                }
            }
        }
        return obj
    },
    findLines: function(symbol1, symbol2) {
        var lines = [];
        if (this.isSymbol(symbol1) && this.isSymbol(symbol2)) {
            var lines1 = symbol1.lines,
                line = null,
                other = null;
            for (var id in lines1) {
                line = lines1[id];
                if (!line.srcNode || !line.dstNode) {
                    continue
                }
                other = line.srcNode.id == symbol1.id ? line.dstNode : line.srcNode;
                if (other && other.id && other.id == symbol2.id && this.isLine(line)) {
                    lines.push(line)
                }
            }
        }
        return lines
    },
    findLineseter: function(node1, node2) {
        var lineseter = null;
        if ((this.isSymbol(node1) || this.isContainer(node1)) && ((this.isSymbol(node2) || this.isContainer(node2)))) {
            var lines1 = null,
                line = null,
                other = null;
            if (this.isSymbol(node1)) {
                lines1 = node1.lines
            } else {
                lines1 = node1.lineseters
            }
            for (var id in lines1) {
                line = lines1[id];
                if (!line.srcNode || !line.dstNode) {
                    continue
                }
                other = line.srcNode.id == node1.id ? line.dstNode : line.srcNode;
                if (other && other.id && other.id == node2.id && this.isLineseter(line)) {
                    lineseter = line;
                    break
                }
            }
        }
        return lineseter
    },
    findLinesByObjectId: function(objectId) {
        var lines = [];
        var line;
        for (var id in this.shapes.lines) {
            line = this.shapes.lines[id];
            if (line.objectId == objectId) {
                lines.push(line)
            }
        }
        return lines
    },
    findSymbolsByObjectId: function(objectId) {
        var symbols = [];
        var symbol;
        for (var id in this.shapes.symbols) {
            symbol = this.shapes.symbols[id];
            if (symbol.objectId == objectId && !symbol.instanceId) {
                symbols.push(symbol)
            }
        }
        return symbols
    },
    createSymbol: function(data) {
        if (!data) {
            data = {}
        }
        data.id = this.uuid();
        var symbol = new hy.topology.model.Symbol(data);
        return symbol
    },
    createContainer: function(data) {
        if (!data) {
            data = {}
        }
        data.id = this.uuid();
        var container = new hy.topology.model.Container(data);
        return container
    },
    createLine: function(data) {
        if (!data) {
            data = {}
        }
        data.id = this.uuid();
        data.type = "0";
        var line = new hy.topology.model.Line(data);
        line.option["custom-label"] = "0";
        return line
    },
    createCurveLine: function(data) { // 创建曲线
        if (!data) {
            data = {}
        }
        data.id = this.uuid();
        data.type = "0";
        var line = new hy.topology.model.Line(data); // 线模型
        line.option["custom-label"] = "0";
        return line
    },
    createLineseter: function(data) {
        if (!data) {
            data = {}
        }
        data.id = this.uuid();
        var lineseter = new hy.topology.model.Lineseter(data);
        lineseter.option["custom-label"] = 0;
        return lineseter
    },
    getEventColor: function(level) {
        return {
            "5": "red",
            "4": "rgb(255, 127, 0)",
            "3": "yellow",
            "2": "rgb(0, 255, 255)"
        }[String(level)]
    },
    getIcon: function(objectClass) {
        if (typeof objectClass !== "string") {
            return null
        }
        var g = this.config.graph[objectClass];
        var icon = null;
        if (g && (g.type === "ICON")) {
            icon = {
                path: g.icon,
                width: g.width || 32,
                height: g.height || 32
            }
        }
        return icon
    },
    getAllObjectClass: function() {
        var ocs = [],
            o, oc;
        var tmp = {};
        var _s = $.topology.shapes;
        for (var type in _s) {
            for (var id in _s[type]) {
                o = _s[type][id];
                oc = null;
                oc = o.getObjectClass();
                if (oc && oc != -1) {
                    tmp[oc] = null
                }
            }
        }
        for (var k in tmp) {
            ocs.push(k)
        }
        return ocs
    },
    loadObjectClassConfig: function() {
        var config = this.config;
        config["objectClass"] = topoData.config.objectClass
    },
    getObjectClassInfo: function(id) {
        var config = this.config;
        if (config && config["objectClass"]) {
            return config["objectClass"][id]
        } else {
            return null
        }
        return config && config["objectClass"] && config["objectClass"][id]
    },
    focus: function(elementIds) {
        var elements = [];
        if (!$.isArray(elementIds)) {
            elementIds = [elementIds]
        }
        var element;
        for (var i = 0; i < elementIds.length; i++) {
            element = this.find(elementIds[i]);
            if (element) {
                if (this.show(element)) {
                    elements.push(element)
                }
            }
        }
        if (elements.length > 0) {
            var nodesBBox = this.getNodesBBox(elements);
            if (nodesBBox) {
                var viewport = this.view.viewport();
                if (nodesBBox.width > viewport.width || nodesBBox.height > viewport.height) {
                    this.view.viewport(nodesBBox.minX, nodesBBox.minY, nodesBBox.width, nodesBBox.height)
                } else {
                    var scale = this.view.scale();
                    var centerX = nodesBBox.minX + nodesBBox.width / 2,
                        centerY = nodesBBox.minY + nodesBBox.height / 2;
                    this.view.scale(scale, -centerX, -centerY, true)
                }
                this.selector.select(elementIds)
            }
        } else {
            this.selector.select()
        }
    },
    show: function(element) {
        if (typeof element === "string") {
            element = this.find(element)
        }
        if (!element || element.visible) {
            return true
        }
        var parent = element.parent;
        if (this.isSymbol(element)) {
            if (parent && parent.isPermit && !parent.isExpand) {
                parent.expand()
            }
        } else {
            if (this.isLine(element)) {
                var srcNode = element.srcNode,
                    dstNode = element.dstNode;
                if (srcNode) {
                    this.show(srcNode)
                }
                if (dstNode) {
                    this.show(dstNode)
                }
                if (parent && parent.state == 1 && !parent.isExpand) {
                    parent.expand()
                }
            } else {
                if (this.isLineseter(element)) {
                    var srcNode = element.srcNode,
                        dstNode = element.dstNode;
                    if (element.state == 1) {
                        if (srcNode) {
                            this.show(srcNode)
                        }
                        if (dstNode) {
                            this.show(dstNode)
                        }
                        if (element.isExpand) {
                            element.collapse()
                        }
                    } else {
                        if (this.isContainer(srcNode) && srcNode.isPermit && srcNode.isExpand) {
                            srcNode.collapse()
                        }
                        if (this.isContainer(dstNode) && srcNode.isPermit && dstNode.isExpand) {
                            dstNode.collapse()
                        }
                        if (this.isSymbol(srcNode)) {
                            this.show(srcNode)
                        }
                        if (this.isSymbol(dstNode)) {
                            this.show(dstNode)
                        }
                    }
                }
            }
        }
        return element.visible
    },
    updateVirtualLine: function() { // 更新实际线
        function isInContainer(symbol, container) {
            return symbol.parent ? symbol.parent.id == container.id : false
        }

        function isExistLines(topology, container, symbol) {
            var lines = symbol.lines,
                line;
            for (var id in lines) {
                line = lines[id];
                if (topology.isLine(line)) {
                    var other = line.otherNode(symbol);
                    if (other.parent && other.parent.id == container.id) {
                        return true
                    }
                }
            }
            return false
        }

        function createVirtualLine(topology, from, to) {
            var p = [],
                fromCoords = from.getCenterCoords(),
                toCoords = to.getCenterCoords();
            p[0] = [fromCoords.x, fromCoords.y];
            p[1] = [toCoords.x, toCoords.y];
            var visible = true;
            if (($.topology.isContainer(from) && from.isExpand) || ($.topology.isContainer(to) && to.isExpand)) {
                visible = false
            }
            var containerLineseter = new hy.topology.model.Lineseter();
            containerLineseter.name = from.getName() + "->" + to.getName();
            containerLineseter.setPath(topology.graphEngine.path(p));
            containerLineseter.srcNode = from;
            containerLineseter.dstNode = to;
            containerLineseter.state = 2;
            containerLineseter.visible = visible;
            containerLineseter.add();
            from.addRelationLine(containerLineseter);
            to.addRelationLine(containerLineseter);
            return containerLineseter
        }

        function containerSymbolVirtualLine(topology, container, symbol, line) {
            var fromContainer = container,
                to = symbol;
            var containerLineseter = topology.findLineseter(fromContainer, to);
            if (!containerLineseter) {
                containerLineseter = createVirtualLine(topology, fromContainer, to)
            }
            var child = null;
            if (!line.parent) {
                child = line
            } else {
                if (line.parent.state == 1 && !line.parent.parent) {
                    child = line.parent
                }
            }
            if (child) {
                containerLineseter.addChild(child, false);
                child.change()
            }
            return containerLineseter
        }
        var lineseters = this.shapes.lineseters,
            lineseter;
        for (var lid in lineseters) {
            lineseter = lineseters[lid];
            var from = lineseter.srcNode,
                to = lineseter.dstNode;
            if (lineseter.state == 1 || !from || !to) {
                continue
            }
            var isFromContainer = this.isContainer(from),
                isToContainer = this.isContainer(to);
            if (isFromContainer && !isToContainer) {
                if (isInContainer(to, from) || !isExistLines(this, from, to)) {
                    lineseter.remove();
                    continue
                }
            } else {
                if (!isFromContainer && isToContainer) {
                    if (isInContainer(from, to) || !isExistLines(this, to, from)) {
                        lineseter.remove();
                        continue
                    }
                } else {
                    if (isFromContainer && isToContainer) {
                        var children = from.children,
                            child, hasLine = false;
                        for (var sid in children) {
                            child = children[sid];
                            if (isExistLines(this, to, child)) {
                                hasLine = true;
                                break
                            }
                        }
                        if (!hasLine) {
                            lineseter.remove()
                        }
                    }
                }
            }
        }
        var lines = this.shapes.lines,
            line;
        for (var lid in lines) {
            line = lines[lid];
            var from = line.srcNode,
                to = line.dstNode,
                fromContainer = null,
                toContainer = null;
            if (!from || !to) {
                continue
            }
            fromContainer = from.parent;
            toContainer = to.parent;
            if (fromContainer && toContainer && fromContainer.id == toContainer.id) {
                continue
            }
            var fromLineseter = null,
                toLineseter = null;
            if (fromContainer) {
                fromLineseter = containerSymbolVirtualLine(this, fromContainer, to, line)
            }
            if (toContainer) {
                toLineseter = containerSymbolVirtualLine(this, toContainer, from, line)
            }
            if (fromContainer && toContainer) {
                var containerLineseter = this.findLineseter(fromContainer, toContainer);
                if (!containerLineseter) {
                    containerLineseter = createVirtualLine(this, fromContainer, toContainer)
                }
                if (fromLineseter) {
                    containerLineseter.addChild(fromLineseter, false)
                }
                if (toLineseter) {
                    containerLineseter.addChild(toLineseter, false)
                }
            }
        }
    },
    isView: function(element) {
        if (element instanceof hy.topology.model.View) {
            return true
        } else {
            return element == this.view.id
        }
    },
    isSymbol: function(element) {
        if (typeof element === "string") {
            element = this.find(element, "symbol")
        }
        return element instanceof hy.topology.model.Symbol
    },
    isNode: function(element) {
        return this.isSymbol(element) || this.isContainer(element)
    },
    isContainer: function(element) {
        if (typeof element === "string") {
            element = this.find(element, "container")
        }
        return element instanceof hy.topology.model.Container
    },
    isLine: function(element) {
        if (typeof element === "string") {
            element = this.find(element, "line")
        }
        return element instanceof hy.topology.model.Line
    },
    isLineseter: function(element) {
        if (typeof element === "string") {
            element = this.find(element, "lineseter")
        }
        return element instanceof hy.topology.model.Lineseter
    },
    getNodesBBox: function(nodes) {
        if (!nodes || !$.isArray(nodes)) {
            return null
        }
        var nodeBBoxs = [];
        for (var i = 0, len = nodes.length; i < len; i++) {
            nodeBBoxs.push($.extend({}, nodes[i].getBBox()))
        }
        return this.getMaxBBox(nodeBBoxs)
    },
    getNodesIconBBox: function(nodes) {
        if (!nodes || !$.isArray(nodes)) {
            return null
        }
        var nodeBBoxs = [];
        for (var i = 0, len = nodes.length; i < len; i++) {
            nodeBBoxs.push($.extend({}, nodes[i].getIconBBox()))
        }
        return this.getMaxBBox(nodeBBoxs)
    },
    getMaxBBox: function(bboxs) {
        if (!bboxs || !$.isArray(bboxs)) {
            return null
        }
        var minX = null,
            minY = null,
            maxX = null,
            maxY = null;
        for (var i = 0, len = bboxs.length; i < len; i++) {
            var bbox = bboxs[i];
            if (minX == null) {
                minX = bbox.minX;
                minY = bbox.minY;
                maxX = bbox.maxX;
                maxY = bbox.maxY
            } else {
                minX = Math.min(minX, bbox.minX);
                minY = Math.min(minY, bbox.minY);
                maxX = Math.max(maxX, bbox.maxX);
                maxY = Math.max(maxY, bbox.maxY)
            }
        }
        if (isNaN(minX) || isNaN(minY) || isNaN(maxX) || isNaN(maxY)) {
            return null
        }
        return {
            minX: minX,
            minY: minY,
            maxX: maxX,
            maxY: maxY,
            width: maxX - minX,
            height: maxY - minY
        }
    },
    length: function(type) {
        var len = 0;
        if (arguments.length === 0) {
            for (var name in this.shapes) {
                len += $.objAttrLength(this.shapes[name])
            }
        } else {
            len = $.objAttrLength(this.shapes[type + "s"])
        }
        return len
    },
    addElement: function(element) { // 添加元素
        if (!element) {
            return
        }
        var id = String(element.id) || this.uuid();
        if (isNaN(Number(id))) {
            if ($.inArray(id, this.changed["add"]) === -1) {
                this.changed["add"].push(id)
            }
        }
        var type = "";
        if (this.isSymbol(element)) {
            type = "symbol"
        } else {
            if (this.isContainer(element)) {
                type = "container"
            } else {
                if (this.isLine(element)) {
                    type = "line"
                } else {
                    if (this.isLineseter(element)) {
                        type = "lineseter"
                    } else {
                        return
                    }
                }
            }
        }
        this.shapes[type + "s"][element.id] = element;
        $(this).triggerHandler("addElement", element)
    },
    changeElement: function(element) { // 改变元素
        if (!element || !element.id) {
            return
        }
        var id = String(element.id);
        if (!isNaN(Number(id))) {
            if ($.inArray(id, this.changed["modify"]) === -1) {
                this.changed.modify.push(id)
            }
        } else { // 保存后，新加节点转换为固有节点，再次修改时会无法判断，加了这段很可能出现bug
            if ($.inArray(id, this.changed["add"]) === -1) {
                this.changed.modify.push(id)
            }
        }
        $(this).triggerHandler("changeElement", element)
    },
    removeElement: function(element) {
        var type = "",
            id = "";
        if (this.isSymbol(element)) {
            type = "symbol"
        } else {
            if (this.isContainer(element)) {
                type = "container"
            } else {
                if (this.isLine(element)) {
                    type = "line"
                } else {
                    if (this.isLineseter(element)) {
                        type = "lineseter"
                    } else {
                        return
                    }
                }
            }
        }
        id = String(element.id);
        if (isNaN(Number(id))) {
            this.changed["add"] = $.grep(this.changed["add"], function(n, i) {
                return n !== id
            })
        } else {
            if ($.inArray(element, this.changed["delete"]) === -1) {
                this.changed["delete"].push(element)
            }
            this.changed["modify"] = $.grep(this.changed["modify"], function(n, i) {
                return n !== id
            })
        }
        delete this.shapes[type + "s"][id];
        $(this).triggerHandler("removeElement", id);
        this.selector.reset()
    },
    eventTransmit: function() {
        var lineseter = null,
            eventIds = null,
            $topo = $.topology;
        for (var id in $topo.shapes.lineseters) {
            var eventLevel = 0;
            lineseter = $topo.shapes.lineseters[id];
            eventIds = $topo._getChildrenEvents(lineseter);
            lineseter.eventIds = eventIds;
            if (!lineseter.kpis) {
                lineseter.kpis = {}
            }
            lineseter.kpis["EventTotal"] = eventIds.length !== 0 ? eventIds.length : null;
            for (var i = 0, len = eventIds.length; i < len; i++) {
                var event = $topo.events[eventIds[i]];
                if (event && parseInt(event.level) > eventLevel) {
                    eventLevel = parseInt(event.level)
                }
            }
            lineseter.kpis["EventLevel"] = eventLevel
        }
    },
    _getChildrenEvents: function(lineseter) {
        // 线组器子资源状态
        var $events = $.topology.events,
            values = [],
            children = lineseter.children,
            child = null,
            filter = $.topology.config.global["event_filter"];
        // for ( var id in children) {
        // child = children[id];
        // var _v = $.topology.isLineseter(child) ? $.topology._getChildrenEvents(child)
        // : child.eventIds, oriId = null, ids = [];
        // if (!_v) {
        // continue
        // }
        // for (var i = 0, len = _v.length; i < len; i++) {
        // oriId = _v[i];
        // var cloneId = oriId.split("-")[0] + "-1-" + lineseter.id, cloneEvent =
        // $.extend({}, $events[oriId]),
        // tfrStatus = child.alarm["tfr-status-param"] || "0", tfrLevel =
        // child.alarm["tfr-min-level"] || "1";
        // if (parseInt(cloneEvent.level) < parseInt(tfrLevel)) {
        // continue
        // }
        // if (cloneEvent && $.isPlainObject(cloneEvent)) {
        // cloneEvent.id = cloneId;
        // cloneEvent.transfer = "1";
        // var level = parseInt(cloneEvent.level) + parseInt(tfrStatus);
        // if (level < 1) {
        // level = 1
        // } else {
        // if (level > 5) {
        // level = 5
        // }
        // }
        // cloneEvent.level = level;
        // if (!!filter && filter.split(level).length === 1) {
        // continue
        // }
        // ids.push(cloneId);
        // $events[cloneId] = cloneEvent
        // }
        // }
        // values = values.concat(ids)
        // }
        return $.array.unique(values)
    },
    eventRender: function(useNativeRender, animateEnabled) {
        var $ge = $.topology.graphEngine;
        var isIE9 = $.browser.msie && $.browser.version == 9;
        useNativeRender = typeof useNativeRender === "boolean" ? useNativeRender : !isIE9;
        animateEnabled = typeof animateEnabled === "boolean" ? animateEnabled : true;

        function removeEventNativeRender() {
            var shapes = $.topology.shapes;
            for (var name in shapes) {
                var elements = shapes[name];
                var element;
                for (var id in elements) {
                    element = elements[id];
                    $ge.eventAnimationRender(element.id, name, null);
                    $ge.eventColorRender(element.id, name, null)
                }
            }
        }

        function removeEventJsRender() {
            for (var name in $.topology.shapes) {
                var elements = $.topology.shapes[name];
                var element;
                for (var id in elements) {
                    element = elements[id];
                    $ge.eventAnimationRender4IE9(element.id, name, null);
                    $ge.eventColorRender4IE9(element.id, name, null)
                }
            }
        }

        function getEventElementWraps() {
            var animateLevels = $.topology.config.global["event_animate"].split(","),
                _shapes = $.topology.shapes;
            var s = [];
            for (var name in _shapes) {
                var elements = _shapes[name];
                var element, currLevel, elementWrap;
                for (var id in elements) {
                    element = elements[id], currLevel = element.kpis && element.kpis["EventLevel"];
                    if (currLevel) {
                        currLevel = String(currLevel);
                        elementWrap = {
                            target: element,
                            type: name,
                            eventLevel: currLevel
                        };
                        if (element.alarm && element.alarm.render && element.alarm.render === "animation") {
                            if ($.inArray(currLevel, animateLevels) !== -1) {
                                elementWrap.eventRender = animateEnabled ? "animation" : "matrix"
                            } else {
                                element.alarm.render = "matrix";
                                elementWrap.eventRender = "matrix"
                            }
                        } else {
                            elementWrap.eventRender = "matrix";
                            // elementWrap.eventRender = "animation"//动画效果
                        }
                        s.push(elementWrap)
                    }
                }
            }
            return s
        }

        function renderEvents(elementWraps) {
            var e, isAnimationSupport = $.topology.graphEngine.support.animation;
            for (var i = 0; i < elementWraps.length; i++) {
                e = elementWraps[i];
                if (e.eventRender === "animation" && isAnimationSupport) {
                    $ge.eventAnimationRender(e.target.id, e.type, e.eventLevel)
                } else {
                    $ge.eventColorRender(e.target.id, e.type, e.eventLevel)
                }
            }
        }

        function renderEvents4IE9(elementWraps) {
            var e;
            for (var i = 0; i < elementWraps.length; i++) {
                e = elementWraps[i];
                if (e.eventRender === "animation") {
                    $ge.eventAnimationRender4IE9(e.target.id, e.type, e.eventLevel)
                } else {
                    $ge.eventColorRender4IE9(e.target.id, e.type, e.eventLevel)
                }
            }
        }

        function getEventIconPath4IE9(oldIconPath, eventLevel, interval) {
            var iconPath = oldIconPath.substring(0, oldIconPath.lastIndexOf("."));
            iconPath = "icon/ie9_fixed/" + iconPath + "_" + eventLevel + "_" + interval + ".gif";
            return iconPath
        }

        function createEventIcon4IE9(paths, onSuccess, onError) {}

        function prepareEventImage(elementWraps, onComplete) {
            var paths = {},
                path;
            var elementWrap;
            for (var i = 0; i < elementWraps.length; i++) {
                elementWrap = elementWraps[i];
                if (elementWrap.type == "symbols" || elementWrap.type == "containers") {
                    var interval = elementWrap.eventRender == "animation" ? 600 : 0;
                    var eventLevel = elementWrap.eventLevel;
                    var oldIconPath = elementWrap.target.getIcon();
                    path = getEventIconPath4IE9(oldIconPath, eventLevel, interval);
                    paths[path] = null;
                    elementWrap.eventIconPath = path
                }
            }
            var pathArr = [],
                existPaths = [],
                notExistPaths = [];
            for (var k in paths) {
                pathArr.push(k)
            }

            function handleImage() {
                if ((existPaths.length + notExistPaths.length) == pathArr.length) {
                    if (existPaths.length == pathArr.length) {
                        onComplete()
                    } else {
                        createEventIcon4IE9(notExistPaths, function() {
                            setTimeout(function() {
                                onComplete()
                            }, 10000)
                        })
                    }
                }
            }
            for (var k in paths) {
                path = k;
                var image = new Image();
                image.path = path;
                image.onerror = function() {
                    notExistPaths.push(this.path);
                    handleImage()
                };
                image.onload = function() {
                    existPaths.push(this.path);
                    handleImage()
                };
                image.src = k
            }
        }
        removeEventJsRender();
        removeEventNativeRender();
        var es = getEventElementWraps();
        if (useNativeRender) {
            renderEvents(es)
        } else {
            prepareEventImage(es, function() {
                renderEvents4IE9(es)
            })
        }
    },
    elementEventRender4IE9: function(element) {
        var isIe9 = $.browser.msie && $.browser.version == 9;
        var currLevel = element.kpis && element.kpis["EventLevel"];

        if (isIe9 && currLevel) {
            currLevel = String(element.kpis["EventLevel"]);
            var type = null,
                $ge = $.topology.graphEngine;
            if (this.isSymbol(element)) {
                type = "symbols"
            } else {
                if (this.isContainer(element)) {
                    type = "containers"
                } else {
                    if (this.isLine(element)) {
                        type = "lines"
                    } else {
                        if (this.isLineseter(element)) {
                            type = "lineseters"
                        }
                    }
                }
            }
            if (element.alarm && element.alarm.render && element.alarm.render === "animation") {
                $ge.eventAnimationRender4IE9(element.id, type, currLevel)
            } else {
                $ge.eventColorRender4IE9(element.id, type, currLevel)
            }
        }
    },
    selector: function() {
        var $topo = null,
            selector = {},
            selected = null,
            lastSelected = null,
            size = 0;
        selector.init = function(topology) { // 初始化选取器
            $topo = topology;
            lastSelected = {
                "symbols": [],
                "containers": [],
                "lines": [],
                "lineseters": [],
                "focus": null
            };
            size = 0;
            selected = {
                "symbols": [],
                "containers": [],
                "lines": [],
                "lineseters": [],
                "focus": null
            }
        };

        function reset() {
            var $ge = $topo.graphEngine,
                lineIds = [].concat(selected.lines).concat(selected.lineseters);
            size = 0;
            selected = {
                "symbols": [],
                "containers": [],
                "lines": [],
                "lineseters": [],
                "focus": null
            };
            for (var i in lineIds) {
                $ge.hideLineWrap(lineIds[i])
            }
            $ge.selector.reset()
        }
        selector.reset = function() {
            lastSelected = $.extend(true, {}, selected);
            reset();
            onSelect()
        };

        function onSelect() {
            $($topo).triggerHandler("selectElement")
        }
        selector.size = function() {
            return size
        };
        selector.selected = function() {
            return selected
        };
        selector.lastSelected = function() {
            return lastSelected
        };
        selector.focus = function(target) {
            if (!arguments.length) {
                return selected.focus
            }
            var element = typeof target === "string" ? $topo.find(id) : target,
                id = element && String(element.id);
            if (selector.contains(id, ["symbols", "containers"])) {
                selected.focus = element
            }
        };
        selector.symbols = function() {
            return selected.symbols
        };
        selector.containers = function() {
            return selected.containers
        };
        selector.lines = function() {
            return selected.lines
        };
        selector.lineseters = function() {
            return selected.lineseters
        };
        selector.select = function(target) {
            lastSelected = $.extend(true, {}, selected);
            reset();
            if (!target) {
                return
            }
            var items = $.isArray(target) ? target : [target];
            if (items.length == 0) {
                onSelect();
                return
            }
            if (items.length == 1 && String($topo.view.id) == String(items[0])) {
                selected.focus = $topo.view;
                size = 1;
                onSelect();
                return
            }
            var obj = null;
            for (var i = 0, len = items.length; i < len; i++) {
                id = String(items[i]);
                if (selector.contains(id)) {
                    continue
                }
                obj = $topo.find(id);
                if (!obj || !obj.visible) {
                    continue
                }
                if ($topo.isSymbol(obj)) {
                    selected.symbols.push(id)
                } else {
                    if ($topo.isContainer(obj)) {
                        selected.containers.push(id)
                    } else {
                        if ($topo.isLine(obj)) {
                            selected.lines.push(id)
                        } else {
                            if ($topo.isLineseter(obj)) {
                                selected.lineseters.push(id)
                            } else {
                                continue
                            }
                        }
                    }
                }
                if (!selected.focus) {
                    selected.focus = obj
                }
            }
            size = selected.symbols.length + selected.containers.length + selected.lines.length + selected.lineseters.length;
            selector.refresh();
            onSelect()
        };
        selector.refresh = function() {
            var $ge = $.topology.graphEngine,
                lineIds = [].concat(selected.lines).concat(selected.lineseters);
            $ge.selector.resize();
            for (var i in lineIds) {
                $ge.showLineWrap(lineIds[i])
            }
        };
        selector.contains = function(target, _types) {
            if (!target || size == 0) {
                return false
            }
            var id = typeof target === "object" ? String(target.id) : String(target);
            if (id == selector.focus().id) {
                return true
            }
            var types, items;
            if (arguments.length == 1) {
                types = ["symbols", "containers", "lines", "lineseters"]
            } else {
                if (!$.isArray(_types)) {
                    types = [String(_types)]
                } else {
                    types = _types
                }
            }
            for (var i in types) {
                items = selected[types[i]];
                for (var j in items) {
                    if (id == items[j]) {
                        return true
                    }
                }
            }
            return false
        };
        return selector
    }(),
    floator: function() {
        var opts = {
                floatShape: "RECT",
                hoverRadiation: 0,
                hoverShadow: false
            },
            isVisible = true,
            $fn = {},
            $topo = null,
            $container = null;

        function nodeRender(obj, hang) {
            var isContainer = $topo.isContainer(obj),
                isHide = isContainer ? obj.isExpand : !obj.visible;
            $.each(hang, function(code, cvt) {
                if (!cvt) {
                    return true
                }
                var bbox = obj.getIconBBox(),
                    t = $topo.graphEngine.coordsConvert({
                        coords: {
                            x: bbox.minX,
                            y: bbox.minY
                        },
                        from: "view",
                        to: "svg"
                    }),
                    l = $topo.graphEngine.coordsConvert({
                        coords: {
                            x: bbox.maxX,
                            y: bbox.maxY
                        },
                        from: "view",
                        to: "svg"
                    });
                var $img = $("<img/>").attr({
                    id: "floator-node-" + code + "-" + obj.id,
                    src: cvt.icon,
                    title: (isContainer ? obj.getName() + "内部" : obj.getName()) + cvt.text
                }).css({
                    left: (l.x - 8) + "px",
                    top: (t.y - 8) + "px",
                    width: "16px",
                    height: "16px"
                }).addClass("floator-element").appendTo($container);
                if (isHide) {
                    $img.hide()
                } else {
                    $img.show
                }
            })
        }

        function lineRender(obj, hang) {
            var isLineseter = $topo.isLineseter(obj),
                isHide = !obj.visible;
            $.each(hang, function(code, cvt) {
                if (!cvt) {
                    return true
                }
                var pos = obj.getPointAtLength(obj.getTotalLength() / 2);
                pos = $topo.graphEngine.coordsConvert({
                    coords: {
                        x: pos.x,
                        y: pos.y
                    },
                    from: "view",
                    to: "svg"
                });
                var $img = $("<img/>").attr({
                    id: "floator-line-" + code + "-" + obj.id,
                    src: cvt.icon,
                    title: (isLineseter ? obj.getName() + "内部" : obj.getName()) + cvt.text
                }).css({
                    left: (pos.x - 8) + "px",
                    top: (pos.y - 8) + "px",
                    width: "16px",
                    height: "16px"
                }).addClass("floator-element").appendTo($container);
                if (isHide) {
                    $img.hide()
                } else {
                    $img.show()
                }
            })
        }

        function bind() {
            var $floator = $topo.floator;
            $($topo.graphEngine.canvas).off("change.floator").on("change.floator", function() {
                $floator.adjust()
            });
            $($topo).off("drawElement.floator").on("drawElement.floator", function(event, o) {
                if ($topo.isContainer(o) || $topo.isLineseter(o)) {
                    if (o.isExpand) {
                        $floator.hideById(o.id)
                    } else {
                        $floator.showById(o.id)
                    }
                }
                if (!$topo.isContainer(o)) {
                    if (o.visible) {
                        $floator.showById(o.id)
                    } else {
                        $floator.hideById(o.id)
                    }
                }
                $floator.adjust()
            })
        }
        $fn.init = function(topology) { // 初始化floator
            $topo = topology;
            var _container = $("#floatHangContainer");
            if (_container.length === 0) {
                _container = $("<div/>").attr("id", "floatHangContainer");
                $("#svgCanvas").append(_container)
            }
            $container = _container
        };
        $fn.hang = function(statusIds) {
            statusIds = statusIds && $.isArray(statusIds) ? statusIds : [];
            var isAll = statusIds.length === 0,
                ids = statusIds.join(""),
                $cfg = $topo.config.status,
                datas = null;
            $fn.clear();
            $.each($topo.shapes, function(s, eles) {
                $.each(eles, function(id, ele) {
                    datas = {};
                    var _status = ele.status || {};
                    if (isAll) {
                        $.each(_status, function(c, val) {
                            datas[c] = eval($cfg[c].converter).call(this, val);
                            if (datas[c] === null) {
                                delete datas[c]
                            }
                        })
                    } else {
                        $.each(_status, function(c, val) {
                            if ((new RegExp(c, "g")).test(ids)) {
                                datas[c] = eval($cfg[c].converter).call(this,
                                    val);
                                if (datas[c] === null) {
                                    delete datas[c]
                                }
                            }
                        })
                    }
                    if (s === "symbols" || s === "containers") {
                        nodeRender(ele, datas)
                    } else {
                        lineRender(ele, datas)
                    }
                })
            });
            bind()
        };
        $fn.adjust = function() {
            $("img[id^='floator-node-']").each(function(i) {
                var $img = $(this),
                    _id = $img.attr("id").substring($img.attr("id").lastIndexOf("-") + 1),
                    obj = $topo.find(_id, "symbol|container");
                if (!obj) {
                    return true
                }
                var bbox = obj.getIconBBox(),
                    t = $topo.graphEngine.coordsConvert({
                        coords: {
                            x: bbox.minX,
                            y: bbox.minY
                        },
                        from: "view",
                        to: "svg"
                    }),
                    l = $topo.graphEngine.coordsConvert({
                        coords: {
                            x: bbox.maxX,
                            y: bbox.maxY
                        },
                        from: "view",
                        to: "svg"
                    });
                $img.css({
                    left: (l.x - 8) + "px",
                    top: (t.y - 8) + "px"
                })
            });
            $("img[id^='floator-line-']").each(function(i) {
                var $img = $(this),
                    _id = $img.attr("id").substring($img.attr("id").lastIndexOf("-") + 1),
                    obj = $topo.find(_id, "line|lineseter");
                if (!obj) {
                    return true
                }
                var pos = obj.getPointAtLength(obj.getTotalLength() / 2);
                pos = $topo.graphEngine.coordsConvert({
                    coords: {
                        x: pos.x,
                        y: pos.y
                    },
                    from: "view",
                    to: "svg"
                });
                $img.css({
                    left: (pos.x - 8) + "px",
                    top: (pos.y - 8) + "px"
                })
            })
        };
        $fn.visible = function() {
            return isVisible
        };
        $fn.show = function() {
            isVisible = true;
            $container.fadeIn(800)
        };
        $fn.showById = function(id) {
            if (!id || id === "") {
                return
            }
            $("img[id^='floator-'][id$='-" + id + "']").each(function() {
                $(this).show()
            })
        };
        $fn.hide = function() {
            isVisible = false;
            $container.fadeOut(800)
        };
        $fn.hideById = function(id) {
            if (!id || id === "") {
                return
            }
            $("img[id^='floator-'][id$='-" + id + "']").each(function() {
                $(this).hide()
            })
        };
        $fn.clear = function() {
            $container.empty()
        };
        return $fn
    }(),
    uuid: function() { // 获取时间
        return "tmp-" + this._uuid++
    },
    _drawTopo: function() {
        var _s = $.topology.shapes;
        $.topology.view.draw();
        for (var id in _s.symbols) {
            _s.symbols[id].draw()
        }
        for (var id in _s.containers) {
            _s.containers[id].draw()
        }
        for (var id in _s.lines) {
            _s.lines[id].draw()
        }
        for (var id in _s.lineseters) {
            _s.lineseters[id].draw()
        }
        $.topology.graphEngine.canvas.init()
    },
    _lineKpiMapping: function() {
        var $topo = $.topology,
            mapping = {},
            _contextCfg = $topo.config.context["link"],
            _kpiCfg = $topo.config.kpi["link"],
            _lineseters = $topo.shapes.lineseters;
        for (var _contextName in _contextCfg) {
            var cfg = _contextCfg[_contextName],
                kpis = cfg.kpis.split(","),
                operations = cfg.operations.split(",");
            for (var i = 0, len = kpis.length; i < len; i++) {
                _k = kpis[i];
                if (_kpiCfg[_k] && typeof(_kpiCfg[_k]) != "undefined" && _kpiCfg[_k].type === "DYNAMIC") {
                    mapping[_k] = operations[i] && operations[i] !== "" ? operations[i] : "NULL"
                }
            }
        }
        var linesetersId = [];
        for (var _lineId in _lineseters) {
            linesetersId.push(_lineId)
        }
        for (var i = linesetersId.length - 1; i >= 0; i--) {
            var lineseter = _lineseters[linesetersId[i]];
            lineseter.kpis = lineseter.kpis || {};
            $topo._lineseterKpi(lineseter, mapping)
        }
    },
    _lineseterKpi: function(lineseter, mapping) {
        for (var kpi in mapping) {
            var oper = mapping[kpi],
                childrenValue = $.topology
                ._getChildrenKpi(lineseter, kpi),
                kpiValue = 0;
            switch (oper) {
                case "MAX":
                    for (var i = 0, len = childrenValue.length; i < len; i++) {
                        var childV = Number(childrenValue[i]);
                        if (kpiValue < childV) {
                            kpiValue = childV
                        }
                    }
                    lineseter.kpis[kpi] = Number(kpiValue).toFixed(2);
                    break;
                case "MIN":
                    for (var i = 0, len = childrenValue.length; i < len; i++) {
                        var childV = Number(childrenValue[i]);
                        if (kpiValue > childV) {
                            kpiValue = childV
                        }
                    }
                    lineseter.kpis[kpi] = Number(kpiValue).toFixed(2);
                    break;
                case "SUM":
                    for (var i = 0, len = childrenValue.length; i < len; i++) {
                        var childV = Number(childrenValue[i]);
                        kpiValue += childV
                    }
                    lineseter.kpis[kpi] = Number(kpiValue).toFixed(2);
                    break;
                case "AVG":
                    for (var i = 0, len = childrenValue.length; i < len; i++) {
                        var childV = Number(childrenValue[i]);
                        kpiValue += childV
                    }
                    kpiValue = kpiValue / childrenValue.length;
                    lineseter.kpis[kpi] = Number(kpiValue).toFixed(2);
                    break;
                case "NULL":
                    kpiValue = lineseter.kpis[kpi];
                    lineseter.kpis[kpi] = kpiValue && Number(kpiValue) !== 0 ? kpiValue : null;
                    break
            }
        }
    },
    _getChildrenKpi: function(lineseter, kpi) {
        var values = [],
            children = lineseter.children,
            child = null,
            $topo = $.topology;
        for (var id in children) {
            child = children[id];
            if ($topo.isLineseter(child)) {
                var _v = $topo._getChildrenKpi(child, kpi);
                values = values.concat(_v)
            } else {
                values.push(child.kpis !== null && typeof(child.kpis[kpi]) != "undefined" ? Number(child.kpis[kpi]) : 0)
            }
        }
        return values
    }
};
jQuery.extend({
    "topology": new hy.topology.Topology()
});
// /hy.topology.layout
hy.topology.layout = {};

// /hy.topology.layout.util//running
hy.topology.layout.util = function() {
    var util = {};
    util.existsNode = function(node) {};
    util.isNode = function(node) {};
    util.getViewSize = function() {
        var view = $.topology.view;
        return [view.getWidth(), view.getHeight()]
    };
    util.convert2LayoutElement = function(nodes) {};
    return util
}();

// /hy.topology.layout.tree//running
hy.topology.layout.tree = function() {
    if (typeof d3 == "undefined") {
        return
    }
    var RENDER_NONE = "0",
        RENDER_GROW = "1",
        RENDER_TRANSLATE = "2";
    var tree = {},
        event = d3.dispatch("start", "tick", "end", "error"),
        defaults = {
            orientation: LayoutTree.O_TOP,
            render: RENDER_GROW,
            levelDistance: 100,
            siblingDistance: 40,
            subtreeDistance: 60
        },
        settings = $.extend({}, defaults),
        alpha, root = null,
        nodes = [];
    var nodeMap = {},
        childrenMap = {};
    var util = hy.topology.layout.util;
    tree.start = function() {
        var moveNode = $.topology.view.moveNodes;
        $.topology.selector.reset();
        var layoutTree = new LayoutTree();
        layoutTree.config.orientation = settings.orientation;
        layoutTree.config.levelDistance = settings.levelDistance;
        layoutTree.config.siblingDistance = settings.siblingDistance;
        layoutTree.config.subtreeDistance = settings.subtreeDistance;
        initTree(root, layoutTree);
        layoutTree.updateTree();
        var layoutTreeNodes = layoutTree.nodes();
        var node, dx, dy;
        $.each(layoutTreeNodes, function(i, o) {
            node = nodeMap[o.id];
            dx = o.x - node.x;
            dy = o.y - node.y;
            node.move(dx, dy)
        });
        var bbox = $.topology.getNodesBBox(nodes);
        dx = bbox.minX < 0 ? -bbox.minX : 0;
        dy = bbox.minY < 0 ? -bbox.minY : 0;
        moveNode(nodes, dx, dy);
        $.topology.view.moveNodesStop(nodes)
        $.topology.selector.refresh();
        $.topology.saveTopo();
    };

    function initTree(root, layoutTree) {
        nodes = [];
        nodeMap = {};
        childrenMap = {};
        initChildren(root);
        sortChildren();
        initTreeNode(root, -1);

        function initChildren(node) {
            if ($.topology.isContainer(node) && node.isExpand) {
                node.collapse()
            }
            node.change();
            nodes.push(node);
            nodeMap[node.id] = node;
            var children = [];
            var links = node.getLines();
            for (var lid in links) {
                var link = links[lid];
                var other = link.otherNode(node);
                if (!other.parent && !nodeMap[other.id]) {
                    children.push(other);
                    initChildren(other)
                }
            }
            children.sort(sortChildren);
            var childrenIds = [];
            $.each(children, function(i, o) {
                childrenIds.push(o.id)
            });
            childrenMap[node.id] = childrenIds
        }

        function sortChildren(n1, n2) {
            if (n1 && n2 && n1.getObjectClass() < n2.getObjectClass()) {
                return -1
            } else {
                return 1
            }
        }

        function initTreeNode(node, pid) {
            var nodeId = node.id,
                iconBBox = node.getIconBBox();
            layoutTree.add(nodeId, pid, iconBBox.width, iconBBox.height);
            var children = childrenMap[nodeId],
                child;
            $.each(children, function(i, id) {
                child = nodeMap[id];
                initTreeNode(child, nodeId)
            })
        }
    }
    tree.stop = function() {};
    tree.root = function(x) {
        if (!arguments.length) {
            return root
        }
        if ($.topology.isSymbol(x) || $.topology.isContainer(x)) {
            root = x
        }
        return tree
    };
    tree.setOption = function(key, value) {
        settings[key] = value
    };
    tree.getOption = function(key) {
        return settings[key]
    };
    tree.resetSetting = function() {
        settings = $.extend({}, defaults)
    };
    return tree
}();
// /hy.topology.layout.force //running
hy.topology.layout.force = function() {
    if (typeof d3 == "undefined") {
        return
    }
    var force = {},
        event = d3.dispatch("start", "tick", "end"),
        size = [1, 1],
        defaults = {
            friction: 0.9,
            linkDistance: 80,
            linkStrength: 1,
            charge: -600,
            gravity: 0.1,
            theta: 0.8
        },
        settings = $.extend({}, defaults),
        nodes = [],
        links = [],
        viewNodes = {},
        viewLinks = {},
        util = hy.topology.layout.util,
        d3force = null;
    force.init = function() {
        size = util.getViewSize();
        nodes = [];
        links = []
    };
    force.initData = function() {
        viewNodes = {};
        viewLinks = {};
        var shapes = $.topology.shapes,
            node, line;
        for (var id in shapes.containers) {
            node = shapes.containers[id];
            if (node.isExpand) {
                node.collapse()
            }
            viewNodes[node.id] = node
        }
        for (var id in shapes.symbols) {
            node = shapes.symbols[id];
            if (node.visible && !node.parent) {
                viewNodes[node.id] = node;
                for (var lid in node.lines) {
                    line = node.lines[lid];
                    if (line.isExpand) {
                        line.collapse()
                    }
                }
                for (var lid in node.lines) {
                    line = node.lines[lid];
                    if (line.visible) {
                        viewLinks[line.id] = line
                    }
                }
            }
        }
        for (var id in viewNodes) {
            node = viewNodes[id];
            if ($.topology.isSymbol(node)) {
                for (var lid in node.lines) {
                    line = node.lines[lid];
                    if (line.isExpand) {
                        line.collapse()
                    }
                }
                for (var lid in node.lines) {
                    line = node.lines[lid];
                    if (line.visible && line.srcNode && viewNodes[line.srcNode.id] && line.dstNode && viewNodes[line.dstNode.id]) {
                        viewLinks[line.id] = line
                    }
                }
            } else {
                if ($.topology.isContainer(node)) {
                    for (var lid in node.lineseters) {
                        line = node.lineseters[lid];
                        if (line.visible && line.srcNode && viewNodes[line.srcNode.id] && line.dstNode && viewNodes[line.dstNode.id]) {
                            viewLinks[line.id] = line
                        }
                    }
                }
            }
        }
        var nodesIndex = {};
        for (var id in viewNodes) {
            node = viewNodes[id];
            nodesIndex[node.id] = nodes.length;
            nodes.push({
                id: node.id,
                node: node,
                x: node.x,
                y: node.y,
                px: node.x,
                py: node.y,
                width: node.getIconBBox().width,
                height: node.getIconBBox().height
            })
        }
        var sid, tid;
        for (var id in viewLinks) {
            line = viewLinks[id];
            sid = line.srcNode.id;
            tid = line.dstNode.id;
            links.push({
                source: nodesIndex[sid],
                target: nodesIndex[tid]
            })
        }
    };

    function onEnd() {
        var o;
        for (var i = 0; i < nodes.length; i++) {
            o = nodes[i];
            o.node.moveOver()
        }
    }
    force.start = function() {
        var moveNode = $.topology.view.moveNodes;
        $.topology.selector.reset();
        force.init();
        force.initData();
        if (nodes.length == 0) {
            return
        }
        d3force = d3.layout.force().size(size).friction(settings.friction).linkDistance(settings.linkDistance).linkStrength(settings.linkStrength).charge(settings.charge).gravity(settings.gravity).theta(settings.theta).nodes(nodes).links(links);
        d3force.on("start", function() {
            event.start({
                type: "start"
            })
        });
        d3force.on("tick", function() {
            event.tick({
                type: "tick"
            });
            var o, origCoords, ns = [],
                dx = 0,
                dy = 0;
            for (var i = 0; i < nodes.length; i++) {
                o = nodes[i];
                ns.push(o.node);
                origCoords = o.node.getCenterCoords();
                dx = o.x - origCoords.x;
                dy = o.y - origCoords.y;
                o.node.move(dx, dy)
            }
            var bbox = $.topology.getNodesBBox(ns);
            dx = bbox.minX < 0 ? -bbox.minX : 0;
            dy = bbox.minY < 0 ? -bbox.minY : 0;
            moveNode(ns, dx, dy)
        });
        d3force.on("end", function() {
            onEnd();
            event.end({
                type: "end"
            })
        });
        d3force.start()
    };
    force.stop = function() {
        d3force && d3force.stop()
    };
    force.setOption = function(key, value) {
        settings[key] = +value
    };
    force.getOption = function(key) {
        return settings[key]
    };
    force.resetSetting = function() {
        settings = $.extend({}, defaults)
    };
    return d3.rebind(force, event, "on")
}();

// /hy.topology.model
Package.p("hy.topology.model");
// /hy.topology.model.View
hy.topology.model.View = function() {
    this.id = "";
    this.name = "";
    this.descr = "";
    this.type = -1;
    this.isInstance = true;
    this.isHidden = false;
    this.style = null;
    this.option = null;
    this.init.apply(this, arguments)
};
hy.topology.model.View.prototype = {
    init: function() {
        if (!$.isPlainObject(arguments[0])) {
            return
        }
        var _data = arguments[0];
        this.id = _data.id;
        this.name = typeof _data.name == "string" ? _data.name : "";
        this.descr = _data.descr;
        this.type = parseInt(_data.type ? _data.type : "-1");
        this.isInstance = _data.isInstance ? true : false;
        this.isHidden = _data.isHidden ? true : false;
        this.style = {};
        if (_data.style) {
            if ($.isPlainObject(_data.style)) {
                this.style = $.extend(this.style, _data.style)
            } else {
                if ($.type(_data.style) === "string") {
                    var _styleArr = _data.style.split(";");
                    for (var i = 0, len = _styleArr.length; i < len; i++) {
                        var _style = _styleArr[i].split(":");
                        if ($.trim(_style[0]) !== "") {
                            this.style[_style[0]] = _style[1]
                        }
                    }
                }
            }
        }
        this.option = {};
        if (_data.options) {
            if ($.isPlainObject(_data.options)) {
                this.option = $.extend(this.option, _data.options)
            } else {
                if ($.type(_data.options) === "string") {
                    var _optionArr = _data.options.split(";");
                    for (var i = 0, len = _optionArr.length; i < len; i++) {
                        var _option = _optionArr[i].split(":");
                        if ($.trim(_option[0]) !== "") {
                            this.option[_option[0]] = _option[1]
                        }
                    }
                }
            }
        }
        this.fillScaleX = 1;
        this.fillScaleY = 1
    },
    getContainerWidth: function() {
        return $.topology.graphEngine.canvas.width()
    },
    getContainerHeight: function() {
        return $.topology.graphEngine.canvas.height()
    },
    getBBox: function() {
        var box = $.topology.graphEngine.canvas.bbox();
        return {
            x: box.x / this.fillScaleX,
            y: box.y / this.fillScaleY,
            width: box.width / this.fillScaleX,
            height: box.height / this.fillScaleY
        }
    },
    fitToCanvas: function() {
        $.topology.graphEngine.canvas.fitToCanvas()
    },
    origiZoom: function() {
        var width = this.getContainerWidth();
        var height = this.getContainerHeight();
        this.scale(1, width / 2, height / 2)
    },
    scale: function(_scale, anchorX, anchorY, isCentered) {
        if (!arguments.length) {
            return $.topology.graphEngine.canvas.scale()
        }
        anchorX *= this.fillScaleX;
        anchorY *= this.fillScaleY;
        $.topology.graphEngine.canvas.scale(_scale, anchorX, anchorY,
            isCentered)
    },
    translate: function() {
        return $.topology.graphEngine.canvas.translate()
    },
    viewport: function(x, y, width, height) {
        if (!arguments.length) {
            var v = $.topology.graphEngine.canvas.viewport();
            return {
                x: v.x / this.fillScaleX,
                y: v.y / this.fillScaleY,
                width: v.width / this.fillScaleX,
                height: v.height / this.fillScaleY
            }
        }
        x *= this.fillScaleX;
        y *= this.fillScaleY;
        width *= this.fillScaleX;
        height *= this.fillScaleY;
        $.topology.graphEngine.canvas.viewport(x, y, width, height)
    },
    move: function(x, y) {
        $.topology.graphEngine.canvas.move(x, y)
    },
    moveNodes: function(nodes, dx, dy) {
        if (!dx && !dy) {
            return
        }
        if (!$.isArray(nodes)) {
            nodes = [nodes]
        }
        var $topo = $.topology,
            nodeMap = {},
            node;
        for (var i = 0; i < nodes.length; i++) {
            node = nodes[i];
            nodeMap[node.id] = node;
            if ($topo.isContainer(node)) {
                for (var nid in node.children) {
                    nodeMap[nid] = node.children[nid]
                }
            }
        }
        var line1 = {},
            line2 = {};
        var lines, line, otherNode;
        for (var id in nodeMap) {
            node = nodeMap[id];
            if ($topo.isSymbol(node)) {
                lines = node.lines
            } else {
                if ($topo.isContainer(node)) {
                    lines = node.lineseters
                } else {
                    continue
                }
            }
            for (var id in lines) {
                line = lines[id];
                otherNode = line.otherNode(node);
                if (otherNode && nodeMap[otherNode.id]) {
                    line1[id] = line
                } else {
                    line2[id] = line
                }
            }
        }
        for (var id in nodeMap) {
            node = nodeMap[id];
            if ($topo.isSymbol(node)) {
                node.x += dx;
                node.y += dy;
                if (node.parent && !nodeMap[node.parent.id]) {
                    node.updateParentSize()
                }
            } else {
                if ($topo.isContainer(node)) {
                    node.expandX += dx;
                    node.expandY += dy;
                    node.x += dx;
                    node.y += dy
                }
            }
            node.changeCoords()
        }
        for (var id in line1) {
            line = line1[id];
            if ($topo.isLine(line)) {
                if (!line.parent || line.parent.state != 1) {
                    line.move(dx, dy);
                    line.changePath()
                }
            } else {
                line.move(dx, dy);
                line.changePath();
                if (line.state == 1) {
                    line.renovate()
                }
            }
        }
        for (var id in line2) {
            line = line2[id];
            if ($topo.isLine(line)) {
                if (!line.parent || line.parent.state != 1) {
                    line.updateNodePosition();
                    line.changePath()
                }
            } else {
                line.updateNodePosition();
                line.changePath();
                if (line.state == 1) {
                    line.renovate()
                }
            }
        }
        var mark = document.getElementById('search_mark');
        if (mark) {
            mark.setAttribute('x', node.x);
            mark.setAttribute('y', node.y);
        }
        $.each(nodes,function(index,node){
            var tipEl = $('#' + node.id).closest('g').find('.j-alarm-tip').get(0);
            if (tipEl) {
                tipEl.setAttribute('display', 'none');
            }
            var tipNat = $('#' + node.id).closest('g').find('.j-nat-tip').get(0);
            if (tipNat) {
                tipNat.setAttribute('display', 'none');
            }
            var markEl = $('#' + node.id).closest('g').find('#search_mark').get(0);
            if(markEl){
                markEl.setAttribute('display', 'none');
            }
        });
    },
    moveNodesStop: function(nodes) {
        if (!$.isArray(nodes)) {
            nodes = [nodes]
        }
        var $topo = $.topology,
            nodeMap = {},
            node;
        for (var i = 0; i < nodes.length; i++) {
            node = nodes[i];
            nodeMap[node.id] = node;
            if ($topo.isContainer(node)) {
                for (var nid in node.children) {
                    nodeMap[nid] = node.children[nid]
                }
            }
        }
        var lineMap = {};
        var lines, line;
        for (var id in nodeMap) {
            node = nodeMap[id];
            if ($topo.isSymbol(node)) {
                lines = node.lines
            } else {
                if ($topo.isContainer(node)) {
                    lines = node.lineseters
                } else {
                    continue
                }
            }
            for (var id in lines) {
                line = lines[id];
                lineMap[id] = line
            }
        }
        for (var id in nodeMap) {
            node = nodeMap[id];
            node.change();
            if (node.parent && !nodeMap[node.parent.id]) {
                node.parent.change()
            }
        }
        for (var id in lineMap) {
            lineMap[id].change()
        }
        $.each(nodes,function(index,node){
            var el = document.getElementById(node.id);
            var info = el.getBBox();
            var tipEl = $('#' + node.id).closest('g').find('.j-alarm-tip').get(0);
            if (tipEl) {
                tipEl.setAttribute("transform", 'translate(' + (info.x + info.width - 8) + ',' + (info.y - 8) + ')');
                tipEl.setAttribute('display', 'block');
            }

            var tipNat = $('#' + node.id).closest('g').find('.j-nat-tip').get(0);
            if (tipNat) {
                tipNat.setAttribute("transform", 'translate(' + (info.x - 26) + ',' + (info.y + 20) + ')');
                tipNat.setAttribute('display', 'block');
            }
            var markEl = $('#' + node.id).closest('g').find('#search_mark').get(0);
            if(markEl){
                markEl.setAttribute('display', 'block');
                markEl.setAttribute("width", info.width);
                markEl.setAttribute("height", info.height);
                markEl.setAttribute("x", info.x);
                markEl.setAttribute("y", info.y);
            }
        });

    },
    getViewBox: function() {
        return {
            x: 0,
            y: 0,
            width: this.getWidth(),
            height: this.getHeight()
        }
    },
    getWidth: function() {
        return parseInt(this.style["width"], 10)
    },
    getHeight: function() {
        return parseInt(this.style["height"], 10)
    },
    setWidth: function(width) {
        this.style["width"] = width
    },
    setHeight: function(height) {
        this.style["height"] = height
    },
    change: function() {
        $.topology.changed.view = true;
        $.topology.graphEngine.view(this)
    },
    draw: function() {
        $.topology.graphEngine.view(this)
    },
    serialize: function() {
        var json = "{";
        json += '"id":"' + this.id + '",';
        json += '"name":"' + $.string.quoteString(this.name) + '",';
        if (this.descr) {
            json += '"descr":"' + $.string.quoteString(this.descr) + '",'
        }
        json += '"type":"' + this.type + '",';
        json += '"isInstance":"' + this.isInstance + '",';
        json += '"isHidden":"' + this.isHidden + '",';
        var _style = "";
        for (var key in this.style) {
            if (key.length == 0) {
                continue
            }
            _style += key + ":" + this.style[key] + ";"
        }
        json += '"style":"' + _style + '",';
        var _option = "";
        for (var key in this.option) {
            if (key.length == 0) {
                continue
            }
            _option += key + ":" + this.option[key] + ";"
        }
        json += '"options":"' + _option + '"}';
        return json
    }
};
// /hy.topology.model.BaseNode
hy.topology.model.BaseNode = function() {
    this.id = "";
    this.name = "";
    this.x = 0;
    this.y = 0;
    this.bbox = null;
    this.visible = true;
    this.objectId = "";
    this.objectClass = "";
    this.instanceId = "";
    this.kpis = null;
    this.eventIds = null;
    this.status = null;
    this.style = null;
    this.option = null;
    this.url = null;
    this.alarm = null
    this.ipaddress = "";
};
hy.topology.model.BaseNode.prototype = {
    setBBox: function() {
        if (arguments.length === 4) {
            this.bbox = {
                minX: Number(arguments[0]),
                minY: Number(arguments[1]),
                width: Number(arguments[2]),
                height: Number(arguments[3]),
                maxX: Number(arguments[0]) + Number(arguments[2]),
                maxY: Number(arguments[1]) + Number(arguments[3])
            }
        } else {
            if (arguments.length === 8) {
                this.bbox = {
                    minX: Number(arguments[0]),
                    minY: Number(arguments[1]),
                    width: Number(arguments[2]),
                    height: Number(arguments[3]),
                    maxX: Number(arguments[0]) + Number(arguments[2]),
                    maxY: Number(arguments[1]) + Number(arguments[3]),
                    expandMinX: Number(arguments[4]),
                    expandMinY: Number(arguments[5]),
                    expandWidth: Number(arguments[6]),
                    expandHeight: Number(arguments[7]),
                    expandMaxX: Number(arguments[4]) + Number(arguments[6]),
                    expandMaxY: Number(arguments[5]) + Number(arguments[7])
                }
            }
        }
    },
    getName: function(useNewline) {
        if (typeof this.name !== "string") {
            this.name = ""
        }
        return useNewline ? this.name : this.name.replace(/<br>/ig, " ")
    },
    getIcon: function() {
        return this.style["icon"]
    },
    serialize: function() {
        console.log("serialize 1")
        if ($.topology.isContainer(this)) {
            this.option["container-x"] = this.expandX;
            this.option["container-y"] = this.expandY;
            this.option["container-width"] = this.expandWidth;
            this.option["container-height"] = this.expandHeight;
            this.option["container-expand"] = this.isExpand ? "1" : "0";
            this.option["container-permit"] = this.isPermit ? "1" : "0";
            this.option["container-expand-autoresize"] = this.autoResize ? "1" : "0"
        }
        var json = "{";
        json += '"id":"' + this.id + '",';
        json += '"name":"' + (this.name ? $.string.quoteString(this.name) : "") + '",';
        json += '"x":"' + parseInt(this.x, 10) + '",';
        json += '"y":"' + parseInt(this.y, 10) + '",';
        json += '"type":"' + (this instanceof hy.topology.model.Container ? 1 : 0) + '",';
        json += '"viewId":"' + $.topology.view.id + '",';
        json += '"parentId":"' + (this.parent ? this.parent.id : "-1") + '",';
        json += '"objectId":"' + (this.objectId ? this.objectId : "-1") + '",';
        json += '"objectClass":"' + this.objectClass + '",';
        json += '"objectType":"' + this.objectType + '",';
        json += '"resourceId":"' + this.resourceId + '",';
        json += '"instanceId":"' + this.instanceId + '",';

        json += '"isRelaRes":"' + this.isRelaRes + '",';
        json += '"statusRela":"' + this.statusRela + '",';
        json += '"metricId":"' + this.metricId + '",';
        json += '"relaType":"' + this.relaType + '",';
        json += '"isDbclick":"' + this.isDbclick + '",';
        json += '"dbclickType":"' + this.dbclickType + '",';
        json += '"dbclickRes":"' + this.dbclickRes + '",';

        json += '"ipaddress":"' + this.ipaddress + '",';
        var _style = "";
        for (var key in this.style) {
            if (key.length == 0) {
                continue
            }
            _style += key + ":" + this.style[key] + ";"
        }
        json += '"style":"' + _style + '",';
        var _option = "";
        for (var key in this.option) {
            if (key.length == 0) {
                continue
            }
            _option += key + ":" + this.option[key] + ";"
        }
        json += '"options":"' + _option + '",';
        if (this.url && this.url.name.length > 0) {
            var _url = "[";
            for (var i = 0, len = this.url.name.length; i < len; i++) {
                _url += "{'n':'" + $.string.quoteString(this.url.name[i]) + "',";
                _url += "'i':'" + this.url.icon[i] + "',";
                _url += "'l':'" + $.string.quoteString(this.url.link[i]) + "',";
                _url += "'o':'" + this.url.open[i] + "'}";
                _url += (i !== len - 1 ? "," : "]")
            }
            json += '"url":"' + _url + '",'
        } else {
            json += '"url":"",'
        }
        var _alarm = "";
        for (var key in this.alarm) {
            if (key.length == 0) {
                continue
            }
            _alarm += key + ":" + this.alarm[key] + ";"
        }
        json += '"alarm":"' + _alarm + '"}';
        return json
    }
};
// /hy.topology.model.Symbol
hy.topology.model.Symbol = function() {
    this.type = 1;
    this.parent = null;
    this.lines = null;
    hy.topology.model.BaseNode.call(this);
    this.init.apply(this, arguments)
};
hy.topology.model.Symbol.prototype = {
    init: function() {
        var _data = arguments[0] || {};
        this.id = $.trim(_data.id) || $.topology.uuid();
        this.name = typeof _data.name == "string" ? _data.name : "";
        this.x = parseInt(_data.x) || 0;
        this.y = parseInt(_data.y) || 0;
        this.visible = true;
        if (_data.objectId && $.trim(_data.objectId) !== "" && $.trim(_data.objectId) !== "-1") {
            this.objectId = $.trim(_data.objectId)
        }
        if (_data.objectClass && $.trim(_data.objectClass) !== "" && $.trim(_data.objectClass) !== "-1") {
            this.objectClass = $.trim(_data.objectClass)
        }
        // 节点类型 auto（自动发现）/icon（图标）
        if (_data.objectType && $.trim(_data.objectType) !== "" && $.trim(_data.objectType) !== "-1") {
            this.objectType = $.trim(_data.objectType)
        }

        // 节点resourceId
        if (_data.resourceId && $.trim(_data.resourceId) !== "" && $.trim(_data.resourceId) !== "-1") {
            this.resourceId = $.trim(_data.resourceId)
        }

        // 节点是否关联资源
        if (_data.isRelaRes && $.trim(_data.isRelaRes) !== "" && $.trim(_data.isRelaRes) !== "-1") {
            this.isRelaRes = $.trim(_data.isRelaRes)
        }

        // 节点状态表示
        if (_data.statusRela && $.trim(_data.statusRela) !== "" && $.trim(_data.statusRela) !== "-1") {
            this.statusRela = $.trim(_data.statusRela)
        }

        // 节点状态表示
        if (_data.metricId && $.trim(_data.metricId) !== "" && $.trim(_data.metricId) !== "-1") {
            this.metricId = $.trim(_data.metricId)
        }
        // 节点状态表示
        if (_data.relaType && $.trim(_data.relaType) !== "" && $.trim(_data.relaType) !== "-1") {
            this.relaType = $.trim(_data.relaType)
        }
        // 节点双击
        if (_data.isDbclick && $.trim(_data.isDbclick) !== "" && $.trim(_data.isDbclick) !== "-1") {
            this.isDbclick = $.trim(_data.isDbclick)
        }

        // 节点双击展示类型
        if (_data.dbclickType && $.trim(_data.dbclickType) !== "" && $.trim(_data.dbclickType) !== "-1") {
            this.dbclickType = $.trim(_data.dbclickType)
        }

        if (_data.ipaddress && $.trim(_data.ipaddress) !== "" && $.trim(_data.ipaddress) !== "-1") {
            this.ipaddress = $.trim(_data.ipaddress)
        }

        // 节点双击关联的内容
        if (_data.dbclickRes && $.trim(_data.dbclickRes) !== "" && $.trim(_data.dbclickRes) !== "-1") {
            this.dbclickRes = $.trim(_data.dbclickRes)
        }

        if (_data.instanceId && $.trim(_data.instanceId) !== "" && $.trim(_data.instanceId) !== "-1") {
            this.instanceId = $.trim(_data.instanceId)
        }

        var parentId = $.trim(_data.parentId);
        if (parentId) {
            this.parent = $.topology.shapes.containers[parentId] || null;
            if (this.parent) {
                this.parent.addChild(this)
            }
        }
        this.lines = {};
        this.style = {};
        if (_data.style) {
            if ($.isPlainObject(_data.style)) {
                this.style = _data.style
            } else {
                if ($.type(_data.style) === "string") {
                    var _styleArr = _data.style.split(";");
                    for (var i = 0, len = _styleArr.length; i < len; i++) {
                        var _style = _styleArr[i].split(":");
                        if ($.trim(_style[0]) !== "") {
                            this.style[_style[0]] = _style[1]
                        }
                    }
                }
            }
        }
        this.option = {};
        if (_data.options) {
            if ($.isPlainObject(_data.options)) {
                this.option = _data.options
            } else {
                if ($.type(_data.options) === "string") {
                    var _optionArr = _data.options.split(";");
                    for (var i = 0, len = _optionArr.length; i < len; i++) {
                        var _option = _optionArr[i].split(":");
                        if ($.trim(_option[0]) !== "") {
                            this.option[_option[0]] = _option[1]
                        }
                    }
                }
            }
        }
        if (_data.url) {
            if ($.isPlainObject(_data.url)) {
                this.url = _data.url
            } else {
                if ($.type(_data.url) === "string") {
                    this.url = {
                        name: [],
                        icon: [],
                        link: [],
                        open: []
                    };
                    var _urlArr = eval(_data.url);
                    for (var i = 0, len = _urlArr.length; i < len; i++) {
                        this.url.name.push(_urlArr[i].n);
                        this.url.icon.push(_urlArr[i].i);
                        this.url.link.push(_urlArr[i].l);
                        this.url.open.push(_urlArr[i].o)
                    }
                }
            }
        } else {
            this.url = null
        }
        this.alarm = {};
        if (_data.alarm) {
            if ($.isPlainObject(_data.alarm)) {
                this.alarm = _data.alarm
            } else {
                if ($.type(_data.alarm) === "string") {
                    var _alarmArr = _data.alarm.split(";");
                    for (var i = 0, len = _alarmArr.length; i < len; i++) {
                        var _alarm = _alarmArr[i].split(":");
                        if ($.trim(_alarm[0]) !== "") {
                            this.alarm[_alarm[0]] = _alarm[1]
                        }
                    }
                }
            }
        }
    },
    getObjectClass: function() {
        if (this.objectId && this.objectId != -1) {
            return this.objectClass
        } else {
            return "symbol"
        }
    },
    getLines: function() {
        return this.lines
    },
    setName: function(name) {
        this.name = name;
        this.updateRelationLineName();
        this.draw()
    },
    getIconBBox: function() {
        return {
            minX: this.x,
            minY: this.y,
            maxX: this.x + this.getIconWidth(),
            maxY: this.y + this.getIconHeight(),
            width: this.getIconWidth(),
            height: this.getIconHeight()
        }
    },
    getIconWidth: function() {
        return parseInt(this.style["icon-width"])
    },
    getIconHeight: function() {
        return parseInt(this.style["icon-height"])
    },
    setIconWidth: function(width) {
        if (width < 1) {
            width = 1
        } else {
            var viewWidth = $.topology.view.getWidth(),
                iconPadding = this
                .getIconMargin(),
                padding = iconPadding.left + iconPadding.right;
            if (this.parent) {
                iconPadding = this.parent.getExpandPadding();
                padding += iconPadding.left + iconPadding.right
            }
            var maxWidth = viewWidth - padding;
            if (width > maxWidth) {
                width = maxWidth
            }
        }
        this.style["icon-width"] = width
    },
    setIconHeight: function(height) {
        if (height < 1) {
            height = 1
        } else {
            var viewHeight = $.topology.view.getHeight(),
                iconPadding = this
                .getIconMargin(),
                padding = iconPadding.top + iconPadding.bottom;
            if (this.parent) {
                iconPadding = this.parent.getExpandPadding();
                padding += iconPadding.top + iconPadding.bottom
            }
            var maxHeight = viewHeight - padding;
            if (height > maxHeight) {
                height = maxHeight
            }
        }
        this.style["icon-height"] = height
    },
    getCenterCoords: function() {
        var bbox = this.getIconBBox();
        return {
            x: bbox.minX + bbox.width / 2,
            y: bbox.minY + bbox.height / 2
        }
    },
    getBBox: function() {
        return this.bbox
    },
    getIconMargin: function() {
        var bbox = this.getBBox(),
            iconBbox = this.getIconBBox();
        return {
            left: iconBbox.minX - bbox.minX,
            top: iconBbox.minY - bbox.minY,
            bottom: bbox.maxY - iconBbox.maxY,
            right: bbox.maxX - iconBbox.maxX
        }
    },
    show: function() {
        this.visible = true;
        this.draw();
        var $topo = $.topology;
        for (var id in this.lines) {
            var line = this.lines[id];
            var other = line.otherNode(this);
            if ($topo.isSymbol(other) && !other.visible) {
                continue
            }
            if ($topo.isContainer(other) && other.isExpand) {
                continue
            }
            if ($topo.isLine(line) && line.parent && line.parent.state == 1) {
                continue
            } else {
                if ($topo.isLineseter(line) && line.state == 1) {
                    if (line.isExpand) {
                        line.expand()
                    } else {
                        line.collapse()
                    }
                } else {
                    line.show()
                }
            }
        }
    },
    hide: function() {
        this.visible = false;
        this.draw();
        for (var id in this.lines) {
            this.lines[id].hide()
        }
    },
    add: function() {
        $.topology.addElement(this);
        this.draw()
    },
    draw: function() {
        $.topology.graphEngine.symbol(this);
        // if ($.topology.status === "SHOW") {
        $.topology.elementEventRender4IE9(this)
        // }
        $($.topology).triggerHandler("drawElement", this)
    },
    edgeDetect: function() {
        var bbox = this.getBBox(),
            minX = bbox.minX,
            minY = bbox.minY,
            maxX = bbox.maxX,
            maxY = bbox.maxY;
        if (this.parent) {
            var parentPadding = this.parent.getExpandPadding();
            minX -= parentPadding.left;
            minY -= parentPadding.top;
            maxX += parentPadding.bottom;
            maxY += parentPadding.right
        }
        var offset = $.topology.graphEngine.boxCanvasEdgeDetect(minX, minY,
            maxX, maxY);
        if (offset.x != 0 || offset.y != 0) {
            this.move(offset.x, offset.y);
            this.moveOver()
        }
    },
    change: function(drawing, needresize) {
        $.topology.changeElement(this);
        drawing = !(typeof drawing === "boolean" && drawing == false);
        if (drawing) {
            this.draw();
        }
        if (needresize) {console.log(this)
            this.onResize();

            //改变大小，刷新报警，nat，检索等信息
            var el = document.getElementById(this.id);
            var info = el.getBBox();

            var tipEl = $('#' + this.id).closest('g').find('.j-alarm-tip').get(0);
            if (tipEl) {
                tipEl.setAttribute("transform", 'translate(' + (info.x + info.width - 8) + ',' + (info.y - 8) + ')');
                tipEl.setAttribute('display', 'block');
            }

            var tipNat = $('#' + this.id).closest('g').find('.j-nat-tip').get(0);
            if (tipNat) {
                tipNat.setAttribute("transform", 'translate(' + (info.x - 26) + ',' + (info.y + 20) + ')');
                tipNat.setAttribute('display', 'block');
            }

            var markEl = $('#' + this.id).closest('g').find('#search_mark').get(0);

            if(markEl){
                markEl.setAttribute("width", info.width);
                markEl.setAttribute("height", info.height);
                markEl.setAttribute("x", info.x);
                markEl.setAttribute("y", info.y);
            }
        }
    },
    changeCoords: function() {
        $.topology.graphEngine.changeSymbolCoords(this);
        $($.topology).triggerHandler("drawElement", this)
    },
    remove: function() {
        for (var id in this.lines) {
            this.lines[id].remove()
        }
        if (this.parent) {
            this.parent.removeChild(this, true)
        }
        $.topology.removeElement(this);
        $.topology.graphEngine.remove("block_" + this.id)
    },
    move: function(x, y) {
        var moveX = Number(x, 10),
            moveY = Number(y, 10),
            x = this.x + moveX,
            y = this.y + moveY;
        var viewWidth = $.topology.view.getWidth(),
            viewHeight = $.topology.view.getHeight(),
            iconPadding = this.getIconMargin(),
            paddingLeft = iconPadding.left,
            paddingRight = this.getIconWidth() + iconPadding.right,
            paddingTop = iconPadding.top,
            paddingBottom = this.getIconHeight() + iconPadding.bottom;
        if (this.parent) {
            iconPadding = this.parent.getExpandPadding();
            paddingLeft += iconPadding.left;
            paddingRight += iconPadding.right;
            paddingTop += iconPadding.top;
            paddingBottom += iconPadding.bottom
        }
        var minX = paddingLeft,
            minY = paddingTop,
            maxX = viewWidth - paddingRight,
            maxY = viewHeight - paddingBottom;
        if (x < minX) {
            x = minX
        } else {
            if (x > maxX) {
                x = maxX
            }
        }
        if (y < minY) {
            y = minY
        } else {
            if (y > maxY) {
                y = maxY
            }
        }
        moveX = x - this.x;
        moveY = y - this.y;
        $.topology.view.moveNodes([this], moveX, moveY)
    },
    moveOver: function() {
        $.topology.view.moveNodesStop([this])
    },
    updateParentSize: function() {
        if (this.parent && this.parent.isExpand) {
            this.parent.renovate(true)
        }
    },
    onResize: function() {
        this.updateParentSize();
        this.updateRelationLinePosition()
    },
    updateRelationLinePosition: function() {
        var lines = this.lines,
            line;
        for (var k in lines) {
            line = lines[k];
            if (line.parent && line.parent.state == 1) {
                continue
            }
            line.updateNodePosition(this);
            line.changePath()
        }
    },
    updateRelationLineName: function() {
        var lines = this.lines,
            line;
        for (var k in lines) {
            line = lines[k];
            line.refreshName();
            line.change(false)
        }
    },
    addRelationLine: function(line) { // 添加关系线
        if (line && (line instanceof hy.topology.model.Line || line instanceof hy.topology.model.Lineseter)) {
            if ((line.srcNode == this || line.dstNode == this) && !(line.srcNode == this && line.dstNode == this)) {
                this.lines[line.id] = line;
                if (!this.visible) {
                    line.visible = false
                }
                if ($.topology.isLine(line)) {
                    var other = line.otherNode(this);
                    var toLines = $.topology.findLines(this, other);
                    if (toLines && toLines.length >= 2) {
                        var toLineseter = $.topology.findLineseter(this, other);
                        if (toLineseter) {
                            toLineseter.addChild(line, true);
                            line.change()
                        } else {
                            var name = this.getName() + " -> " + other.getName();
                            toLineseter = $.topology.createLineseter({
                                name: name
                            });
                            toLineseter.setSrcNode(this);
                            toLineseter.setDstNode(other);
                            toLineseter.add();
                            var l;
                            for (var k in toLines) {
                                l = toLines[k];
                                toLineseter.addChild(l, true);
                                l.change()
                            }
                        }
                    }
                }
            }
        }
    },
    removeRelationLine: function(line) { // 删除关系线
        if (line && (line instanceof hy.topology.model.Line || line instanceof hy.topology.model.Lineseter)) {
            delete this.lines[line.id];
            if ($.topology.isLine(line) && (line.srcNode == this || line.dstNode == this) && !(line.srcNode == this && line.dstNode == this)) {
                var other = line.otherNode(this);
                var toLines = $.topology.findLines(this, other);
                if (toLines && toLines.length <= 1) {
                    var toLineseter = $.topology.findLineseter(this, other);
                    if (toLineseter) {
                        toLineseter.remove(false)
                    }
                }
            }
        }
    }
};
extend(hy.topology.model.Symbol, hy.topology.model.BaseNode);
// /hy.topology.model.Container
hy.topology.model.Container = function() {
    this.children = null;
    this.expandSpacing = 40;
    this.expandX = 0;
    this.expandY = 0;
    this.expandWidth = 0;
    this.expandHeight = 0;
    this.isExpand = false;
    this.isPermit = true;
    this.lineseters = null;
    hy.topology.model.BaseNode.call(this);
    this.init.apply(this, arguments)
};
hy.topology.model.Container.prototype = {
    init: function() {
        var _data = arguments[0] || {};
        this.id = $.trim(_data.id) || $.topology.uuid();
        this.name = typeof _data.name == "string" ? _data.name : "";
        this.x = parseInt(_data.x) || 0;
        this.y = parseInt(_data.y) || 0;
        this.visible = true;
        this.objectId = $.trim(_data.objectId) || "";
        if (_data.objectClass && $.trim(_data.objectClass) !== "" && $.trim(_data.objectClass) !== "-1") {
            this.objectClass = $.trim(_data.objectClass)
        }
        this.instanceId = _data.instanceId || "";
        this.children = {};
        this.style = {};
        if (_data.style) {
            if ($.isPlainObject(_data.style)) {
                this.style = _data.style
            } else {
                if ($.type(_data.style) === "string") {
                    var _styleArr = _data.style.split(";");
                    for (var i = 0, len = _styleArr.length; i < len; i++) {
                        var _style = _styleArr[i].split(":");
                        if ($.trim(_style[0]) !== "") {
                            this.style[_style[0]] = _style[1]
                        }
                    }
                }
            }
        }
        this.option = {};
        if (_data.options) {
            if ($.isPlainObject(_data.options)) {
                this.option = _data.options
            } else {
                if ($.type(_data.options) === "string") {
                    var _optionArr = _data.options.split(";");
                    for (var i = 0, len = _optionArr.length; i < len; i++) {
                        var _option = _optionArr[i].split(":");
                        if ($.trim(_option[0]) !== "") {
                            this.option[_option[0]] = _option[1]
                        }
                    }
                }
            }
        }
        this.bbox = {};
        this.expandX = parseInt(this.option["container-x"]);
        this.expandY = parseInt(this.option["container-y"]);
        if (isNaN(this.expandX)) {
            this.expandX = this.x
        }
        if (isNaN(this.expandY)) {
            this.expandY = this.y
        }
        this.expandWidth = parseInt(this.option["container-width"]);
        this.expandHeight = parseInt(this.option["container-height"]);
        if (isNaN(this.expandWidth)) {
            this.expandWidth = this.expandSpacing
        }
        if (isNaN(this.expandHeight)) {
            this.expandHeight = this.expandSpacing
        }
        this.isExpand = this.option["container-expand"] && this.option["container-expand"] === "1" ? true : false;
        this.isPermit = this.option["container-permit"] && this.option["container-permit"] === "0" ? false : true;
        this.autoResize = this.option["container-expand-autoresize"] && this.option["container-expand-autoresize"] === "0" ? false : true;
        this.lineseters = {};
        if (_data.url) {
            if ($.isPlainObject(_data.url)) {
                this.url = _data.url
            } else {
                if ($.type(_data.url) === "string") {
                    this.url = {
                        name: [],
                        icon: [],
                        link: [],
                        open: []
                    };
                    var _urlArr = eval(_data.url);
                    for (var i = 0, len = _urlArr.length; i < len; i++) {
                        this.url.name.push(_urlArr[i].n);
                        this.url.icon.push(_urlArr[i].i);
                        this.url.link.push(_urlArr[i].l);
                        this.url.open.push(_urlArr[i].o)
                    }
                }
            }
        } else {
            this.url = null
        }
        this.alarm = {};
        if (_data.alarm) {
            if ($.isPlainObject(_data.alarm)) {
                this.alarm = _data.alarm
            } else {
                if ($.type(_data.alarm) === "string") {
                    var _alarmArr = _data.alarm.split(";");
                    for (var i = 0, len = _alarmArr.length; i < len; i++) {
                        var _alarm = _alarmArr[i].split(":");
                        if ($.trim(_alarm[0]) !== "") {
                            this.alarm[_alarm[0]] = _alarm[1]
                        }
                    }
                }
            }
        }
    },
    getObjectClass: function() {
        return "container"
    },
    getLines: function() {
        return this.lineseters
    },
    getCollapseIconWidth: function() {
        return parseInt(this.style["icon-width"])
    },
    getCollapseIconHeight: function() {
        return parseInt(this.style["icon-height"])
    },
    setCollapseIconWidth: function(width) {
        if (width < 1) {
            width = 1
        } else {
            var viewWidth = $.topology.view.getWidth(),
                iconPadding = this.getCollapseIconMargin(),
                padding = iconPadding.left + iconPadding.right,
                maxWidth = viewWidth - padding;
            if (width > maxWidth) {
                width = maxWidth
            }
        }
        this.style["icon-width"] = width
    },
    setCollapseIconHeight: function(height) {
        if (height < 1) {
            height = 1
        } else {
            var viewHeight = $.topology.view.getHeight(),
                iconPadding = this.getCollapseIconMargin(),
                padding = iconPadding.top + iconPadding.bottom,
                maxHeight = viewHeight - padding;
            if (height > maxHeight) {
                height = maxHeight
            }
        }
        this.style["icon-height"] = height
    },
    setExpandIconWidth: function(width) {
        if (width < 1) {
            width = 1
        } else {
            var viewWidth = $.topology.view.getWidth(),
                iconMargin = this
                .getExpandIconMargin(),
                marginX = iconMargin.left + iconMargin.right,
                maxWidth = viewWidth - marginX;
            if (width > maxWidth) {
                width = maxWidth
            }
        }
        this.expandWidth = width
    },
    setExpandIconHeight: function(height) {
        if (height < 1) {
            height = 1
        } else {
            var viewHeight = $.topology.view.getHeight(),
                iconMargin = this
                .getExpandIconMargin(),
                marginY = iconMargin.top + iconMargin.bottom,
                maxHeight = viewHeight - marginY;
            if (height > maxHeight) {
                height = maxHeight
            }
        }
        this.expandHeight = height
    },
    getExpandIconWidth: function() {
        return this.expandWidth
    },
    getExpandIconHeight: function() {
        return this.expandHeight
    },
    getIconBBox: function() {
        if (this.isExpand) {
            return this.getExpandIconBBox()
        } else {
            return this.getCollapseIconBBox()
        }
    },
    getCollapseIconMargin: function() {
        var collapseBbox = this.getCollapseBBox(),
            iconBbox = this.getCollapseIconBBox();
        return {
            left: iconBbox.minX - collapseBbox.minX,
            top: iconBbox.minY - collapseBbox.minY,
            bottom: collapseBbox.maxY - iconBbox.maxY,
            right: collapseBbox.maxX - iconBbox.maxX
        }
    },
    getExpandPadding: function() {
        var iconMargin = this.getExpandIconMargin(),
            expandSpacing = this.expandSpacing;
        return {
            left: iconMargin.left + expandSpacing / 2,
            top: iconMargin.top + expandSpacing / 2,
            bottom: iconMargin.bottom + expandSpacing / 2,
            right: iconMargin.right + expandSpacing / 2
        }
    },
    getExpandIconMargin: function() {
        var expandBbox = this.getExpandBBox(),
            iconBbox = this.getExpandIconBBox();
        return {
            left: iconBbox.minX - expandBbox.minX,
            top: iconBbox.minY - expandBbox.minY,
            bottom: expandBbox.maxY - iconBbox.maxY,
            right: expandBbox.maxX - iconBbox.maxX
        }
    },
    getExpandIconBBox: function() {
        return {
            minX: this.expandX,
            minY: this.expandY,
            width: this.expandWidth,
            height: this.expandHeight,
            maxX: this.expandX + this.expandWidth,
            maxY: this.expandY + this.expandHeight
        }
    },
    getCollapseIconBBox: function() {
        return {
            minX: this.x,
            minY: this.y,
            maxX: this.x + this.getCollapseIconWidth(),
            maxY: this.y + this.getCollapseIconHeight(),
            width: this.getCollapseIconWidth(),
            height: this.getCollapseIconHeight()
        }
    },
    getCenterCoords: function() {
        return this.getCollapseCenterCoords()
    },
    getCollapseCenterCoords: function() {
        var bbox = this.getCollapseIconBBox();
        return {
            x: bbox.minX + bbox.width / 2,
            y: bbox.minY + bbox.height / 2
        }
    },
    getExpandCenterCoords: function() {
        var bbox = this.getExpandIconBBox();
        return {
            x: bbox.minX + bbox.width / 2,
            y: bbox.minY + bbox.height / 2
        }
    },
    getBBox: function() {
        return this.isExpand ? this.getExpandBBox() : this.getCollapseBBox()
    },
    getCollapseBBox: function() {
        return {
            minX: this.bbox.minX,
            minY: this.bbox.minY,
            maxX: this.bbox.maxX,
            maxY: this.bbox.maxY,
            width: this.bbox.width,
            height: this.bbox.height
        }
    },
    getExpandBBox: function() {
        return {
            minX: this.bbox.expandMinX,
            minY: this.bbox.expandMinY,
            maxX: this.bbox.expandMaxX,
            maxY: this.bbox.expandMaxY,
            width: this.bbox.expandWidth,
            height: this.bbox.expandHeight
        }
    },
    setExpandBBox: function(bbox) {
        if (!bbox) {
            return
        }
        this.bbox.expandMinX = Number(bbox.x);
        this.bbox.expandMinY = Number(bbox.y);
        this.bbox.expandWidth = Number(bbox.width);
        this.bbox.expandHeight = Number(bbox.height);
        this.bbox.expandMaxX = this.bbox.expandMinX + this.bbox.expandWidth;
        this.bbox.expandMaxY = this.bbox.expandMinY + this.bbox.expandHeight
    },
    setCollapseBBox: function(bbox) {
        if (!bbox) {
            return
        }
        this.bbox.minX = Number(bbox.x);
        this.bbox.minY = Number(bbox.y);
        this.bbox.width = Number(bbox.width);
        this.bbox.height = Number(bbox.height);
        this.bbox.maxX = this.bbox.minX + this.bbox.width;
        this.bbox.maxY = this.bbox.minY + this.bbox.height
    },
    setName: function(name) {
        this.name = name;
        this.updateRelationLineName();
        this.draw()
    },
    expand: function() {
        this.isExpand = true;
        for (var id in this.children) {
            this.children[id].show()
        }
        for (var id in this.lineseters) {
            this.lineseters[id].hide()
        }
        this.renovate();
        this.draw();
        var expandIconCenter = this.getExpandCenterCoords(),
            collapseIconCenter = this.getCollapseCenterCoords();
        var offsetX = collapseIconCenter.x - expandIconCenter.x,
            offsetY = collapseIconCenter.y - expandIconCenter.y;
        this.moveExpand(offsetX, offsetY);
        this.expandEdgeDetect();
        var $topo = $.topology;
        for (var id in this.children) {
            var lines = this.children[id].lines,
                line;
            for (var k in lines) {
                line = lines[k];
                if ($topo.isLineseter(line) && line.state == 1) {
                    line.renovate()
                }
            }
        }
    },
    collapse: function() {
        this.isExpand = false;
        this.draw();
        var $topo = $.topology;
        for (var id in this.lineseters) {
            var lineseter = this.lineseters[id];
            var other = lineseter.otherNode(this);
            if (other) {
                if ($topo.isSymbol(other)) {
                    if (other.visible) {
                        lineseter.show()
                    } else {
                        lineseter.hide()
                    }
                } else {
                    if ($topo.isContainer(other)) {
                        if (!other.isExpand) {
                            lineseter.show()
                        } else {
                            lineseter.hide()
                        }
                    }
                }
            }
        }
        for (var id in this.children) {
            this.children[id].hide()
        }
        var expandIconCenter = this.getExpandCenterCoords(),
            collapseIconCenter = this.getCollapseCenterCoords();
        var offsetX = expandIconCenter.x - collapseIconCenter.x,
            offsetY = expandIconCenter.y - collapseIconCenter.y;
        this.moveCollapse(offsetX, offsetY);
        this.collapseEdgeDetect()
    },
    edgeDetect: function() {
        if (this.isExpand) {
            this.expandEdgeDetect()
        } else {
            this.collapseEdgeDetect()
        }
    },
    collapseEdgeDetect: function() {
        var bbox = this.getCollapseBBox();
        var offset = $.topology.graphEngine.boxCanvasEdgeDetect(bbox.minX, bbox.minY, bbox.maxX, bbox.maxY);
        if (offset.x != 0 || offset.y != 0) {
            this.moveCollapse(offset.x, offset.y)
        }
    },
    expandEdgeDetect: function() {
        var bbox = this.getExpandBBox();
        var offset = $.topology.graphEngine.boxCanvasEdgeDetect(bbox.minX, bbox.minY, bbox.maxX, bbox.maxY);
        if (offset.x != 0 || offset.y != 0) {
            this.moveExpand(offset.x, offset.y)
        }
    },
    addChild: function(symbol, drawing) {
        if (!symbol || !symbol instanceof hy.topology.model.Symbol) {
            return

        }
        if (drawing && !this.isExpand) {
            this.expand()
        }
        symbol.visible = this.isExpand;
        this.children[symbol.id] = symbol;
        symbol.parent = this;
        $.topology.shapes.symbols[symbol.id] = symbol;
        for (var lid in symbol.lines) {
            $.topology.changed.modify.push(lid)
        }
        $.topology.changed.alarmTfr = true;
        if (drawing) {
            if (!$.topology.graphEngine.isDrew(symbol.id)) {
                symbol.draw()
            }
            this.renovate(drawing);
            $.topology.updateVirtualLine();
            $.topology.graphEngine.coverage.dropNode(symbol)
        }
    },
    removeChild: function(symbol, drawing, deep) {
        var $topo = $.topology;
        if (!$topo.isSymbol(symbol)) {
            return
        }
        delete this.children[symbol.id];
        $topo.changed.alarmTfr = true;
        if (symbol) {
            symbol.parent = null;
            symbol.change()
        }
        if (drawing) {
            this.renovate(drawing);
            this.change();
            $topo.graphEngine.coverage.dropNode(symbol);
            $topo.updateVirtualLine()
        }
        if (deep) {
            symbol.remove()
        }
    },
    changeCoords: function() {
        $.topology.graphEngine.changeContainerCoords(this);
        $($.topology).triggerHandler("drawElement", this)
    },
    changeExpandSize: function() {
        $.topology.graphEngine.updateContainerExpandSize(this)
    },
    move: function(x, y) {
        if (this.isExpand) {
            this.moveExpand(x, y)
        } else {
            this.moveCollapse(x, y)
        }
    },
    moveOver: function() {
        $.topology.view.moveNodesStop([this])
    },
    moveExpand: function(x, y) {
        var moveX = Number(x, 10),
            moveY = Number(y, 10);
        var viewWidth = $.topology.view.getWidth(),
            viewHeight = $.topology.view
            .getHeight(),
            iconPadding = this.getExpandIconMargin(),
            paddingLeft = iconPadding.left,
            paddingRight = this
            .getExpandIconWidth() + iconPadding.right,
            paddingTop = iconPadding.top,
            paddingBottom = this
            .getExpandIconHeight() + iconPadding.bottom;
        var minX = paddingLeft,
            minY = paddingTop,
            maxX = viewWidth - paddingRight,
            maxY = viewHeight - paddingBottom;
        if (this.expandX + moveX < minX) {
            moveX = minX - this.expandX
        } else {
            if (this.expandX + moveX > maxX) {
                moveX = maxX - this.expandX
            }
        }
        if (this.expandY + moveY < minY) {
            moveY = minY - this.expandY
        } else {
            if (this.expandY + moveY > maxY) {
                moveY = maxY - this.expandY
            }
        }
        $.topology.view.moveNodes([this], moveX, moveY);
        $.topology.view.moveNodesStop([this])
    },
    moveCollapse: function(x, y) {
        var moveX = Number(x, 10),
            moveY = Number(y, 10);
        var viewWidth = $.topology.view.getWidth(),
            viewHeight = $.topology.view
            .getHeight(),
            iconPadding = this.getCollapseIconMargin(),
            paddingLeft = iconPadding.left,
            paddingRight = this
            .getCollapseIconWidth() + iconPadding.right,
            paddingTop = iconPadding.top,
            paddingBottom = this
            .getCollapseIconHeight() + iconPadding.bottom;
        var minX = paddingLeft,
            minY = paddingTop,
            maxX = viewWidth - paddingRight,
            maxY = viewHeight - paddingBottom;
        if (this.x + moveX < minX) {
            moveX = minX - this.x
        } else {
            if (this.x + moveX > maxX) {
                moveX = maxX - this.x
            }
        }
        if (this.y + moveY < minY) {
            moveY = minY - this.y
        } else {
            if (this.y + moveY > maxY) {
                moveY = maxY - this.y
            }
        }
        $.topology.view.moveNodes([this], moveX, moveY);
        $.topology.view.moveNodesStop([this])
    },
    updateRelationLinePosition: function() {
        var lineseters = this.lineseters,
            lineseter;
        for (var id in lineseters) {
            lineseter = lineseters[id];
            lineseter.updateNodePosition(this);
            lineseter.changePath()
        }
    },
    updateRelationLineName: function() {
        var lineseters = this.lineseters,
            lineseter;
        for (var id in lineseters) {
            lineseter = lineseters[id];
            lineseter.refreshName();
            lineseter.change(false)
        }
    },
    moveChild: function(x, y) {
        for (var id in this.children) {
            this.children[id].move(x, y, false)
        }
    },
    add: function() {
        $.topology.addElement(this);
        this.draw()
    },
    draw: function() {
        $.topology.graphEngine.container(this);
        // if ($.topology.status === "SHOW") {
        $.topology.elementEventRender4IE9(this)
        // }
        $($.topology).triggerHandler("drawElement", this)
    },
    change: function(drawing) {
        $.topology.changeElement(this);
        drawing = !(typeof drawing === "boolean" && drawing == false);
        if (drawing) {
            this.draw()
        }
    },
    remove: function(deep) {
        for (var id in this.lineseters) {
            if (this.lineseters[id] instanceof hy.topology.model.Lineseter) {
                this.lineseters[id].remove()
            }
        }
        if (deep) {
            for (var id in this.children) {
                this.children[id].remove()
            }
            $.topology.changed.alarmTfr = true
        } else {
            for (var id in this.children) {
                this.children[id].parent = null;
                this.children[id].show();
                this.children[id].change()
            }
        }
        $.topology.removeElement(this);
        $.topology.graphEngine.remove("block_" + this.id);
        $.topology.graphEngine.remove("block_container_" + this.id)
    },
    renovate: function(drawing) {
        if ($.isEmptyObject(this.children)) {
            this.expandWidth = this.expandSpacing;
            this.expandHeight = this.expandSpacing
        } else {
            var children = [];
            for (var id in this.children) {
                children.push(this.children[id])
            }
            var bbox = $.topology.getNodesBBox(children);
            this.expandX = bbox.minX - this.expandSpacing / 2;
            this.expandY = bbox.minY - this.expandSpacing / 2;
            this.setExpandIconWidth(bbox.width + this.expandSpacing);
            this.setExpandIconHeight(bbox.height + this.expandSpacing)
        }
        if (drawing) {
            this.changeCoords();
            this.changeExpandSize()
        }
    },
    addRelationLine: function(line) {
        if (line && line instanceof hy.topology.model.Lineseter) {
            this.lineseters[line.id] = line;
            if (this.isExpand) {
                line.visible = false
            }
        }
    },
    removeRelationLine: function(line) {
        if (line && line instanceof hy.topology.model.Lineseter) {
            delete this.lineseters[line.id]
        }
    }
};
extend(hy.topology.model.Container, hy.topology.model.BaseNode);
// /hy.topology.model.BaseLine
hy.topology.model.BaseLine = function() { // 基线模型
    this.id = "";
    this.name = "";
    this.path = null;
    this.srcNode = null; // 起点
    this.dstNode = null; // 终点
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
    this.points = [
        [0, 0],
        [0, 0]
    ];
    this.visible = true;
    this.objectId = null;
    this.objectClass = null;
    this.objectType = null;

    this.isRelaRes = false;
    this.statusRela = null;
    this.metricId = null;
    this.relaType = null;
    this.isDbclick = false;
    this.dbclickType = null;
    this.dbclickRes = null;

    this.instanceId = null;
    this.kpis = null;
    this.eventIds = null;
    this.status = null;
    this.style = null;
    this.option = null;
    this.url = null;
    this.alarm = null
};
hy.topology.model.BaseLine.prototype = {
    draw: function() { // 基类画线
        var $topo = $.topology;
        if (this instanceof hy.topology.model.Line) {
            if ($topo.shapes.lines[this.id]) {
                $topo.graphEngine.line(this); // 引擎线
                $($topo).triggerHandler("drawElement", this)
            }
        } else {
            if (this instanceof hy.topology.model.Lineseter) {
                if ($topo.shapes.lineseters[this.id]) {
                    $topo.graphEngine.lineseter(this);
                    $($topo).triggerHandler("drawElement", this)
                }
            }
        }
        // if ($topo.status === "SHOW") {
        $topo.elementEventRender4IE9(this)
        // }
    },
    getPointCount: function() {
        return this.points.length
    },
    addPoint: function(index, x, y) {
        var c = this.getPointCount();
        if (index >= c - 1 || index < 0) {
            return
        }
        if (!isNaN(x) && !isNaN(y)) {
            var p = [x, y];
            this.points.splice(index + 1, 0, p)
        }
        this.path = $.topology.graphEngine.path(this.points)
    },
    removePoint: function(index) {
        var c = this.getPointCount();
        if (index >= c - 1 || index < 0) {
            return
        }
        this.points.splice(index, 1);
        this.path = $.topology.graphEngine.path(this.points)
    },
    isPolyline: function() {
        return this.getPointCount() > 2
    },
    setPoints: function(x) {
        if (x && $.isArray(x)) {
            this.points = x;
            this.x1 = parseInt(this.points[0][0]);
            this.y1 = parseInt(this.points[0][1]);
            this.x2 = parseInt(this.points[this.points.length - 1][0]);
            this.y2 = parseInt(this.points[this.points.length - 1][1]);
            this.path = $.topology.graphEngine.path(x)
        }
    },
    setPoint: function(index, x, y) { // 设置坐标点

        index = parseInt(index, 10);
        x = Number(x);
        y = Number(y);
        var len = this.points.length;
        if (index >= 0 && !isNaN(x) && !isNaN(y)) {
            this.points[index] = [x, y];
            if (index == 0) {
                this.x1 = parseInt(x);
                this.y1 = parseInt(y)
            } else {
                if (index == len - 1) {
                    this.x2 = parseInt(x);
                    this.y2 = parseInt(y)
                }
            }
        }
        this.path = $.topology.graphEngine.path(this.points)
    },
    otherNode: function(node) {
        var other = null;
        if (node) {
            if (this.srcNode && this.srcNode.id == node.id) {
                other = this.dstNode
            } else {
                if (this.dstNode && this.dstNode.id == node.id) {
                    other = this.srcNode
                }
            }
        }
        return other
    },
    updateNodePosition: function(node) {
        if (node) {
            if (this.srcNode && this.srcNode.id == node.id) {
                this.updateSrcPosition()
            }
            if (this.dstNode && this.dstNode.id == node.id) {
                this.updateDstPosition()
            }
        } else {
            this.updateSrcPosition();
            this.updateDstPosition()
        }
    },
    updateSrcPosition: function() {
        if (this.srcNode) {
            var coords = this.srcNode.getCenterCoords();
            this.setPoint(0, coords.x, coords.y)
        }
    },
    updateDstPosition: function() {
        if (this.dstNode) {
            var coords = this.dstNode.getCenterCoords();
            var idx = this.points.length - 1;
            if (idx < 1) {
                idx = 1
            }
            this.setPoint(idx, coords.x, coords.y)
        }
    },
    move: function(dx, dy) {
        var x, y;
        for (var i = 0; i < this.points.length; i++) {
            x = this.points[i][0] + dx;
            y = this.points[i][1] + dy;
            this.setPoint(i, x, y)
        }
    },
    rightAngle: function() { // 改变角度
        var _points = this.points;
        if (_points.length <= 2) {
            return
        }
        var isPointToHori = Math.abs(this.x2 - this.x1) > Math.abs(this.y2 - this.y1) ? true : false;
        if (_points.length === 3) {
            if (isPointToHori) {
                _points[1][0] = _points[2][0];
                _points[1][1] = _points[0][1]
            } else {
                _points[1][0] = _points[0][0];
                _points[1][1] = _points[2][1]
            }
        } else {
            if (_points.length === 4) {
                if (isPointToHori) {
                    _points[1][0] = _points[2][0] = parseInt(this.x1 + (this.x2 - this.x1) / 2);
                    _points[1][1] = this.y1;
                    _points[2][1] = this.y2
                } else {
                    _points[1][1] = _points[2][1] = parseInt(this.y1 + (this.y2 - this.y1) / 2);
                    _points[1][0] = this.x1;
                    _points[2][0] = this.x2
                }
            } else {
                if (isPointToHori) {
                    for (var i = 1, len = _points.length - 1; i < len; i++) {
                        if (i === 1) {
                            _points[i][0] = _points[i + 1][0];
                            _points[i][1] = _points[i - 1][1];
                            continue
                        }
                        if (i % 2 === 0) {
                            _points[i][1] = _points[i + 1][1]
                        } else {
                            _points[i][0] = _points[i + 1][0]
                        }
                    }
                } else {
                    for (var i = 1, len = _points.length - 1; i < len; i++) {
                        if (i === 1) {
                            _points[i][0] = _points[i - 1][0];
                            _points[i][1] = _points[i + 1][1];
                            continue
                        }
                        if (i % 2 === 0) {
                            _points[i][0] = _points[i + 1][0]
                        } else {
                            _points[i][1] = _points[i + 1][1]
                        }
                    }
                }
            }
        }
        this.path = $.topology.graphEngine.path(_points); // 根据点改变路径
        return this
    },
    rightCurveAngle: function() { // 改变角度
        var _points = this.points;
        if (_points.length <= 3) { // 曲线最少要四个点
            layer.msg("曲线需要两个参考点", { icon: 0 });
            return
        }
        if (_points.length > 4) { // 曲线最少要四个点
            layer.msg("曲线需要两个参考点", { icon: 0 });
            return
        }
        this.path = $.topology.graphEngine.path2(_points); // 根据点改变路径
        return this
    },
    getName: function() {
        if (typeof this.name !== "string") {
            this.name = ""
        }
        return this.name
    },
    isAutoRefreshName: function() {
        var customLabel = this.option["custom-label"];
        return !!customLabel && customLabel == 0
    },
    refreshName: function() {
        if (this.isAutoRefreshName() && (!!this.objectId == false || this.objectId == -1)) {
            var srcName = !!this.srcNode ? this.srcNode.getName() : "";
            var dstName = !!this.dstNode ? this.dstNode.getName() : "";
            this.name = srcName + " -> " + dstName
        }
    },
    getBBox: function() {
        var bbox = $.topology.graphEngine.getBBox(this.id);
        var lineBBox = null;
        if (bbox) {
            lineBBox = {};
            lineBBox.minX = bbox.x;
            lineBBox.minY = bbox.y;
            lineBBox.maxX = bbox.x + bbox.width;
            lineBBox.maxY = bbox.y + bbox.height
        }
        return lineBBox
    },
    getTotalLength: function() {
        return $.topology.graphEngine.getPathTotalLength(this.id)
    },
    getPointAtLength: function(length) {
        return $.topology.graphEngine.getPointAtLength(this.id, length)
    },
    getCenterCoords: function() {
        var bbox = this.getBBox();
        return bbox ? {
            x: bbox.minX + bbox.width / 2,
            y: bbox.minY + bbox.height / 2
        } : null
    },
    serialize: function() {
        console.log("serialize 2")
        if ($.topology.isLineseter(this)) {
            this.option["lineseter-expand"] = this.isExpand ? "1" : "0";
            this.option["lineseter-permit"] = this.isExpand ? "1" : "0"
        }
        var json = "{";
        json += '"id":"' + this.id + '",';
        json += '"name":"' + (this.name ? $.string.quoteString(this.name) : "") + '",';
        json += '"path":"' + this.path + '",';
        json += '"type":"' + (this instanceof hy.topology.model.Lineseter ? 1 : 0) + '",';
        json += '"srcSymbol":"' + (this.srcNode ? this.srcNode.id : "-1") + '",';
        json += '"dstSymbol":"' + (this.dstNode ? this.dstNode.id : "-1") + '",';
        json += '"viewId":"' + $.topology.view.id + '",';
        json += '"parentId":"' + (this.parent ? this.parent.id : "-1") + '",';
        json += '"objectId":"' + (this.objectId ? this.objectId : "-1") + '",';
        json += '"objectClass":"' + (this.objectClass ? this.objectClass : "-1") + '",';
        json += '"objectType":"' + (this.objectType ? this.objectType : "-1") + '",';
        json += '"instanceId":"' + (this.instanceId ? this.instanceId : "-1") + '",';

        json += '"isRelaRes":"' + this.isRelaRes + '",';
        json += '"statusRela":"' + this.statusRela + '",';
        json += '"metricId":"' + this.metricId + '",';
        json += '"relaType":"' + this.relaType + '",';
        json += '"isDbclick":"' + this.isDbclick + '",';
        json += '"dbclickType":"' + this.dbclickType + '",';
        json += '"dbclickRes":"' + this.dbclickRes + '",';
        var _style = "";
        for (var key in this.style) {
            if (key.length == 0) {
                continue
            }
            _style += key + ":" + this.style[key] + ";"
        }
        json += '"style":"' + _style + '",';
        var _option = "";
        for (var key in this.option) {
            if (key.length == 0) {
                continue
            }
            _option += key + ":" + this.option[key] + ";"
        }
        json += '"options":"' + _option + '",';
        if (this.url && this.url.name.length > 0) {
            var _url = "[";
            for (var i = 0, len = this.url.name.length; i < len; i++) {
                _url += "{'n':'" + $.string.quoteString(this.url.name[i]) + "',";
                _url += "'i':'" + this.url.icon[i] + "',";
                _url += "'l':'" + $.string.quoteString(this.url.link[i]) + "',";
                _url += "'o':'" + this.url.open[i] + "'}";
                _url += (i !== len - 1 ? "," : "]")
            }
            json += '"url":"' + _url + '",'
        } else {
            json += '"url":"",'
        }
        var _alarm = "";
        for (var key in this.alarm) {
            if (key.length == 0) {
                continue
            }
            _alarm += key + ":" + this.alarm[key] + ";"
        }
        json += '"alarm":"' + _alarm + '"}';
        return json
    }
};
// /hy.topology.model.Line
hy.topology.model.Line = function() { // 线模型
    this.parent = null;
    this.isRelaRes = false;
    this.statusRela = null;
    this.metricId = null;
    this.relaType = null;
    this.isDbclick = false;
    this.dbclickType = null;
    this.dbclickRes = null;
    hy.topology.model.BaseLine.call(this); // 基线模型
    this.init.apply(this, arguments)
};
hy.topology.model.Line.prototype = {
    init: function() {
        var _data = arguments[0] || {};
        this.id = $.trim(_data.id) || $.topology.uuid();
        this.name = typeof _data.name == "string" ? _data.name : "";
        var path = $.trim(_data.path);

        if (path) {
            this.setPath(path)
        }
        this.objectId = _data.objectId && $.trim(_data.objectId) !== "-1" ? $
            .trim(_data.objectId) : null;
        if (_data.objectClass && $.trim(_data.objectClass) !== "" && $.trim(_data.objectClass) !== "-1") {
            this.objectClass = $.trim(_data.objectClass)
        }

        if (_data.objectType && $.trim(_data.objectType) !== "" && $.trim(_data.objectType) !== "-1") {
            this.objectType = $.trim(_data.objectType)
        }

        // 连线是否关联资源
        if (_data.isRelaRes && $.trim(_data.isRelaRes) !== "" && $.trim(_data.isRelaRes) !== "-1") {
            this.isRelaRes = $.trim(_data.isRelaRes)
        }

        // 连线状态表示
        if (_data.statusRela && $.trim(_data.statusRela) !== "" && $.trim(_data.statusRela) !== "-1") {
            this.statusRela = $.trim(_data.statusRela)
        }

        // 连线状态表示
        if (_data.relaType && $.trim(_data.relaType) !== "" && $.trim(_data.relaType) !== "-1") {
            this.relaType = $.trim(_data.relaType)
        }
        // 连线状态表示
        if (_data.metricId && $.trim(_data.metricId) !== "" && $.trim(_data.metricId) !== "-1") {
            this.metricId = $.trim(_data.metricId)
        }
        // 连线双击
        if (_data.isDbclick && $.trim(_data.isDbclick) !== "" && $.trim(_data.isDbclick) !== "-1") {
            this.isDbclick = $.trim(_data.isDbclick)
        }

        // 连线双击展示类型
        if (_data.dbclickType && $.trim(_data.dbclickType) !== "" && $.trim(_data.dbclickType) !== "-1") {
            this.dbclickType = $.trim(_data.dbclickType)
        }

        // 连线双击关联的内容
        if (_data.dbclickRes && $.trim(_data.dbclickRes) !== "" && $.trim(_data.dbclickRes) !== "-1") {
            this.dbclickRes = $.trim(_data.dbclickRes)
        }

        this.instanceId = _data.instanceId && $.trim(_data.instanceId) !== "-1" ? $
            .trim(_data.instanceId) : null;
        this.style = {};
        if (_data.style) {
            if ($.isPlainObject(_data.style)) {
                this.style = _data.style
            } else {
                if ($.type(_data.style) === "string") {
                    var _styleArr = _data.style.split(";");
                    for (var i = 0, len = _styleArr.length; i < len; i++) {
                        var _style = _styleArr[i].split(":");
                        if ($.trim(_style[0]) !== "") {
                            this.style[_style[0]] = _style[1]
                        }
                    }
                }
            }
        }
        this.option = {};
        if (_data.options) {
            if ($.isPlainObject(_data.options)) {
                this.option = _data.options
            } else {
                if ($.type(_data.options) === "string") {
                    var _optionArr = _data.options.split(";");
                    for (var i = 0, len = _optionArr.length; i < len; i++) {
                        var _option = _optionArr[i].split(":");
                        if ($.trim(_option[0]) !== "") {
                            this.option[_option[0]] = _option[1]
                        }
                    }
                }
            }
        }
        if (_data.url) {
            if ($.isPlainObject(_data.url)) {
                this.url = _data.url
            } else {
                if ($.type(_data.url) === "string") {
                    this.url = {
                        name: [],
                        icon: [],
                        link: [],
                        open: []
                    };
                    var _urlArr = eval(_data.url);
                    for (var i = 0, len = _urlArr.length; i < len; i++) {
                        this.url.name.push(_urlArr[i].n);
                        this.url.icon.push(_urlArr[i].i);
                        this.url.link.push(_urlArr[i].l);
                        this.url.open.push(_urlArr[i].o)
                    }
                }
            }
        } else {
            this.url = null
        }
        this.alarm = {};
        if (_data.alarm) {
            if ($.isPlainObject(_data.alarm)) {
                this.alarm = _data.alarm
            } else {
                if ($.type(_data.alarm) === "string") {
                    var _alarmArr = _data.alarm.split(";");
                    for (var i = 0, len = _alarmArr.length; i < len; i++) {
                        var _alarm = _alarmArr[i].split(":");
                        if ($.trim(_alarm[0]) !== "") {
                            this.alarm[_alarm[0]] = _alarm[1]
                        }
                    }
                }
            }
        }
        this.setSrcNode(_data.srcSymbol);
        this.setDstNode(_data.dstSymbol);
        if (_data.parentId && $.trim(_data.parentId) !== "" && $.trim(_data.parentId) !== "-1") {
            this.parent = $.topology.shapes.lineseters[$.trim(_data.parentId)] || null;
            if (this.parent) {
                this.parent.addChild(this)
            }
        }
    },
    setSrcNode: function(symbol) { // 设置起点
        if (this.srcNode) {
            this.srcNode.removeRelationLine(this); // 删除关系线
            this.srcNode = null
        }
        if (typeof symbol !== "object") {
            symbol = $.topology.shapes.symbols[symbol]
        }
        if (symbol) {

            this.srcNode = symbol;
            this.updateSrcPosition();
            this.srcNode.addRelationLine(this); // 添加关系线
            this.refreshName()
        }

    },
    setDstNode: function(symbol) { // 设置终点
        if (this.dstNode) {
            this.dstNode.removeRelationLine(this); // 删除关系线
            this.dstNode = null
        }
        if (typeof symbol !== "object") {
            symbol = $.topology.shapes.symbols[symbol]
        }
        if (symbol) {
            this.dstNode = symbol;
            this.updateDstPosition();
            this.dstNode.addRelationLine(this); // 添加关系线
            this.refreshName()
        }
    },
    setCurveNode: function() { // 设置曲线点
        var _Src_X = this.srcNode.getCenterCoords().x;
        var _Src_Y = this.srcNode.getCenterCoords().y;
        var _Dst_X = this.dstNode.getCenterCoords().x;
        var _Dst_Y = this.dstNode.getCenterCoords().y;
        this.path = "M " + _Src_X + ", " + _Src_Y + " C " + (_Src_X + 100) + ", " + _Src_Y + " " + _Dst_X + ", " + (_Dst_Y + 100) + " " + _Dst_X + ", " + _Dst_Y;
    },
    getObjectClass: function() {
        if (this.objectId && this.objectId != -1) {
            return this.objectClass
        } else {
            return "line"
        }
    },
    changePath: function() { // 改变路径
        $.topology.graphEngine.changeLinePath(this); // 改变线路径
        $($.topology).triggerHandler("drawElement", this)
    },
    setPath: function(pathStr) {
        this.path = pathStr || "";
        if (pathStr) {
            this.points = $.topology.graphEngine.path(pathStr);
            if (this.points.length >= 2) {
                this.x1 = parseInt(this.points[0][0]);
                this.y1 = parseInt(this.points[0][1]);
                this.x2 = parseInt(this.points[this.points.length - 1][0]);
                this.y2 = parseInt(this.points[this.points.length - 1][1])
            }
        }
    },
    show: function() {
        this.visible = true;
        $.topology.graphEngine.show("block_" + this.id);
        // if ($.topology.status === "SHOW") {
        $.topology.elementEventRender4IE9(this)
        // }
        $($.topology).triggerHandler("drawElement", this)
    },
    hide: function() {
        this.visible = false;
        $.topology.graphEngine.hide("block_" + this.id);
        $($.topology).triggerHandler("drawElement", this)
    },
    add: function() {
        $.topology.addElement(this); // 添加元素
        this.draw() // 基类画线
    },
    change: function(drawing) { // 更新拖动点
        this.refreshName();
        $.topology.changeElement(this); // 改变元素
        drawing = !(typeof drawing === "boolean" && drawing == false);
        if (drawing) {
            this.draw()
        }
    },
    remove: function() {
        if (this.parent) {
            this.parent.removeChild(this, true)
        }
        if (this.srcNode) {
            this.srcNode.removeRelationLine(this)
        }
        if (this.dstNode) {
            this.dstNode.removeRelationLine(this)
        }
        $.topology.removeElement(this);
        $.topology.graphEngine.remove("block_" + this.id);
        $.topology.updateVirtualLine()
    }
};

extend(hy.topology.model.Line, hy.topology.model.BaseLine);
// /hy.topology.model.Lineseter
hy.topology.model.Lineseter = function() {
    this.state = 1;
    this.parent = null;
    this.children = null;
    this.isExpand = false;
    this.isPermit = true;
    this.lineSpacing = 14;
    this.polySpacing = 28;
    hy.topology.model.BaseLine.call(this);
    this.init.apply(this, arguments)
};
hy.topology.model.Lineseter.prototype = {
    init: function() {
        var _data = arguments[0] || {};
        this.id = $.trim(_data.id) || $.topology.uuid();
        this.name = typeof _data.name == "string" ? _data.name : "";
        if ($.trim(_data.path)) {
            this.setPath($.trim(_data.path))
        }
        var type = String(_data.type);
        this.objectId = $.trim(_data.objectId) || "";
        if (_data.objectClass && $.trim(_data.objectClass) !== "" && $.trim(_data.objectClass) !== "-1") {
            this.objectClass = $.trim(_data.objectClass)
        }
        this.instanceId = _data.instanceId || "";
        this.children = {};
        this.style = {};
        if (_data.style) {
            if ($.isPlainObject(_data.style)) {
                this.style = _data.style
            } else {
                if ($.type(_data.style) === "string") {
                    var _styleArr = _data.style.split(";");
                    for (var i = 0, len = _styleArr.length; i < len; i++) {
                        var _style = _styleArr[i].split(":");
                        if ($.trim(_style[0]) !== "") {
                            this.style[_style[0]] = _style[1]
                        }
                    }
                }
            }
        }
        this.option = {};
        if (_data.options) {
            if ($.isPlainObject(_data.options)) {
                this.option = _data.options
            } else {
                if ($.type(_data.options) === "string") {
                    var _optionArr = _data.options.split(";");
                    for (var i = 0, len = _optionArr.length; i < len; i++) {
                        var _option = _optionArr[i].split(":");
                        if ($.trim(_option[0]) !== "") {
                            this.option[_option[0]] = _option[1]
                        }
                    }
                }
            }
        }
        this.isExpand = this.option["lineseter-expand"] && this.option["lineseter-expand"] === "0" ? false : true;
        this.isPermit = this.option["lineseter-permit"] && this.option["lineseter-permit"] === "0" ? false : true;
        if (_data.url) {
            if ($.isPlainObject(_data.url)) {
                this.url = _data.url
            } else {
                if ($.type(_data.url) === "string") {
                    this.url = {
                        name: [],
                        icon: [],
                        link: [],
                        open: []
                    };
                    var _urlArr = eval(_data.url);
                    for (var i = 0, len = _urlArr.length; i < len; i++) {
                        this.url.name.push(_urlArr[i].n);
                        this.url.icon.push(_urlArr[i].i);
                        this.url.link.push(_urlArr[i].l);
                        this.url.open.push(_urlArr[i].o)
                    }
                }
            }
        } else {
            this.url = null
        }
        this.alarm = {};
        if (_data.alarm) {
            if ($.isPlainObject(_data.alarm)) {
                this.alarm = _data.alarm
            } else {
                if ($.type(_data.alarm) === "string") {
                    var _alarmArr = _data.alarm.split(";");
                    for (var i = 0, len = _alarmArr.length; i < len; i++) {
                        var _alarm = _alarmArr[i].split(":");
                        if ($.trim(_alarm[0]) !== "") {
                            this.alarm[_alarm[0]] = _alarm[1]
                        }
                    }
                }
            }
        }
        var srcSymbol = $.trim(_data.srcSymbol);
        var dstSymbol = $.trim(_data.dstSymbol);
        this.setSrcNode(srcSymbol);
        this.setDstNode(dstSymbol);
        if (this.srcNode instanceof hy.topology.model.Container || this.dstNode instanceof hy.topology.model.Container) {
            this.state = 2
        } else {
            this.state = 1
        }
        var parentId = $.trim(_data.parentId);
        if (parentId) {
            this.parent = $.topology.shapes.lineseters[parentId] || null;
            if (this.parent) {
                this.parent.addChild(this)
            }
        }
    },
    setSrcNode: function(symbol) {
        if (this.srcNode) {
            this.srcNode.removeRelationLine(this);
            this.srcNode = null
        }
        if (typeof symbol !== "object") {
            symbol = $.topology.shapes.symbols[symbol] || $.topology.shapes.containers[symbol]
        }
        if (symbol) {
            this.srcNode = symbol;
            this.updateSrcPosition();
            this.srcNode.addRelationLine(this);
            this.refreshName()

        }
    },
    setDstNode: function(symbol) {
        if (this.dstNode) {
            this.dstNode.removeRelationLine(this);
            this.dstNode = null
        }
        if (typeof symbol !== "object") {
            symbol = $.topology.shapes.symbols[symbol] || $.topology.shapes.containers[symbol]
        }
        if (symbol) {
            this.dstNode = symbol;
            this.updateDstPosition();
            this.dstNode.addRelationLine(this);
            this.refreshName()
        }
    },
    getObjectClass: function() {
        return "lineseter"
    },
    show: function() {
        this.visible = true;
        $.topology.graphEngine.show("block_" + this.id);
        // if ($.topology.status === "SHOW") {
        $.topology.elementEventRender4IE9(this)
        // }
        $($.topology).triggerHandler("drawElement", this)
    },
    hide: function() {
        this.visible = false;
        $.topology.graphEngine.hide("block_" + this.id);
        $($.topology).triggerHandler("drawElement", this)
    },
    expand: function() { // liyang
        if (this.state == 1) {
            if (this.srcNode && !this.srcNode.visible) {
                return
            }
            if (this.dstNode && !this.dstNode.visible) {
                return
            }
            this.isExpand = true;
            this.hide();
            for (var id in this.children) {
                this.children[id].show()
            }
            this.renovate()
        }
    },
    collapse: function() {
        if (this.state == 1) {
            if (this.srcNode && !this.srcNode.visible) {
                return
            }
            if (this.dstNode && !this.dstNode.visible) {
                return
            }
            this.isExpand = false;
            this.show();
            for (var id in this.children) {
                this.children[id].hide()
            }
        }
    },
    addChild: function(line, drawing) { // liyang 添加多条链路
        if (line && (line instanceof hy.topology.model.Line || line instanceof hy.topology.model.Lineseter)) {
            this.children[line.id] = line;
            line.parent = this
        }
        if (drawing) {
            if (this.state == 1) {
                this.renovate();
                if ((this.srcNode && !this.srcNode.visible) || (this.dstNode && !this.dstNode.visible)) {
                    line.hide()
                } else {
                    line.show();
                    this.expand()
                }
            } else {
                line.draw()
            }
        }


    },
    removeChild: function(line, drawing) { // liyang 移除多条链路
        if (line && (line instanceof hy.topology.model.Line || line instanceof hy.topology.model.Lineseter)) {
            delete this.children[line.id];
            line.parent = null;
            line.change()
        }
        if (drawing && this.state === 1) {
            this.renovate()
        }
    },
    add: function() {
        $.topology.addElement(this);
        this.draw()
    },
    change: function(drawing) {
        this.refreshName();
        $.topology.changeElement(this);
        drawing = !(typeof drawing === "boolean" && drawing == false);
        if (drawing) {
            this.draw()
        }
    },
    remove: function(deep) {
        if (this.parent) {
            this.parent.removeChild(this, true)
        }
        if (this.srcNode) {
            this.srcNode.removeRelationLine(this)
        }
        if (this.dstNode) {
            this.dstNode.removeRelationLine(this)
        }
        for (var id in this.children) {
            if (deep) {
                this.children[id].remove()
            } else {
                var child = this.children[id];
                child.parent = null;
                child.updateNodePosition();
                child.show();
                child.change()
            }
        }
        $.topology.removeElement(this);
        $.topology.graphEngine.remove("block_" + this.id)
    },
    setPath: function(pathStr) {
        this.path = pathStr || "";
        if (pathStr) {
            this.points = $.topology.graphEngine.path(pathStr);
            if (this.points.length >= 2) {
                this.x1 = parseInt(this.points[0][0]);
                this.y1 = parseInt(this.points[0][1]);
                this.x2 = parseInt(this.points[this.points.length - 1][0]);
                this.y2 = parseInt(this.points[this.points.length - 1][1])
            }
        }
    },
    changePath: function() {
        $.topology.graphEngine.changeLineseterPath(this);
        $($.topology).triggerHandler("drawElement", this)
    },
    renovate: function() { // liyang 翻新路径
        if (this.state === 1) {
            var linesLength = $.objAttrLength(this.children);
            if (linesLength == 1) {
                var points = [
                    [this.x1, this.y1],
                    [this.x2, this.y2]
                ];
                for (var id in this.children) {
                    var child = this.children[id];
                    child.setPoints(points);
                    child.changePath();

                }
            } else {

                var r = Math.sqrt((this.y2 - this.y1) * (this.y2 - this.y1) + (this.x2 - this.x1) * (this.x2 - this.x1)),
                    sin = (this.y2 - this.y1) / r,
                    cos = (this.x2 - this.x1) / r,
                    isOdd = linesLength % 2 === 1 ? 1 : 2,
                    p = [];
                if ((r / 2) < this.polySpacing) {
                    this.polySpacing = r / 2
                }
                p[0] = this.x1 + this.polySpacing * cos;
                p[1] = this.y1 + this.polySpacing * sin;
                p[2] = this.x2 - this.polySpacing * cos;
                p[3] = this.y2 - this.polySpacing * sin;
                for (var id in this.children) {
                    var child = this.children[id],
                        points = [];
                    points[0] = [], points[1] = [], points[2] = [],
                        points[3] = [];
                    points[0][0] = this.x1;
                    points[0][1] = this.y1;
                    points[1][0] = parseInt(p[0] + this.lineSpacing * sin * (isOdd % 2 === 1 ? -1 : 1) * parseInt(isOdd / 2));
                    points[1][1] = parseInt(p[1] + this.lineSpacing * cos * (isOdd % 2 === 1 ? 1 : -1) * parseInt(isOdd / 2));
                    points[2][0] = parseInt(p[2] + this.lineSpacing * sin * (isOdd % 2 === 1 ? -1 : 1) * parseInt(isOdd / 2));
                    points[2][1] = parseInt(p[3] + this.lineSpacing * cos * (isOdd % 2 === 1 ? 1 : -1) * parseInt(isOdd / 2));
                    points[3][0] = this.x2;
                    points[3][1] = this.y2;

                    child.setPoints(points);
                    child.changePath();
                    isOdd++
                }
            }
        }
    }
};
extend(hy.topology.model.Lineseter, hy.topology.model.BaseLine);

// /hy.topology.engine
Package.p("hy.topology.engine");
// /hy.topology.engine.SVGEngine
hy.topology.engine.SVGEngine = function() {
    this.svg = null;
    this.canvas = null;
    this.event = null;
    this.defs = null;
    this.coverage = null;
    this.animation = null;
    this.shadow = {
        "top": {
            "offsetX": 0,
            "offsetY": -6
        },
        "left": {
            "offsetX": -6,
            "offsetY": 0
        },
        "bottom": {
            "offsetX": 0,
            "offsetY": 6
        },
        "right": {
            "offsetX": 6,
            "offsetY": 0
        },
        "top_left": {
            "offsetX": -4,
            "offsetY": -4
        },
        "bottom_left": {
            "offsetX": -4,
            "offsetY": 4
        },
        "bottom_right": {
            "offsetX": 4,
            "offsetY": 4
        },
        "top_right": {
            "offsetX": 4,
            "offsetY": -4
        }
    };
    this.highLighter = null;
    this.selector = null;
    this.coordsConvert = null;
    this.canvasGrid = null;
    this.support = this._support();

    this.options = {
        "view": {
            "text-display": "0",
            "font-family": "Microsoft YaHei",
            "font-size": "12px",
            "font-color": "#000000",
            "background-color": "",
            "background-opacity": "0"
        },
        "symbol_icon": {
            "opacity": "1"
        },
        "container": {
            "background-color": "#0000ff",
            "background-opacity": "0.3",
            "rounded": "4"
        },
        "node_text": {
            "text-align": "center",
            "text-valign": "bottom",
            "text-path": "h",
            "font-family": "Microsoft YaHei",
            "font-color": "#000000",
            "font-size": "12px",
            "font-weight": "normal",
            "font-style": "normal",
            "text-stroke": "0",
            "text-border": "0",
            "text-opacity": "1",
            "text-spacing": "5",
            "letter-spacing": "1px",
            "text-anchor": "middle",
            "text-decoration": "none",
            "text-line-spacing": "2",
            "text-line-height": "100%"
        },
        "line": {
            "color": "#000000",
            "weight": "2",
            "opacity": "1"
        }
    }
};





hy.topology.engine.SVGEngine.prototype = {
    init: function(dom, callback) {
        var graphEngine = this;
        $("#" + dom).svg({
            onLoad: function(_svg) {
                graphEngine.svg = _svg;
                graphEngine.defs = _svg.defs("topo_effect_defs");
                graphEngine._initDefFilters();
                graphEngine.coverage = new hy.topology.engine.SVGCoverage();
                graphEngine.animation = new hy.topology.engine.SVGAnimation();
                graphEngine.canvas = new hy.topology.engine.SVGCanvas($(this), _svg, "root");
                graphEngine.event = new hy.topology.engine.SVGEvent($(this), _svg);
                graphEngine.event.init();
                graphEngine.selector = new hy.topology.engine.SVGSelector();
                graphEngine.canvasGrid = new hy.topology.engine.SVGCanvasGrid();
                // if ($.topology.status == "EDIT") {
                graphEngine.bindLineRemoveToolToggleEvent()
                // }
                $(document).unbind("mousedown.jqctxClose").bind("mousedown.jqctxClose",
                    function(e) {
                        $.lab.menu.clearContextMenu(e)
                    });
                if ($.isFunction(callback)) {
                    callback.call()
                }
            }
        })
    },
    reset: function(callback) {
        var svg, $ge = $.topology.graphEngine;
        if (svg = $ge.svg) {
            $ge.svg.clear();
            $ge.defs = svg.defs("topo_effect_defs");
            $ge._initDefFilters();
            $ge.coverage = new hy.topology.engine.SVGCoverage();
            $ge.canvas.reset();
            $ge.animation = new hy.topology.engine.SVGAnimation();
            $ge.selector = new hy.topology.engine.SVGSelector();
            $ge.event.reset();
            if (callback && $.isFunction(callback)) {
                callback.call()
            }
        }
    },
    isDrew: function(id) {
        return !!this.svg.getElementById(id)
    },
    view: function(view) {
        var viewElement = this.svg.getElementById(view.id),
            block = this.coverage.getCoverageById("coverage_10");
        var isExits = !!viewElement;
        if (isExits) {
            this.svg.remove(viewElement)
        }
        if (view.style["background-image"]) {
            viewElement = this.svg.image(block, 0, 0, parseInt(view.style["width"]), parseInt(view.style["height"]), "images/background/" + view.style["background-image"],
                $.extend({}, {
                    "id": view.id,
                    "preserveAspectRatio": "none",
                    "opacity": view.style["background-opacity"] ? view.style["background-opacity"] : this.options.view["background-opacity"]
                }))
        } else {
            viewElement = this.svg.rect(block, 0, 0,
                parseInt(view.style["width"]),
                parseInt(view.style["height"]),
                $.extend({}, {
                    "id": view.id,
                    "fill": view.style["background-color"] ? view.style["background-color"] : this.options.view["background-color"],
                    "fill-opacity": view.style["background-opacity"] ? view.style["background-opacity"] : this.options.view["background-opacity"]
                }))
        }
        var canvas = this.canvas,
            svg = this.svg;
        if (!isExits) {
            this.coordsConvert = new hy.topology.engine.SVGCoordsConvert(view, canvas);
            if ($.topology.status == "SHOW") {
                var backgroundPosition = view.option.adapter && view.option.adapter == 1 ? "fill" : "auto";
                var nodePosition = (view.option.position && view.option.position == 1) ? "relative" : "absolute";
                if (backgroundPosition && backgroundPosition == "fill") {
                    if (nodePosition && nodePosition == "relative") {
                        function scaleView() {
                            var width = canvas.width(),
                                height = canvas.height();
                            var bbox = viewElement.getBBox();
                            if (bbox.width != 0 && bbox.height != 0) {
                                var scaleX = width / bbox.width,
                                    scaleY = height / bbox.height;

                                viewElement.setAttribute("transform", "scale(" + scaleX + " " + scaleY + ")");
                                svg.getElementById("view_main").setAttribute("transform", "scale(" + (scaleX * 5) + " " + scaleY + ")");
                                view.fillScaleX = scaleX;
                                view.fillScaleY = scaleY
                            }
                            canvas.updateCanvas()
                        }
                        $(canvas).on("canvasResize", scaleView);
                        this.svg.rect(this.svg.getElementById("background"), 0,
                            0, "100%", "100%", {
                                "id": "background_" + view.id,
                                "fill": "#ffffff",
                                "opacity": 0
                            })
                    } else {
                        var backgroundElement = viewElement.cloneNode(false);
                        backgroundElement.setAttribute("id", "background_" + view.id);
                        backgroundElement.setAttribute("width", "100%");
                        backgroundElement.setAttribute("height", "100%");
                        this.svg.getElementById("background").appendChild(backgroundElement);
                        viewElement.setAttribute("opacity", "0")
                    }
                } else {
                    this.svg.rect(this.svg.getElementById("background"), 0, 0,
                        "100%", "100%", {
                            "id": "background_" + view.id,
                            "fill": "#ffffff",
                            "opacity": 0
                        })
                }
            } else {
                this.svg.rect(this.svg.getElementById("background"), 0, 0,
                    "100%", "100%", {
                        "id": "background_" + view.id,
                        "fill": "#ffffff",
                        "opacity": 0
                    })
            }
            this.bindViewDragEvent(view.id);
            this.bindViewDragEvent("background_" + view.id);
            this.bindViewSelectEvent(view.id);
            this.bindViewSelectEvent("background_" + view.id);
            this.bindViewDrawRectSelectEvent(view.id);
            this.bindViewDrawRectSelectEvent("background_" + view.id);
            this.bindViewContextMenuEvent(view.id);
            this.bindViewContextMenuEvent("background_" + view.id);
            this.bindViewFullScreenEvent(view.id);
            this.bindViewFullScreenEvent("background_" + view.id)
        } else {
            canvas.init();
            if (this.canvasGrid.isShow()) {
                this.canvasGrid.reset()
            }
        }
    },
    symbol: function(symbol) {
        if (!symbol) {
            return
        }
        var symbolId = symbol.id,
            isIcon = symbol.style["icon"] && symbol.style["icon"] !== "" ? true : false;
        var blockId = "block_" + symbolId,
            iconId = symbolId;
        var block = this.svg.getElementById(blockId);
        if (!block) {
            block = this.svg.group(this.coverage.getCoverageById("coverage_" + (symbol.parent ? "63" : "50")), blockId);
            if (isIcon) {
                this._icon(symbol)
            }
            // if ($.topology.status == "EDIT") {
            this.bindNodeDragEvent(iconId)
            // }
            this.bindNodeSelectEvent(iconId);
            this.bindElementContextMenuEvent(iconId)
            this.bindElementDbclickEvent(iconId) // TODO 双击节点
        }
        if (!symbol.visible) {
            this.hide(block)
        } else {
            this.show(block);
            if (isIcon) {
                this._icon(symbol)
            }
            var labelBlock = this._label(symbol);
            if (labelBlock) {
                this.updateSymbolLabelPosition(symbol, labelBlock)
            }
            var _bbox = block.getBBox();
            symbol.setBBox(_bbox.x, _bbox.y, _bbox.width, _bbox.height)
        }
    },
    container: function(container) {
        if (!container) {
            return
        }
        var containerId = container.id,
            isExpand = container.isExpand,
            style = $
            .extend({}, container.style),
            opts4ctn = this.options.container;
        var collapseBlockId = "block_" + containerId,
            collapseId = containerId,
            expandBlockId = "block_container_" + containerId,
            expandId = "container_" + containerId;
        var collapseBlock = this.svg.getElementById(collapseBlockId),
            expandBlock = this.svg
            .getElementById(expandBlockId);
        if (!collapseBlock) {
            collapseBlock = this.svg.group(this.coverage
                .getCoverageById("coverage_50"), collapseBlockId);
            this._icon(container);
            // if ($.topology.status == "EDIT") {
            this.bindNodeDragEvent(collapseId)
            // }
            this.bindNodeSelectEvent(collapseId);
            this.bindElementContextMenuEvent(collapseId);
            this.bindContainerExpandEvent(collapseId)
        }
        if (!expandBlock) {
            expandBlock = this.svg.group(this.coverage.getCoverageById("coverage_60"), expandBlockId);
            // if ($.topology.status == "EDIT") {
            this.bindNodeDragEvent(expandId)
            // }
            this.bindNodeSelectEvent(expandId);
            this.bindElementContextMenuEvent(expandId);
            this.bindContainerCollapseEvent(expandId)
        }
        var icon, blockBBox, label;
        if (!isExpand) {
            this.hide(expandBlock);
            this.show(collapseBlock);
            this._icon(container);
            label = this._label(container);
            this.updateContainerCollapseLabelPosition(container, label);
            var expandToolElementId = "tool_expand_" + container.id;
            var expandToolElement = this.svg
                .getElementById(expandToolElementId);
            if (container.isPermit) {
                if (!expandToolElement) {
                    expandToolElement = this.svg.image(collapseBlock, 0, 0, 20,
                        20, "icon/plus2.svg", {
                            "id": expandToolElementId,
                            "preserveAspectRatio": "none",
                            "cursor": "pointer"
                        });
                    this.svg.title(expandToolElement, "展开");
                    this.event.add(expandToolElementId, "click", function(e) {
                        var c = $.topology.graphEngine.findModel(e.target.id);
                        if ($.topology.isContainer(c) && !c.isExpand) {
                            c.expand();
                            c.change();
                            var selector = $.topology.selector;
                            if (selector.contains(c.id)) {
                                selector.refresh()
                            }
                        }
                    })
                }
                this.updateContainerCollapseExpandToolPosition(container, expandToolElement)
            } else {
                expandToolElement && this.remove(expandToolElementId)
            }
            blockBBox = collapseBlock.getBBox();
            container.setCollapseBBox(blockBBox)
        } else {
            this.hide(collapseBlock);
            this.show(expandBlock);
            var isBackgroundImage = style["background-image"] ? true : false;
            icon = this.svg.getElementById(expandId);
            if (icon) {
                this.svg.remove(icon);
                icon = null
            }
            if (isBackgroundImage) {
                icon = this.svg.image(expandBlock, container.expandX, container.expandY,
                    container.expandWidth, container.expandHeight,
                    "images/container/" + style["background-image"], {
                        "id": "container_" + container.id,
                        "preserveAspectRatio": "none",
                        "opacity": style["background-opacity"] ? style["background-opacity"] : opts4ctn["background-opacity"]
                    })
            } else {
                icon = this.svg.rect(expandBlock, container.expandX, container.expandY, container.expandWidth, container.expandHeight,
                    opts4ctn["rounded"], opts4ctn["rounded"], $.extend({}, {
                            "id": "container_" + container.id,
                            "fill": style["background-color"] ? style["background-color"] : opts4ctn["background-color"],
                            "fill-opacity": style["background-opacity"] ? style["background-opacity"] : opts4ctn["background-opacity"]
                        },
                        (style["border"] ? {
                            "stroke-width": style["border"],
                            "stroke": style["border-color"]
                        } : {})))
            }
            label = this._label({
                "id": "container_" + container.id,
                "name": container.name,
                "x": container.expandX,
                "y": container.expandY,
                "style": $.extend({}, style, {
                    "icon": "container_expand",
                    "icon-width": container.expandWidth,
                    "icon-height": container.expandHeight
                })
            });
            this.updateContainerExpandLabelPosition(container, label);
            blockBBox = expandBlock.getBBox();
            container.setExpandBBox(blockBBox)
        }
    },
    line: function(line) { // 引擎线

        var $ge = this,
            $svg = $ge.svg,
            $event = $ge.event,
            _f_gebi = $svg.getElementById,
            _f_group = $svg.group,
            _f_change = $svg.change;
        var lineId = line.id,
            blockId = "block_" + lineId,
            selfBlockId = "block_l_" + lineId,
            borderBlockId = "block_border_" + lineId,
            headBlockId = "block_linehead_" + lineId,
            wrapBlockId = "block_wrap_" + lineId,
            verticesBlockId = "block_vertices_" + lineId,
            toolsBlockId = "block_tools_" + lineId;
        var style = line.style,
            opts4line = this.options.line,
            isModify = this.isDrew(blockId),
            isLineseter = line instanceof hy.topology.model.Lineseter ? true : false,
            isRelNodeInCtn = false,
            block = null,
            selfBlock = null,
            headBlock = null,
            borderBlock = null,
            wrapBlock = null;
        if ((line.srcNode && line.srcNode.parent) || (line.dstNode && line.dstNode.parent)) {
            isRelNodeInCtn = true
        }
        if (!isModify) {
            block = !isLineseter ? _f_group.call($svg, this.coverage.getCoverageById("coverage_" + (!isRelNodeInCtn ? "40" : "61")), blockId) : _f_group.call($svg, this.coverage.getCoverageById("coverage_" + (!isRelNodeInCtn ? "41" : "62")), blockId);
            borderBlock = _f_group.call($svg, block, borderBlockId);
            headBlock = _f_group.call($svg, block, headBlockId);
            selfBlock = _f_group.call($svg, block, selfBlockId);
            wrapBlock = _f_group.call($svg, block, wrapBlockId);
            _f_group.call($svg, block, verticesBlockId);
            _f_group.call($svg, block, toolsBlockId)
        } else {
            block = _f_gebi.call($svg, blockId);
            selfBlock = _f_gebi.call($svg, selfBlockId);
            headBlock = _f_gebi.call($svg, headBlockId);
            borderBlock = _f_gebi.call($svg, borderBlockId);
            wrapBlock = _f_gebi.call($svg, wrapBlockId)
        }
        _f_change(block, {
            "display": line.visible ? "block" : "none"
        });
        var opts = $.extend({
            "fill": "none",
            "stroke": style["color"] ? style["color"] : opts4line["color"],
            "stroke-width": style["weight"] ? style["weight"] : opts4line["weight"],
            "stroke-opacity": style["opacity"] ? style["opacity"] : opts4line["opacity"]
        }, (style["dashed"] ? {
            "stroke-dasharray": style["dashed"]
        } : {}), (!line.srcNode || !line.dstNode ? {
            "stroke-linecap": "round"
        } : {}));
        var wrapOpts = {
            "fill": "none",
            "stroke": style["color"] ? style["color"] : opts4line["color"],
            "stroke-width": Number(style["weight"] ? style["weight"] : opts4line["weight"]) + 14,
            "stroke-linecap": "round",
            "stroke-linejoin": "round"
        };
        var _line = null,
            wrapId = "wrap_" + lineId,
            lineWrap = null;
        if (isModify) {
            _line = _f_gebi.call($svg, lineId);
            _f_change(_line, $.extend({}, opts, {
                "d": line.path
            }));
            lineWrap = _f_gebi.call($svg, wrapId);
            _f_change(lineWrap, $.extend({}, wrapOpts, {
                "d": line.path
            }))
        } else {

            _line = $svg.path(selfBlock, line.path, $.extend({}, opts, {
                "id": line.id
            }));
            lineWrap = $svg.path(wrapBlock, line.path, $.extend({}, wrapOpts, {
                "id": wrapId,
                "opacity": "0"
            }));
            this.bindElementContextMenuEvent(wrapId);
            this.bindLineSelectEvent(wrapId);
            this.bindLineCollapseToggleEvent(wrapId);
            // if ($.topology.status == "SHOW") {
            bindTopoShowLineHoverEvent(wrapId)
            // } else {
            bindTopoEditLineHoverEvent(wrapId);
            bindDrawVertexEvent(wrapId) // 绑定拖动添加顶点
            // }
            this.bindElementDbclickEvent(wrapId) // TODO 双击连线
        }
        // if ($.topology.status == "EDIT") {
        renderVertices(line)
        // }
        var srcCx = line.x1,
            srcCy = line.y1,
            dstCx = line.x2,
            dstCy = line.y2,
            r = parseInt(opts["stroke-width"]) + 1,
            headStyle = {
                "fill": opts["stroke"],
                "fill-opacity": opts["stroke-opacity"],
                "stroke": style["border-color"] ? style["border-color"] : opts["stroke"],
                "stroke-width": style["border"] ? style["border"] : "0",
                "stroke-opacity": opts["stroke-opacity"]
            };
        if (isModify) {
            var srcHead = _f_gebi.call($svg, "linehead_s_" + line.id),
                dstHead = _f_gebi.call($svg, "linehead_d_" + line.id);
            if (srcHead) {
                _f_change(srcHead, $.extend({
                    "cx": srcCx,
                    "cy": srcCy,
                    "r": r
                }, headStyle))
            }
            if (dstHead) {
                _f_change(dstHead, $.extend({
                    "cx": dstCx,
                    "cy": dstCy,
                    "r": r
                }, headStyle))
            }
        } else {
            $svg.circle(headBlock, srcCx, srcCy, r, $.extend(headStyle, {
                "id": "linehead_s_" + line.id
            }));
            $svg.circle(headBlock, srcCx, srcCy, r, $.extend(headStyle, {
                "id": "linehead_d_" + line.id
            }))
        }
        var _weight = style["border"] && style["border"] !== "0" ? (parseInt(opts["stroke-width"]) + parseInt(style["border"]) * 2) : parseInt(opts["stroke-width"]);
        var _border = _f_gebi.call($svg, "border_" + line.id);
        if (isModify && _border) {
            _f_change(_border, $.extend({}, opts, {
                "d": line.path,
                "stroke": style["border-color"] ? style["border-color"] : opts["stroke"],
                "stroke-width": _weight
            }))
        } else {

            $svg.path(borderBlock, line.path, $.extend({}, opts, {
                "id": "border_" + line.id,
                "stroke": style["border-color"] ? style["border-color"] : opts["stroke"],
                "stroke-width": _weight
            }))
        }
        if (style["shadow"] && style["shadow"] !== "" && style["shadow"] !== "null") {
            _f_change(block, {
                "filter": "url(#shadow_" + style["shadow"].toLowerCase() + ")"
            })
        } else {
            var hasAlarmFilter = /alarm_/gi;
            if (block && block.getAttribute("filter") && !hasAlarmFilter.test(block.getAttribute("filter"))) {
                block.removeAttribute("filter")
            }
        }
        updateLineToolsPosition(lineId);

        function updateLineToolsPosition(lineId) {
            $ge.updateLineToolsPosition($ge.findModel(lineId))
        }

        function bindTopoShowLineHoverEvent(elementId) {
            $event.add(elementId, "mouseover", function(e) {
                var target = e.target,
                    line = $ge.findModel(target.id),
                    lineId = line.id;
                $ge.showLineWrap(lineId);
                for(var i = 0;i<viewContent.lines.length;i++){
                    if(viewContent.lines[i].id == lineId){
                        var pp = viewContent.lines[i].instanceName;
                        if(pp.indexOf("--") > 0){
                            $(".layertips").show();
                            $(".layertips2").show();
                            $(".layertips").text(pp.substring(pp.indexOf(":")+1,pp.indexOf("--")));
                            $(".layertips2").text(pp.substring(pp.lastIndexOf(":")+1));
                            for(var j = 0;j<viewContent.symbols.length;j++){
                                if(viewContent.symbols[j].instanceId == pp.substring(0,pp.indexOf(":"))){
                                    var topp = viewContent.symbols[j].id;
                                    var el=document.querySelector("#block_"+topp);
                                    var ellabel = document.querySelector("#label_"+topp).getBoundingClientRect().height
                                    var elheight = el.getBoundingClientRect().height - ellabel;
                                    var leftl = ($(".layertips").width() - 24)/2+10;
                                    $('.layertips').append("<style>.layertips::before{left:"+leftl+"}</style>");
                                    $(".layertips").css({top:$("#"+topp).offset().top+elheight,left:$("#"+topp).offset().left-leftl-5})
                                }
                                if(viewContent.symbols[j].instanceId == pp.substring(pp.lastIndexOf(":"),pp.lastIndexOf("--")+2)){
                                    var topp = viewContent.symbols[j].id;
                                    var el=document.querySelector("#block_"+topp);
                                    var ellabel = document.querySelector("#label_"+topp).getBoundingClientRect().height
                                    var elheight = el.getBoundingClientRect().height - ellabel;
                                    var leftl = ($(".layertips2").width() - 24)/2+10;
                                    $('.layertips2').append("<style>.layertips2::before{left:"+leftl+"}</style>");
                                    $(".layertips2").css({top:$("#"+topp).offset().top+elheight,left:$("#"+topp).offset().left-leftl-5})
                                }
                            }
                        }
                    }
                }
            });
            $event.add(elementId, "mouseout", function(e) {
                var target = e.target,
                    line = $ge.findModel(target.id),
                    lineId = line.id;
                $ge.hideLineWrap(lineId);
                $(".layertips").hide();
                $(".layertips2").hide();
            })
        }

        function bindTopoEditLineHoverEvent(elementId) {

            $event.add(elementId, "mouseover", function(e) {
                var target = e.target,
                    line = $ge.findModel(target.id),
                    lineId = line.id;
                $ge.showLineWrap(lineId);
                showLineVertices(lineId)
            });
            $event.add(elementId, "mouseout", function(e) {
                var target = e.target,
                    line = $ge.findModel(target.id),
                    lineId = line.id;
                $ge.hideLineWrap(lineId);
                hideLineVertices(lineId)
            })
        }

        function bindDrawVertexEvent(elementId) { // 绑定拖动添加顶点
            $event.add(elementId, "dragstart", dragstart);

            function dragstart(e) {
                if (e.button != 0) {
                    return
                }
                var target = e.target,
                    line = $ge.findModel(target.id);
                if (!line) {
                    return
                }
                if ($.topology.isLine(line) && line.parent && line.parent.state == 1) {
                    return
                }
                var idx = null,
                    moved = 0;
                $event.add(target.id, "drag", drag);
                $event.add(target.id, "dragend", dragend);

                function drag(e) {
                    moved |= e.dx | e.dy;
                    if (idx == null && moved) {
                        var point = $ge.canvas.coordinateConvert.page2Canvas(e.pageX, e.pageY);
                        idx = addVertex(line, point) // 添加顶点
                    }
                    if (idx != null) {
                        dragVertex(e, line, idx) // 拖动顶点
                    }

                }

                function dragend(e) {
                    $event.remove(target.id, "drag", drag);
                    $event.remove(target.id, "dragend", dragend);
                    if (moved) {
                        line.change()
                    }
                }
            }
        }

        function getVertices(line) {
            var points = line.points || [],
                vertices = null,
                verticesCount = points.length - 2;
            if (verticesCount > 0) {
                vertices = points.slice();
                vertices.shift();
                vertices.pop()
            } else {
                vertices = []
            }
            return vertices
        }

        function addVertex(line, vertex) { // 添加顶点
            var lineId = line.id;
            vertex = [vertex.x, vertex.y];
            var vertices = getVertices(line),
                originalVertices = vertices
                .slice(),
                path = _f_gebi.call($svg, lineId)
                .cloneNode(false),
                originalPathLength = $ge
                .getPathTotalLength(path),
                pathLength, pathLengthTolerance = 10,
                idx = vertices.length + 1;
            while (idx--) {
                vertices.splice(idx, 0, vertex);
                path.setAttribute("d", getPathData(line, vertices));
                pathLength = $ge.getPathTotalLength(path);
                if (pathLength - originalPathLength > pathLengthTolerance) {
                    vertices = originalVertices.slice()
                } else {
                    break
                }
            }
            if (idx < 0) {
                return null
            }
            line.addPoint(idx, vertex[0], vertex[1]);
            line.changePath();
            line.change();
            return idx
        }

        function getPathData(line, vertices) {
            var points = line.points,
                newVertices = vertices.slice();
            newVertices.unshift(points[0]);
            newVertices.push(points[points.length - 1]);
            return $ge.path(newVertices)
        }

        function removeVertex(line, idx) {
            line.removePoint(idx + 1);
            line.changePath();
            line.change()
        }

        function dragVertex(e, line, idx) { // 拖动顶点
            var viewBox = $.topology.view.getViewBox(),
                mousePoint = $ge.canvas.coordinateConvert
                .page2Canvas(e.pageX, e.pageY),
                vertex = mousePoint;
            var mouseBBox = {
                minX: viewBox.x,
                minY: viewBox.y,
                maxX: viewBox.x + viewBox.width,
                maxY: viewBox.y + viewBox.height
            };
            var mouseOffset = $ge.edgeDetect([mousePoint.x, mousePoint.y,
                mousePoint.x, mousePoint.y
            ], [mouseBBox.minX,
                mouseBBox.minY, mouseBBox.maxX, mouseBBox.maxY
            ]);
            if (mouseOffset.x > 0) {
                vertex.x = viewBox.x
            } else {
                if (mouseOffset.x < 0) {
                    vertex.x = viewBox.x + viewBox.width
                }
            }
            if (mouseOffset.y > 0) {
                vertex.y = viewBox.y
            } else {
                if (mouseOffset.y < 0) {
                    vertex.y = viewBox.y + viewBox.height
                }
            }
            setVertex(line, idx, vertex)
        }

        function setVertex(line, idx, vertex) { // 设置顶点
            var lineId = line.id;
            line.setPoint(idx + 1, vertex.x, vertex.y);
            line.changePath();
            applyVertexTransform(lineId, idx, vertex.x, vertex.y);

            function applyVertexTransform(lineId, idx, x, y) {
                var vertexGroupId = "vertex_group_" + lineId + "_" + idx;
                var vertexGroup = _f_gebi.call($svg, vertexGroupId);
                _f_change(vertexGroup, {
                    "transform": "translate(" + x + " " + y + ")"
                })
            }
        }

        function renderVertices(line) {
            var lineId = line.id,
                verticesBlockId = "block_vertices_" + lineId,
                verticesBlock = _f_gebi.call($svg, verticesBlockId);
            if (!verticesBlock) {
                return
            }
            var vertexPre = "vertex_",
                vertexRemoveAreaPre = "vertex_remove_area_",
                vertexRemovePre = "vertex_remove_";
            while (verticesBlock.firstChild) {
                $ge.remove(verticesBlock.firstChild)
            }
            _f_change(verticesBlock, {
                opacity: "0"
            });
            if ($.topology.isLine(line) && line.parent && line.parent.state == 1) {
                return
            }
            var vertices = getVertices(line),
                verticesCount = vertices.length;
            if (verticesCount > 0) {
                var _f_circle = $svg.circle,
                    _f_path = $svg.path,
                    _f_addEvent = $event.add,
                    point = null,
                    vertexGroupId = null,
                    vertexGroup = null,
                    vertexId = null,
                    vertexRemoveAreaId = null,
                    vertexRemoveId = null,
                    vertexRemove = null,
                    vertexRemoveAreaPath = "M16,5.333c-7.732,0-14,4.701-14,10.5c0,1.982,0.741,3.833,2.016,5.414L2,25.667l5.613-1.441c2.339,1.317,5.237,2.107,8.387,2.107c7.732,0,14-4.701,14-10.5C30,10.034,23.732,5.333,16,5.333z",
                    vertexRemovePath = "M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z";
                for (var i = 0; i < verticesCount; i++) {
                    point = {
                        x: vertices[i][0],
                        y: vertices[i][1]
                    };
                    vertexGroupId = "vertex_group_" + lineId + "_" + i;
                    vertexId = vertexPre + lineId + "_" + i;
                    vertexRemoveAreaId = vertexRemoveAreaPre + lineId + "_" + i;
                    vertexRemoveId = vertexRemovePre + lineId + "_" + i;
                    vertexGroup = _f_group.call($svg, verticesBlock,
                        vertexGroupId);
                    _f_change(vertexGroup, {
                        "transform": "translate(" + point.x + " " + point.y + ")"
                    });
                    _f_circle.call($svg, vertexGroup, 0, 0, 10, {
                        id: vertexId,
                        idx: i,
                        fill: "#1ABC9C",
                        cursor: "move"
                    });
                    _f_addEvent(vertexId, "mouseover", handleVertexMouseoverEvent);
                    _f_addEvent(vertexId, "mouseout", handleVertexMouseoutEvent);
                    _f_addEvent(vertexId, "dragstart", handleVertexDragstartEvent);
                    _f_path.call($svg, vertexGroup, vertexRemoveAreaPath, {
                        id: vertexRemoveAreaId,
                        idx: i,
                        opacity: ".2",
                        cursor: "pointer",
                        transform: "translate(5, -33)"
                    });
                    vertexRemove = _f_path.call($svg, vertexGroup,
                        vertexRemovePath, {
                            id: vertexRemoveId,
                            idx: i,
                            fill: "white",
                            opacity: "0",
                            cursor: "pointer",
                            transform: "scale(.8) translate(9.5, -37)"
                        });
                    $svg.title(vertexRemove, "删除折点");
                    _f_addEvent([vertexRemoveId, vertexRemoveAreaId], "click", handleRemoveClickEvent);
                    _f_addEvent([vertexRemoveId, vertexRemoveAreaId], "mouseover", handleRemoveMouseoverEvent);
                    _f_addEvent([vertexRemoveId, vertexRemoveAreaId], "mouseout", handleRemoveMouseoutEvent);
                }
            }

            function handleVertexDragstartEvent(e) {
                if (e.button != 0) {
                    return
                }
                var target = e.target,
                    targetId = target.id,
                    line = $ge
                    .findModel(targetId);
                if (!line) {
                    return
                }
                var moved = 0;
                $.topology.selector.select(line.id);
                var idx = target.getAttribute("idx");
                idx = parseInt(idx);
                $event.add(targetId, "drag", drag);
                $event.add(targetId, "dragend", dragend);

                function drag(e) {
                    moved |= e.dx | e.dy;
                    dragVertex(e, line, idx)
                }

                function dragend(e) {
                    $event.remove(targetId, "drag", drag);
                    $event.remove(targetId, "dragend", dragend);
                    if (moved) {
                        line.change()
                    }
                }
            }

            function handleVertexMouseoverEvent(e) {
                var target = e.target,
                    line = $ge.findModel(target.id),
                    lineId = line.id;
                var vertexId = target.getAttribute("idx");
                showLineVertices(lineId);
                _f_change(target, {
                    fill: "#34495E"
                });
                _f_change(_f_gebi.call($svg, "vertex_remove_area_" + lineId + "_" + vertexId), {
                    opacity: "1"
                });
                _f_change(_f_gebi.call($svg, "vertex_remove_" + lineId + "_" + vertexId), {
                    opacity: "1"
                })
            }

            function handleVertexMouseoutEvent(e) {
                var target = e.target,
                    line = $ge.findModel(target.id),
                    lineId = line.id;
                var vertexId = target.getAttribute("idx");
                hideLineVertices(lineId);
                _f_change(target, {
                    fill: "#1ABC9C"
                });
                _f_change(_f_gebi.call($svg, "vertex_remove_area_" + lineId + "_" + vertexId), {
                    opacity: ".2"
                });
                _f_change(_f_gebi.call($svg, "vertex_remove_" + lineId + "_" + vertexId), {
                    opacity: "0"
                })
            }

            function handleRemoveClickEvent(e) {
                var target = e.target,
                    line = $ge.findModel(target.id);
                if (!line) {
                    return
                }
                var vertexId = target.getAttribute("idx");
                vertexId = parseInt(vertexId);
                removeVertex(line, vertexId)
            }

            function handleRemoveMouseoverEvent(e) {
                var target = e.target,
                    line = $ge.findModel(target.id),
                    lineId = line.id;
                var vertexId = target.getAttribute("idx");
                vertexId = parseInt(vertexId);
                showLineVertices(lineId);
                _f_change(_f_gebi.call($svg, "vertex_remove_area_" + lineId + "_" + vertexId), {
                    opacity: "1"
                });
                _f_change(_f_gebi.call($svg, "vertex_remove_" + lineId + "_" + vertexId), {
                    opacity: "1"
                })
            }

            function handleRemoveMouseoutEvent(e) {
                var target = e.target,
                    line = $ge.findModel(target.id),
                    lineId = line.id;
                var vertexId = target.getAttribute("idx");
                vertexId = parseInt(vertexId);
                hideLineVertices(lineId);
                _f_change(_f_gebi.call($svg, "vertex_remove_area_" + lineId + "_" + vertexId), {
                    opacity: ".2"
                });
                _f_change(_f_gebi.call($svg, "vertex_remove_" + lineId + "_" + vertexId), {
                    opacity: "0"
                })
            }
        }

        function showLineVertices(lineId) {
            var verticesBlockId = "block_vertices_" + lineId,
                verticesBlock = _f_gebi.call($svg, verticesBlockId);
            if (!verticesBlock) {
                return
            }
            _f_change(verticesBlock, {
                opacity: "1"
            })
        }

        function hideLineVertices(lineId) {
            var verticesBlockId = "block_vertices_" + lineId,
                verticesBlock = _f_gebi.call($svg, verticesBlockId);
            if (!verticesBlock) {
                return
            }
            _f_change(verticesBlock, {
                opacity: "0"
            })
        }
    },
    lineseter: function(lineseter) {
        this.line(lineseter);
        var lineseterId = lineseter.id,
            $svg = this.svg,
            _f_gebi = $svg.getElementById;
        if (lineseter.state === 1) {
            var expandToolBlockId = "block_tool_expand_" + lineseterId,
                expandToolBlock = _f_gebi
                .call($svg, expandToolBlockId),
                expandToolElementId = "tool_expand_" + lineseterId,
                expandToolElement = _f_gebi.call($svg,
                    expandToolElementId);
            if (!expandToolBlock) {
                var toolsBlock = _f_gebi.call($svg, "block_tools_" + lineseterId);
                expandToolBlock = $svg.group(toolsBlock, expandToolBlockId)
            }
            if (!expandToolElement) {
                expandToolElement = $svg.image(expandToolBlock, 0, 0, 20, 20,
                    ctxImg + "/topology/icon_svg/plus.svg", {
                        "id": expandToolElementId,
                        "preserveAspectRatio": "none",
                        "cursor": "pointer",
                        "transform": "scale(.8)"
                    });
                $svg.title(expandToolBlock, "展开");
                this.event.add(expandToolElementId, "click", function(e) {
                    var line = $.topology.graphEngine.findModel(e.target.id);
                    if ($.topology.isLineseter(line)) {
                        line.expand();
                        line.change();
                        var selector = $.topology.selector;
                        if (selector.contains(line.id)) {
                            selector.reset()
                        }
                    }
                })
            }
        }
        this.updateLineToolsPosition(lineseter);
        $svg.change(_f_gebi.call($svg, "block_" + lineseter.id), {
            "display": lineseter.visible ? "block" : "none"
        })
    },
    getLineWrapElement: function(id) {
        return this.svg.getElementById("wrap_" + id)
    },
    getPointAtLength: function(path, length) {
        if (typeof path === "string") {
            path = this.svg.getElementById(path)
        }
        return path.getPointAtLength(length)
    },
    getPathTotalLength: function(path) {
        if (typeof path === "string") {
            path = this.svg.getElementById(path)
        }
        if (!path) {
            return 0
        }
        return path.getTotalLength() || function(graphEngine, path) {
            var points = graphEngine.path(path.getAttribute("d")),
                count = points.length;
            var length = 0,
                x1, y1, x2, y2;
            while (--count > 0) {
                x1 = points[count][0];
                y1 = points[count][1];
                x2 = points[count - 1][0];
                y2 = points[count - 1][1];
                length += lineSpace(x1, y1, x2, y2)
            }
            return length;

            function lineSpace(x1, y1, x2, y2) {
                return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2))
            }
        }(this, path)
    },
    getBBox: function(id) {
        var bbox = null;
        if (id) {
            var block = this.svg.getElementById("block_" + id);
            if (block) {
                bbox = block.getBBox()
            }
        }
        return bbox
    },
    updateNodeIconPosition: function(iconElement, x, y) {
        this.svg.change(iconElement, {
            "x": x,
            "y": y
        })
    },
    updateSymbolLabelPosition: function(symbol, labelElement) {
        if (!symbol.visible) {
            return
        }
        if (!labelElement) {
            labelElement = this.svg.getElementById("label_" + symbol.id)
        }
        if (labelElement) {
            var nodeIconBBox = symbol.getIconBBox();
            var style = symbol.style,
                opts4nodeText = this.options.node_text;
            var options = {
                "text-spacing": parseInt(opts4nodeText["text-spacing"]),
                "text-align": style["text-align"] ? style["text-align"] : opts4nodeText["text-align"],
                "text-valign": style["text-valign"] ? style["text-valign"] : opts4nodeText["text-valign"]
            };
            this.updateNodeLabelPosition(labelElement, nodeIconBBox, options)
        }
    },
    updateNodeLabelPosition: function(labelElement, nodeIconBBox, options) {
        if (!labelElement) {
            return
        }
        var iconBBox = $.extend({}, nodeIconBBox),
            labelBBox = $.extend({}, labelElement.getBBox());
        var spacing = parseInt(options["text-spacing"]),
            alignH = options["text-align"],
            alignV = options["text-valign"];
        var transX = 0,
            transY = 0;
        labelBBox.minX = labelBBox.x;
        labelBBox.minY = labelBBox.y;
        labelBBox.maxX = labelBBox.x + labelBBox.width;
        labelBBox.maxY = labelBBox.y + labelBBox.height;
        var x = labelBBox.minX,
            y = labelBBox.minY;
        switch (alignH) {
            case "left":
                x = iconBBox.minX - spacing - labelBBox.width;
                break;
            case "center":
                x = iconBBox.minX + iconBBox.width / 2 - labelBBox.width / 2;
                break;
            case "right":
                x = iconBBox.maxX + spacing;
                break;
            default:
                break
        }
        switch (alignV) {
            case "top":
                y = iconBBox.minY - spacing - labelBBox.height;
                break;
            case "middle":
                y = iconBBox.minY + iconBBox.height / 2 - labelBBox.height / 2;
                break;
            case "bottom":
                y = iconBBox.maxY + spacing;
                break;
            default:
                break
        }
        transX = x - labelBBox.minX;
        transY = y - labelBBox.minY;
        this.svg.change(labelElement, {
            "transform": "translate(" + transX + " " + transY + ")"
        })
    },
    updateLineToolsPosition: function(line) {
        if (!line) {
            return
        }
        var svg = this.svg,
            lineId = line.id,
            lineElement = svg
            .getElementById(lineId);
        if (!lineElement) {
            return
        }
        var shortLineLength = 100;
        var lineLength = this.getPathTotalLength(lineElement);
        var scale = "";
        var removeOffset = 35;
        var expandOffset = lineLength / 2;
        var scaleVal = null;
        if (lineLength < shortLineLength) {
            scaleVal = lineLength / shortLineLength;
            scaleVal = scaleVal.toFixed(2);
            if (!scaleVal || scaleVal < 0.5) {
                scaleVal = 0.5
            }
            scale = "scale(" + scaleVal + ")";
            removeOffset = 40 * scaleVal
        }
        var expandToolElement = svg.getElementById("block_tool_expand_" + lineId);
        if (expandToolElement) {
            var expandToolPosition = lineElement.getPointAtLength(expandOffset);
            expandToolPosition.x -= 8 * (scaleVal ? scaleVal : 1);
            expandToolPosition.y -= 8 * (scaleVal ? scaleVal : 1);
            expandToolElement.setAttribute("transform", "translate(" + expandToolPosition.x + " " + expandToolPosition.y + ") " + scale)
        }
        // if ($.topology.status == "EDIT") {
        var removeToolElement = svg.getElementById("block_tool_remove_" + lineId);
        if (removeToolElement) {
            var removeTtoolPosition = lineElement
                .getPointAtLength(removeOffset);
            removeToolElement.setAttribute("transform", "translate(" + removeTtoolPosition.x + " " + removeTtoolPosition.y + ") " + scale)
        }
        // }
    },
    findModel: function(id) {
        id = this._id(id);
        return $.topology.find(id)
    },
    findBlock: function(id) {
        if (id.search && id.search(/container_/) !== -1) {
            return this.svg.getElementById("block_container_" + this._id(id))
        } else {
            return this.svg.getElementById("block_" + this._id(id))
        }
    },
    remove: function(id) {
        var event = this.event,
            svg = this.svg;
        var element = typeof id === "string" ? svg.getElementById(id) : id;
        if (!element) {
            return
        }
        removeEvents(element.cloneNode(true));
        this.svg.remove(element);

        function removeEvents(ele) {
            if (typeof ele === "object" && "getAttribute" in ele) {
                var eid = ele.getAttribute("id");
                if (eid) {
                    event.remove(eid)
                }
                var childNodes = ele.childNodes,
                    childNodesLength = 0;
                if (childNodes) {
                    childNodesLength = childNodes.length
                }
                for (var i = 0; i < childNodesLength; i++) {
                    var childNode;
                    childNode = childNodes.item(i);
                    removeEvents(childNode)
                }
            }
        }
    },
    show: function(id) {
        var elem = typeof id === "string" ? this.svg.getElementById(id) : id;
        if (elem) {
            this.svg.change(elem, {
                "display": "block"
            })
        }
    },
    hide: function(id) {
        var elem = typeof id === "string" ? this.svg.getElementById(id) : id;
        if (elem) {
            this.svg.change(elem, {
                "display": "none"
            })
        }
    },
    path: function() { // liyang path 拼路径字符串 可以加一个 曲线path 方法
        if ($.isArray(arguments[0])) {
            if (arguments[0].length === 0) {
                return ""
            }
            var path = [],
                points = arguments[0];
            for (var i = 0, len = points.length; i < len; i++) {
                if (i === 0) {
                    path.push("M", parseInt(points[0][0], 10), parseInt(
                        points[0][1], 10))
                } else {
                    path.push("L", parseInt(points[i][0], 10), parseInt(
                        points[i][1], 10))
                }
            }
            return path.join(" ")
        } else {
            var pathStr = $.trim(arguments[0]).toUpperCase();
            if (pathStr === "") {
                return []
            }
            var p = pathStr.split(" "),
                len = p.length,
                points = [];
            if (len % 3 == 0) {
                for (var i = 0; i < len / 3; i++) {
                    points[i] = [Number(p[i * 3 + 1]), Number(p[i * 3 + 2])]
                }

            }
            return points
        }
    },
    path2: function() { // 根据点改变路径
        if ($.isArray(arguments[0])) {
            if (arguments[0].length === 0) {
                return ""
            }
            var path = [],
                points = arguments[0];
            for (var i = 0, len = points.length; i < len; i++) {
                if (i === 0) {
                    path.push("M", parseInt(points[0][0], 10), parseInt(
                        points[0][1], 10))
                } else {
                    if (i === 1) {
                        path.push("C", parseInt(points[i][0], 10), parseInt(
                            points[i][1], 10))
                    } else {
                        path.push("", parseInt(points[i][0], 10), parseInt(
                            points[i][1], 10))
                    }

                }
            }
            return path.join(" ")
        } else {
            var pathStr = $.trim(arguments[0]).toUpperCase();
            if (pathStr === "") {
                return []
            }
            var p = pathStr.split(" "),
                len = p.length,
                points = [];
            if (len % 3 == 0) {
                for (var i = 0; i < len / 3; i++) {
                    points[i] = [Number(p[i * 3 + 1]), Number(p[i * 3 + 2])]
                }
            }
            return points
        }
    },
    changeId: function(tmpId, element) {
        var id = element.id,
            $svg = this.svg,
            $event = this.event;
        var block = $svg.getElementById("block_" + tmpId);
        replaceId(block, tmpId, id);
        if ($.topology.isContainer(element)) {
            block = $svg.getElementById("block_container_" + tmpId);
            replaceId(block, tmpId, id)
        }

        function replaceId(ele, tmpId, newId) {
            if (typeof ele === "object" && "getAttribute" in ele) {
                var oid = ele.getAttribute("id");
                if (oid) {
                    var nid = oid.replace(tmpId, newId);
                    ele.setAttribute("id", nid);
                    $event.replaceId(oid, nid)
                }
                var childNodes = ele.childNodes;
                for (var i = 0, len = childNodes.length; i < len; i++) {
                    replaceId(childNodes.item(i), tmpId, newId)
                }
            }
        }
    },
    changeSymbolCoords: function(symbol) {
        if (!symbol) {
            return
        }
        var iconEle = this.svg.getElementById(symbol.id),
            blockEle = this.svg
            .getElementById("block_" + symbol.id);
        if (iconEle) {
            this.updateNodeIconPosition(iconEle, symbol.x, symbol.y)
        }
        this.updateSymbolLabelPosition(symbol);
        var _bbox = blockEle.getBBox();
        symbol.setBBox(_bbox.x, _bbox.y, _bbox.width, _bbox.height)
    },
    changeContainerCoords: function(container) {
        if (!container) {
            return
        }
        var id = container.id;
        var iconElement, blockBBox;
        if (container.isExpand) {
            iconElement = this.svg.getElementById("container_" + id);
            this.updateNodeIconPosition(iconElement, container.expandX,
                container.expandY);
            this.updateContainerExpandLabelPosition(container);
            blockBBox = this.svg.getElementById("block_container_" + id)
                .getBBox();
            container.setExpandBBox(blockBBox)
        } else {
            iconElement = this.svg.getElementById(id);
            this.updateNodeIconPosition(iconElement, container.x, container.y);
            this.updateContainerCollapseLabelPosition(container);
            this.updateContainerCollapseExpandToolPosition(container);
            blockBBox = this.svg.getElementById("block_" + id).getBBox();
            container.setCollapseBBox(blockBBox)
        }
    },
    updateContainerExpandLabelPosition: function(container, labelElement) {
        if (container.isExpand) {
            if (!labelElement) {
                labelElement = this.svg.getElementById("label_container_" + container.id)
            }
            if (labelElement) {
                var nodeIconBBox = container.getExpandIconBBox(),
                    style = container.style,
                    opts4nodeText = this.options.node_text;
                var options = {
                    "text-spacing": parseInt(opts4nodeText["text-spacing"]),
                    "text-align": style["text-align"] ? style["text-align"] : opts4nodeText["text-align"],
                    "text-valign": style["text-valign"] ? style["text-valign"] : opts4nodeText["text-valign"]
                };
                this.updateNodeLabelPosition(labelElement, nodeIconBBox,
                    options)
            }
        }
    },
    updateContainerCollapseLabelPosition: function(container, labelElement) {
        if (!container.isExpand) {
            if (!labelElement) {
                labelElement = this.svg.getElementById("label_" + container.id)
            }
            if (labelElement) {
                var nodeIconBBox = container.getCollapseIconBBox(),
                    style = container.style,
                    opts4nodeText = this.options.node_text;
                var options = {
                    "text-spacing": parseInt(opts4nodeText["text-spacing"]),
                    "text-align": style["text-align"] ? style["text-align"] : opts4nodeText["text-align"],
                    "text-valign": style["text-valign"] ? style["text-valign"] : opts4nodeText["text-valign"]
                };
                this.updateNodeLabelPosition(labelElement, nodeIconBBox,
                    options)
            }
        }
    },
    updateContainerCollapseExpandToolPosition: function(container,
        expandToolElement) {
        if (!container.isExpand) {
            if (!expandToolElement) {
                expandToolElement = this.svg.getElementById("tool_expand_" + container.id)
            }
            if (expandToolElement) {
                var nodeIconBBox = container.getCollapseIconBBox(),
                    x = nodeIconBBox.maxX - 16,
                    y = nodeIconBBox.minY;
                expandToolElement.setAttribute("transform", "translate(" + x + " " + y + ") scale(.8)")
            }
        }
    },
    updateContainerExpandSize: function(container) {
        if (container.isExpand) {
            var expandEle = this.svg
                .getElementById("container_" + container.id);
            if (expandEle) {
                this.svg.change(expandEle, {
                    "width": container.expandWidth,
                    "height": container.expandHeight
                })
            }
            this.updateContainerCollapseLabelPosition(container);
            var _cbbox = this.svg.getElementById(
                "block_container_" + container.id).getBBox();
            container.setExpandBBox(_cbbox)
        }
    },
    changeLinePath: function(line) { // 改变线路径
        var $svg = this.svg,
            _f_gebi = $svg.getElementById,
            _f_change = $svg.change;
        var borderElement = _f_gebi.call($svg, "border_" + line.id),
            srcHeadElement = _f_gebi
            .call($svg, "linehead_s_" + line.id),
            dstHeadElement = _f_gebi
            .call($svg, "linehead_d_" + line.id),
            lineElement = _f_gebi
            .call($svg, line.id),
            wrapElement = _f_gebi.call($svg, "wrap_" + line.id);

        if (borderElement) {
            _f_change(borderElement, {
                "d": line.path
            })
        }
        if (srcHeadElement) {
            _f_change(srcHeadElement, {
                "cx": line.x1,
                "cy": line.y1
            })
        }
        if (dstHeadElement) {
            _f_change(dstHeadElement, {
                "cx": line.x2,
                "cy": line.y2
            })
        }
        if (lineElement) {
            _f_change(lineElement, {
                "d": line.path
            })
        }
        if (wrapElement) {
            _f_change(wrapElement, {
                "d": line.path
            })
        }
        this.updateLineToolsPosition(line)
    },
    changeLineseterPath: function(lineseter) {
        this.changeLinePath(lineseter)
    },
    showLineWrap: function(lineId) {
        var isSelected = $.topology.selector.contains(lineId);
        this.svg.change(this.getLineWrapElement(lineId), {
            "opacity": isSelected ? 0.4 : 0.2
        })
    },
    hideLineWrap: function(lineId) {
        if ($.topology.selector.contains(lineId)) {
            return
        }
        this.svg.change(this.getLineWrapElement(lineId), {
            "opacity": 0
        })
    },
    eventColorRender: function(id, type, code) {
        var obj = $.topology.find(id),
            block = this.svg.getElementById("block_" + id),
            element = this.svg.getElementById(id),
            isShadow = obj.style["shadow"] && typeof(obj.style["shadow"]) !== "undefined" && obj.style["shadow"] !== "null";
        if (!block || !element) {
            return
        }
        if (type === "symbols" || type === "containers") {
            if (element != null && element.getAttribute("filter") !== "") {
                element.removeAttribute("filter")
            }
            if (isShadow) {
                this.svg.change(element, {
                    "filter": "url(#shadow_" + obj.style["shadow"] + ")"
                })
            }
        } else {
            if (block.getAttribute("filter") !== "") {
                block.removeAttribute("filter")
            }
            if (isShadow) {
                this.svg.change(block, {
                    "filter": "url(#shadow_" + obj.style["shadow"] + ")"
                })
            }
        }
        if (code !== null) {
            if (type === "symbols" || type === "containers") {
                this.svg.change(element, {
                    "filter": (isShadow ? ("url(#alarm_r4s_" + code + "_shadow_" + obj.style["shadow"] + ")") : ("url(#alarm_r4s_" + code + ")"))
                })
            } else {
                this.svg.change(block, {
                    "filter": (isShadow ? ("url(#alarm_r4l_" + code + "_shadow_" + obj.style["shadow"] + ")") : ("url(#alarm_r4l_" + code + ")"))
                })
            }
        }
    },
    eventColorRender4IE9: function(id, type, code) {
        var $topo = $.topology,
            $svg = this.svg,
            _f_gebi = $svg.getElementById,
            _f_change = $svg.change;
        var ele;
        var e = $topo.find(id);
        if (!e) {
            return
        }
        if (type === "symbols" || type === "containers") {
            if (code == null) {
                e.draw()
            } else {
                var iconPath = e.getIcon();
                iconPath = iconPath.substring(0, iconPath.lastIndexOf("."));
                iconPath = "icon/ie9_fixed/" + iconPath + "_" + code + "_0.gif";
                var image = new Image();
                image.onload = function() {
                    var element = _f_gebi.call($svg, id);
                    if (element) {
                        element.setAttribute("href", iconPath)
                    }
                };
                image.src = iconPath
            }
        } else {
            var eventColor = $topo.getEventColor(code);
            if (!eventColor || code == null) {
                e.draw()
            } else {
                ele = _f_gebi.call($svg, id);
                if (ele) {
                    _f_change(ele, {
                        stroke: eventColor
                    })
                }
                ele = _f_gebi.call($svg, "border_" + id);
                if (ele) {
                    _f_change(ele, {
                        stroke: eventColor
                    })
                }
                ele = _f_gebi.call($svg, "linehead_s_" + id);
                if (ele) {
                    _f_change(ele, {
                        fill: eventColor
                    })
                }
                ele = _f_gebi.call($svg, "linehead_d_" + id);
                if (ele) {
                    _f_change(ele, {
                        fill: eventColor
                    })
                }
                ele = _f_gebi.call($svg, "wrap_" + id);
                if (ele) {
                    _f_change(ele, {
                        stroke: eventColor
                    })
                }
            }
        }
    },
    eventAnimationRender4IE9: function(id, type, code) {
        var $topo = $.topology,
            $svg = this.svg;
        var e = $topo.find(id);
        if (!e) {
            return
        }
        if (type === "symbols" || type === "containers") {
            if (code == null) {
                e.draw()
            } else {
                var iconPath = e.getIcon();
                iconPath = iconPath.substring(0, iconPath.lastIndexOf("."));
                iconPath = "icon/ie9_fixed/" + iconPath + "_" + code + "_600.gif";
                var image = new Image();
                image.onerror = function() {};
                image.onload = function() {
                    var element = $svg.getElementById(id);
                    if (element) {
                        element.setAttributeNS($.svg.xlinkNS, "href", iconPath)
                    }
                };
                image.src = iconPath
            }
        } else {
            var eventColor = $topo.getEventColor(code);
            if (!eventColor || code == null) {
                this.lineEventJsAnimationRender.remove(id)
            } else {
                this.lineEventJsAnimationRender.add(id, eventColor)
            }
        }
    },
    eventAnimationRender: function(id, type, code) {
        var obj = $.topology.find(id),
            block = this.svg.getElementById("block_" + id),
            element = this.svg.getElementById(id),
            filter = (type === "symbols" || type === "containers" ? "r4s" : "r4l"),
            isShadow = obj.style["shadow"] && typeof(obj.style["shadow"]) !== "undefined" && obj.style["shadow"] !== "null";
        if (!block || !element) {
            return
        }
        var filterAnimate = this.svg.getElementById("event_" + id);
        if (filterAnimate) {
            this.svg.remove(filterAnimate)
        }
        if (isShadow) {
            if (type === "symbols" || type === "containers") {
                this.svg.change(element, {
                    "filter": "url(#shadow_" + obj.style["shadow"] + ")"
                })
            } else {
                this.svg.change(block, {
                    "filter": "url(#shadow_" + obj.style["shadow"] + ")"
                })
            }
        }
        if (code !== null) {
            filterAnimate = this.svg._svg.ownerDocument.createElementNS(
                $.svg.svgNS, "animate");
            filterAnimate.setAttribute("id", "event_" + id);
            filterAnimate.setAttribute("attributeName", "filter");
            filterAnimate.setAttribute("attributeType", "CSS");
            filterAnimate.setAttribute("begin", "0s");
            filterAnimate.setAttribute("dur", "1.2s");
            filterAnimate.setAttribute("fill", "freeze");
            filterAnimate.setAttribute("restart", "always");
            filterAnimate.setAttribute("repeatCount", "indefinite");
            if (isShadow) {
                filterAnimate.setAttribute("from", "url(#alarm_" + filter + "_" + code + "_shadow_" + obj.style["shadow"] + ")");
                filterAnimate.setAttribute("to", "url(#shadow_" + obj.style["shadow"] + ")")
            } else {
                filterAnimate.setAttribute("from", "url(#alarm_" + filter + "_" + code + ")");
                filterAnimate.setAttribute("to", "url(#alarm_r_normal)")
            }
            if (type === "symbols" || type === "containers") {
                element.appendChild(filterAnimate)
            } else {
                block.appendChild(filterAnimate)
            }
        }
    },
    lineEventJsAnimationRender: function() {
        var render = {},
            lines = null,
            timer = null,
            isShowEventColor = true;

        function init() {
            lines = {};
            timer = setInterval(function() {
                var color, elementArr, arr;
                for (var id in lines) {
                    elementArr = lines[id];
                    if (!elementArr) {
                        continue
                    }
                    for (var i = 0; i < elementArr.length; i++) {
                        arr = elementArr[i];
                        color = isShowEventColor ? arr[2] : arr[3];
                        arr[0].setAttribute(arr[1], color)
                    }
                }
                isShowEventColor = !isShowEventColor
            }, 600)
        }

        function wrapElement(eleId, color) {
            var $element = $("#" + eleId),
                e = null;
            if ($element.length > 0) {
                var element = $element[0],
                    attributeName = element.tagName == "path" ? "stroke" : "fill",
                    oldColor = element
                    .getAttribute(attributeName);
                e = [element, attributeName, color, oldColor]
            }
            return e
        }
        render.add = function(id, eventColor) {
            if (!timer) {
                init()
            }
            render.remove(id);
            var es = [],
                e;
            e = wrapElement(id, eventColor);
            if (e) {
                es.push(e)
            }
            e = wrapElement("border_" + id, eventColor);
            if (e) {
                es.push(e)
            }
            e = wrapElement("linehead_s_" + id, eventColor);
            if (e) {
                es.push(e)
            }
            e = wrapElement("linehead_d_" + id, eventColor);
            if (e) {
                es.push(e)
            }
            e = wrapElement("wrap_" + id, eventColor);
            if (e) {
                es.push(e)
            }
            if (es.length > 0) {
                lines[id] = es
            }
        };
        render.remove = function(id) {
            var es;
            if (lines && (es = lines[id])) {
                delete lines[id];
                var arr;
                for (var i = 0; i < es.length; i++) {
                    arr = es[i];
                    arr[0].setAttribute(arr[1], arr[3])
                }
            }
        };
        return render
    }(),
    code: function() {
        this.selector.reset();
        var showGrid = this.canvasGrid.isShow();
        if (showGrid) {
            this.canvasGrid.hide()
        }
        // if ($.topology.status === "SHOW") {
        $.topology.eventRender(true, false)
        // }
        var svgClone = this.svg._svg.cloneNode(true),
            _svgCode = this.svg.toSVG(svgClone),
            rootTransformStr = null;
        var reg = /<script[^>]*>.*(?=<\/script>)<\/script>/gi;
        _svgCode = _svgCode.replace(reg, "");
        _svgCode = _svgCode.replace('<defs><menu id="emptyDefaultMenu"/></defs>', "");
        _svgCode = _svgCode.replace('onload="(window.parent || window).jQuery.svg._registerSVG();emptyDefaultMenu();"', "");
        rootTransformStr = svgClone.getElementById("root").getAttribute("transform");
        if (rootTransformStr) {
            rootTransformStr = 'transform="' + rootTransformStr + '"'
        }
        _svgCode = _svgCode.replace(rootTransformStr, "");
        if ($.browser.msie) {
            var majorVer = Number($.browser.version.split(".")[0]);
            if (majorVer >= 9) {
                _svgCode = _svgCode.replace(/(<svg.*?width=.*?height=.*?version)/i, '<svg width="' + $.topology.view.style["width"] + '" height="' + $.topology.view.style["height"] + '" version')
            } else {
                _svgCode = _svgCode.replace(/(<svg.*?width=.*?height=.*?>)/i, '<svg version="1.1" width="' + $.topology.view.style["width"] + '" height="' + $.topology.view.style["height"] + '">')
            }
        } else {
            _svgCode = _svgCode.replace(/(<svg.*?width=.*?height=.*?>)/i, '<svg version="1.1" width="' + $.topology.view.style["width"] + '" height="' + $.topology.view.style["height"] + '">')
        }
        _svgCode = '<?xml version="1.0" encoding="UTF-8"?>' + '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" ' + '"http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">' + _svgCode;
        // if ($.topology.status === "SHOW") {
        $.topology.eventRender()
        // }
        if (showGrid) {
            this.canvasGrid.show()
        }
        return _svgCode
    },
    drawCurveLine: function() { // liyang曲线
        var drawLine = {},
            $topo = null,
            $ge = null,
            $svg = null,
            $event = null,
            fromNode = null,
            toNode = null,
            line = null,
            linePath = [],
            tempLine = null,
            tempLineId = "drawCurveLineTempLine",
            ids = null;
        drawLine.state = false;
        drawLine.init = function(_$topology) {
            $topo = _$topology;
            $ge = $topo.graphEngine;
            $svg = $ge.svg;
            $event = $ge.event;
            linePath = [
                [0, 0],
                [0, 0]
            ];
            if (!tempLine) {
                var block = $svg.group($ge.coverage
                    .getCoverageById("coverage_64"), "block_" + tempLineId);
                tempLine = $svg.path(block, $ge.path(linePath), {
                    "id": tempLineId,
                    "display": "none"
                })
            }
        };
        drawLine.start = function() {
            if (drawLine.state) {
                return
            }
            drawLine.state = true;
            fromNode = null;
            toNode = null;
            var style = $ge.options.line;
            linePath = [
                [0, 0],
                [0, 0]
            ];
            $svg.change(tempLine, {
                "d": $ge.path(linePath),
                "display": "block",
                "fill": "none", // liyang add,for delete fill-color
                "stroke": style["color"],
                "stroke-width": style["weight"],
                "stroke-opacity": style["opacity"]
            });
            var symbols = $topo.shapes.symbols,
                symbol, id;
            ids = [];
            for (var i in symbols) {
                symbol = symbols[i];
                if ($topo.isSymbol(symbol)) {
                    id = String(symbol.id);
                    ids.push(id)
                }
            }

            $event.add(ids, "mouseup", handelLeftClick);
            $("body").on("mousedown", handelRightClick)
        };

        function handelLeftClick(evt) {

            if (drawLine.state && evt.button == 0) {
                var id = evt.target.id,
                    node = null;
                if (!fromNode) {
                    node = $topo.find(id);
                    if ($topo.isSymbol(node)) {
                        drawLine.setFromNode(node)
                    }
                } else {
                    if (!toNode) {
                        node = $topo.find(id);
                        if ($topo.isSymbol(node) && node.id != fromNode.id) {
                            drawLine.setToNode(node)
                        }
                    }
                }

            } else {
                if (drawLine.state && evt.button == 2) {
                    drawLine.cancel()
                }
            }


        }

        function handelRightClick(evt) {
            if (drawLine.state && evt.button == 2) {
                drawLine.end()
            }
        }
        drawLine.setFromNode = function(node) {
            if (!node) {
                return
            }
            fromNode = node;
            if (fromNode && "getIconBBox" in fromNode) {
                var fromCoords = fromNode.getCenterCoords();
                linePath[0][0] = fromCoords.x;
                linePath[0][1] = fromCoords.y
            }
            $topo.selector.select(fromNode.id);
            $("body").on("mousemove", handelMove)
        };

        function handelMove(evt) {
            var pageX = evt.pageX,
                pageY = evt.pageY;
            if (fromNode && "getIconBBox" in fromNode) {
                var fromCoords = fromNode.getCenterCoords();
                linePath[0][0] = fromCoords.x;
                linePath[0][1] = fromCoords.y
            }
            var coords = $ge.canvas.coordinateConvert.page2Canvas(pageX, pageY);
            // 设置终点
            linePath[1][0] = coords.x;
            linePath[1][1] = coords.y;
            if (linePath[1][0] > linePath[0][0]) {
                linePath[1][0] -= 3
            } else {
                if (linePath[1][0] < linePath[0][0]) {
                    linePath[1][0] += 3
                }
            }
            if (linePath[1][1] > linePath[0][1]) {
                linePath[1][1] -= 3
            } else {
                if (linePath[1][1] < linePath[0][1]) {
                    linePath[1][1] += 3
                }
            }
            $svg.change(tempLine, {
                "d": $ge.path(linePath)
            })
        }
        drawLine.setToNode = function(node) {
            if (!(toNode = node)) {
                return
            }
            line = $topo.createCurveLine(); // 创建曲线
            line.setSrcNode(fromNode); // 设置起点
            line.setDstNode(toNode); // 设置终点
            line.setCurveNode(); // 设置曲线点
            line.add();

            $.topology.updateVirtualLine(); // 更新实际线
            var parent = line.parent;
            if (parent && !parent.isExpand) {
                parent.hide()
            }
            drawLine.end();
            $topo.selector.select(line.id)
        };
        drawLine.end = function() {
            fromNode = null;
            toNode = null;
            $svg.change(tempLine, {
                "display": "none"
            });
            for (var i in ids) {
                $event.remove(ids[i], "mouseup", handelLeftClick)
            }
            $("body").off("mousemove", handelMove);
            $("body").off("mousedown", handelRightClick);
            setTimeout(function() {
                drawLine.state = false
            }, 500)
        };
        drawLine.cancel = function() {
            drawLine.end()
        };

        return drawLine

    }(),

    drawStraightLink: function() { // 进入画链路
        var drawLine = {},
            $topo = null,
            $ge = null,
            $svg = null,
            $event = null,
            fromNode = null,
            toNode = null,
            line = null,
            linePath = [],
            tempLine = null,
            tempLineId = "drawStraightLineTempLine",
            ids = null;
        drawLine.state = false;
        drawLine.init = function(_$topology) {

            $topo = _$topology;
            $ge = $topo.graphEngine;
            $svg = $ge.svg;
            $event = $ge.event;
            linePath = [
                [0, 0],
                [0, 0]
            ];
            if (!tempLine) {
                var block = $svg.group($ge.coverage
                    .getCoverageById("coverage_64"), "block_" + tempLineId);
                tempLine = $svg.path(block, $ge.path(linePath), {
                    "id": tempLineId,
                    "display": "none"
                })
            }
        };
        drawLine.start = function() {
            if (drawLine.state) {
                return
            }
            drawLine.state = true;
            fromNode = null;
            toNode = null;
            var style = $ge.options.line;
            linePath = [
                [0, 0],
                [0, 0]
            ];
            $svg.change(tempLine, {
                "d": $ge.path(linePath),
                "display": "block",
                "stroke": style["color"],
                "stroke-width": style["weight"],
                "stroke-opacity": style["opacity"]
            });
            var symbols = $topo.shapes.symbols,
                symbol, id;
            ids = [];
            for (var i in symbols) {
                symbol = symbols[i];
                if ($topo.isSymbol(symbol)) {
                    id = String(symbol.id);
                    ids.push(id)
                }
            }

            $event.add(ids, "mouseup", handelLeftClick);
            $("body").on("mousedown", handelRightClick)
        };

        function handelLeftClick(evt) {
            if (drawLine.state && evt.button == 0) {
                var id = evt.target.id,
                    node = null;
                if (!fromNode) {
                    node = $topo.find(id);
                    if ($topo.isSymbol(node)) {
                        drawLine.setFromNode(node)
                    }
                } else {
                    if (!toNode) {
                        node = $topo.find(id);
                        if ($topo.isSymbol(node) && node.id != fromNode.id) {
                            drawLine.setToNode(node)
                        }
                    }
                }

            } else {
                if (drawLine.state && evt.button == 2) {
                    drawLine.cancel()
                }
            }


        }

        function handelRightClick(evt) {
            if (drawLine.state && evt.button == 2) {
                drawLine.end()
            }
        }
        drawLine.setFromNode = function(node) {
            if (!node) {
                return
            }
            fromNode = node;
            if (fromNode && "getIconBBox" in fromNode) {
                var fromCoords = fromNode.getCenterCoords();
                linePath[0][0] = fromCoords.x;
                linePath[0][1] = fromCoords.y
            }
            $topo.selector.select(fromNode.id);
            $("body").on("mousemove", handelMove)
        };

        function handelMove(evt) {
            var pageX = evt.pageX,
                pageY = evt.pageY;
            if (fromNode && "getIconBBox" in fromNode) {
                var fromCoords = fromNode.getCenterCoords();
                linePath[0][0] = fromCoords.x;
                linePath[0][1] = fromCoords.y
            }
            var coords = $ge.canvas.coordinateConvert.page2Canvas(pageX, pageY);
            linePath[1][0] = coords.x;
            linePath[1][1] = coords.y;
            if (linePath[1][0] > linePath[0][0]) {
                linePath[1][0] -= 3
            } else {
                if (linePath[1][0] < linePath[0][0]) {
                    linePath[1][0] += 3
                }
            }
            if (linePath[1][1] > linePath[0][1]) {
                linePath[1][1] -= 3
            } else {
                if (linePath[1][1] < linePath[0][1]) {
                    linePath[1][1] += 3
                }
            }
            $svg.change(tempLine, {
                "d": $ge.path(linePath)
            })
        }
        drawLine.setToNode = function(node) {
            if (!(toNode = node)) {
                return
            }
            loadingwindow(ctx, 200, 50, '加载中...')
            var urlStr = ctx + "/network/topology/linkInfo.do?id=-1&fromId=" + fromNode.instanceId + "&toId=" + toNode.instanceId + "&fromName=" + fromNode.name + "&toName=" + toNode.name;
            var title = "新建链路";
            $.ajax({
                type: "get",
                url: urlStr,
                timeout: 60000, //超时时间设置，单位毫秒
                dataType: "html",
                success: function(content) {
                    closeLodingWindow();
                    openwindow(title, 450, 480, content, function() {
                        if (!$("#topoLineInfo").valid()) {
                            return;
                        }
                        loadingwindow(ctx, 200, 50, '加载中...')
                        $.ajax({
                            type: "get",
                            url: ctx + "/network/topology/saveLink.do",
                            timeout: 60000, //超时时间设置，单位毫秒
                            data: $("#topoLineInfo").serialize(),
                            dataType: "json",
                            success: function(msg) {
                                closeLodingWindow();
                                if (msg.success == true || msg.success == "true" || msg.success == 7) {
                                    // msg.success==7表示资源实例已存在，直接绑定链路资源ID
                                    line = $topo.createLine();
                                    line.setSrcNode(fromNode);
                                    line.setDstNode(toNode);
                                    line.add();
                                    $.topology.updateVirtualLine();
                                    var parent = line.parent;
                                    if (parent && !parent.isExpand) {
                                        parent.hide()
                                    }
                                    drawLine.end();
                                    line.instanceId = msg.instanceId;
                                    line.objectClass = "link";
                                    line.objectType = "auto";
                                    $topo.selector.select(line.id)
                                    closeWindow();
                                    $topo.saveTopo();
                                } else {
                                    layer.msg("链路创建失败:" + msg.errMsg, { icon: 2 });
                                    drawLine.cancel();
                                    closeWindow();
                                }
                            },
                            error: function() {
                                closeLodingWindow();
                                layer.msg("系统异常，请联系管理员", { icon: 0 });
                            }
                        })
                    }, function() {
                        drawLine.cancel();
                        closeWindow();
                    })
                },
                error: function() {
                    closeLodingWindow();
                    layer.msg("系统异常，请联系管理员", { icon: 0 });
                }
            })
        };
        drawLine.end = function() {
            fromNode = null;
            toNode = null;
            $svg.change(tempLine, {
                "display": "none"
            });
            for (var i in ids) {
                $event.remove(ids[i], "mouseup", handelLeftClick)
            }
            $("body").off("mousemove", handelMove);
            $("body").off("mousedown", handelRightClick);
            setTimeout(function() {
                drawLine.state = false
            }, 500)
        };
        drawLine.cancel = function() {
            drawLine.end()
        };

        return drawLine

    }(),
    drawStraightLine: function() { // 进入画直线
        var drawLine = {},
            $topo = null,
            $ge = null,
            $svg = null,
            $event = null,
            fromNode = null,
            toNode = null,
            line = null,
            linePath = [],
            tempLine = null,
            tempLineId = "drawStraightLineTempLine",
            ids = null;
        drawLine.state = false;
        drawLine.init = function(_$topology) {

            $topo = _$topology;
            $ge = $topo.graphEngine;
            $svg = $ge.svg;
            $event = $ge.event;
            linePath = [
                [0, 0],
                [0, 0]
            ];
            if (!tempLine) {
                var block = $svg.group($ge.coverage
                    .getCoverageById("coverage_64"), "block_" + tempLineId);
                tempLine = $svg.path(block, $ge.path(linePath), {
                    "id": tempLineId,
                    "display": "none"
                })
            }
        };
        drawLine.start = function() {
            if (drawLine.state) {
                return
            }
            drawLine.state = true;
            fromNode = null;
            toNode = null;
            var style = $ge.options.line;
            linePath = [
                [0, 0],
                [0, 0]
            ];
            $svg.change(tempLine, {
                "d": $ge.path(linePath),
                "display": "block",
                "stroke": style["color"],
                "stroke-width": style["weight"],
                "stroke-opacity": style["opacity"]
            });
            var symbols = $topo.shapes.symbols,
                symbol, id;
            ids = [];
            for (var i in symbols) {
                symbol = symbols[i];
                if ($topo.isSymbol(symbol)) {
                    id = String(symbol.id);
                    ids.push(id)
                }
            }

            $event.add(ids, "mouseup", handelLeftClick);
            $("body").on("mousedown", handelRightClick)
        };

        function handelLeftClick(evt) {
            if (drawLine.state && evt.button == 0) {
                var id = evt.target.id,
                    node = null;
                if (!fromNode) {
                    node = $topo.find(id);
                    if ($topo.isSymbol(node)) {
                        drawLine.setFromNode(node)
                    }
                } else {
                    if (!toNode) {
                        node = $topo.find(id);
                        if ($topo.isSymbol(node) && node.id != fromNode.id) {
                            drawLine.setToNode(node)
                        }
                    }
                }

            } else {
                if (drawLine.state && evt.button == 2) {
                    drawLine.cancel()
                }
            }


        }

        function handelRightClick(evt) {
            if (drawLine.state && evt.button == 2) {
                drawLine.end()
            }
        }
        drawLine.setFromNode = function(node) {
            if (!node) {
                return
            }
            fromNode = node;
            if (fromNode && "getIconBBox" in fromNode) {
                var fromCoords = fromNode.getCenterCoords();
                linePath[0][0] = fromCoords.x;
                linePath[0][1] = fromCoords.y
            }
            $topo.selector.select(fromNode.id);
            $("body").on("mousemove", handelMove)
        };

        function handelMove(evt) {
            var pageX = evt.pageX,
                pageY = evt.pageY;
            if (fromNode && "getIconBBox" in fromNode) {
                var fromCoords = fromNode.getCenterCoords();
                linePath[0][0] = fromCoords.x;
                linePath[0][1] = fromCoords.y
            }
            var coords = $ge.canvas.coordinateConvert.page2Canvas(pageX, pageY);
            linePath[1][0] = coords.x;
            linePath[1][1] = coords.y;
            if (linePath[1][0] > linePath[0][0]) {
                linePath[1][0] -= 3
            } else {
                if (linePath[1][0] < linePath[0][0]) {
                    linePath[1][0] += 3
                }
            }
            if (linePath[1][1] > linePath[0][1]) {
                linePath[1][1] -= 3
            } else {
                if (linePath[1][1] < linePath[0][1]) {
                    linePath[1][1] += 3
                }
            }
            $svg.change(tempLine, {
                "d": $ge.path(linePath)
            })
        }
        drawLine.setToNode = function(node) {
            if (!(toNode = node)) {
                return
            }
            line = $topo.createLine();
            line.setSrcNode(fromNode);
            line.setDstNode(toNode);
            line.objectType = "line";
            line.add();
            $.topology.updateVirtualLine();
            var parent = line.parent;
            if (parent && !parent.isExpand) {
                parent.hide()
            }
            drawLine.end();
            $topo.selector.select(line.id)
        };
        drawLine.end = function() {
            fromNode = null;
            toNode = null;
            $svg.change(tempLine, {
                "display": "none"
            });
            for (var i in ids) {
                $event.remove(ids[i], "mouseup", handelLeftClick)
            }
            $("body").off("mousemove", handelMove);
            $("body").off("mousedown", handelRightClick);
            setTimeout(function() {
                drawLine.state = false
            }, 500)
        };
        drawLine.cancel = function() {
            drawLine.end()
        };

        return drawLine

    }(),
    edgeDetect: function(childBox, parentBox) {
        if (!$.isArray(parentBox) || parentBox.length !== 4 || !$.isArray(childBox) || childBox.length !== 4) {
            return false
        }
        var x = 0,
            y = 0;
        if (childBox[0] < parentBox[0]) {
            x = parentBox[0] - childBox[0]
        } else {
            if (childBox[2] > parentBox[2]) {
                x = parentBox[2] - childBox[2]
            }
        }
        if (childBox[1] < parentBox[1]) {
            y = parentBox[1] - childBox[1]
        } else {
            if (childBox[3] > parentBox[3]) {
                y = parentBox[3] - childBox[3]
            }
        }
        return {
            x: x,
            y: y
        }
    },
    boxCanvasEdgeDetect: function(minX, minY, maxX, maxY) {
        if (arguments.length != 4) {
            return false
        }
        var viewBox = $.topology.view.getViewBox(),
            vMinX = viewBox.x,
            vMinY = viewBox.y,
            vMaxX = viewBox.width,
            vMaxY = viewBox.height;
        return this.edgeDetect([minX, minY, maxX, maxY], [vMinX, vMinY,
            vMaxX, vMaxY
        ])
    },
    boxViewportEdgeDetect: function(minX, minY, maxX, maxY) {
        if (arguments.length != 4) {
            return false
        }
        var viewport = this.canvas.viewport(),
            vMinX = viewport.x,
            vMinY = viewport.y,
            vMaxX = vMinX + viewport.width,
            vMaxY = vMinY + viewport.height;
        return this.edgeDetect([minX, minY, maxX, maxY], [vMinX, vMinY,
            vMaxX, vMaxY
        ])
    },
    pointCanvasEdgeDetect: function(x, y) {
        return this.boxCanvasEdgeDetect(x, y, x, y)
    },
    pointViewportEdgeDetect: function(x, y) {
        return this.boxViewportEdgeDetect(x, y, x, y)
    },
    _support: function() {
        var detail = {
            "basic": false,
            "filter": false,
            "font": false,
            "animation": false
        };
        var majorVer = Number($.browser.version.split(".")[0]);
        if ($.browser.msie) {
            if (majorVer >= 10) {
                detail.basic = detail.filter = true
            } else {
                if (majorVer === 9) {
                    try {
                        if (!!(window.ActiveXObject && new ActiveXObject("Adobe.SVGCtl"))) {
                            detail.basic = detail.filter = detail.animation = true
                        } else {
                            detail.basic = true
                        }
                    } catch (e) {
                        detail.basic = true
                    }
                } else {
                    if (majorVer >= 5.5 && majorVer <= 8) {
                        try {
                            if (!!(window.ActiveXObject && new ActiveXObject("Adobe.SVGCtl"))) {
                                detail.basic = detail.filter = detail.animation = true
                            }
                        } catch (e) {}
                    }
                }
            }
        } else {
            if ($.browser.chrome) {
                if (majorVer >= 8) {
                    detail.basic = detail.font = detail.filter = detail.animation = true
                } else {
                    if (majorVer >= 5) {
                        detail.basic = detail.font = detail.animation = true
                    } else {
                        if (majorVer >= 4) {
                            detail.basic = detail.font = true
                        }
                    }
                }
            } else {
                if ($.browser.mozilla) {
                    if (majorVer >= 4) {
                        detail.basic = detail.filter = detail.animation = true
                    } else {
                        if (majorVer >= 3) {
                            detail.basic = detail.filter = true
                        }
                    }
                } else {
                    if ($.browser.safari) {
                        if (majorVer >= 6) {
                            detail.basic = detail.font = detail.animation = detail.filter = true
                        } else {
                            if (majorVer >= 4) {
                                detail.basic = detail.font = detail.animation = true
                            } else {
                                if (majorVer >= 3.2) {
                                    detail.basic = detail.font = true
                                }
                            }
                        }
                    } else {
                        if ($.browser.opera) {
                            if (majorVer >= 9) {
                                detail.basic = detail.filter = detail.font = detail.animation = true
                            }
                        }
                    }
                }
            }
        }
        return detail
    },
    _id: function(gid) {
        gid = $.trim(gid);
        if (!gid || gid === "") {
            return null
        }
        var isTmpId = gid.search(/tmp-\d/) !== -1;
        if (isTmpId) {
            return gid.match(/tmp-[\d]+/g).join("")
        } else {
            var ds = gid.match(/[\d]+/g);
            return ds && ds[0]
        }
    },
    _icon: function(node) {
        var opts = $.extend({ "preserveAspectRatio": "none" }, (node.style["opacity"] ? {
            "opacity": node.style["opacity"]
        } : {}));
        var iconElement = this.svg.getElementById(node.id);
        if (node.style["shadow"] && node.style["shadow"] !== "" && node.style["shadow"] !== "null") {
            opts.filter = "url(#shadow_" + node.style["shadow"].toLowerCase() + ")"
        } else {
            var hasAlarmFilter = /alarm_/gi;
            if (iconElement && iconElement.getAttribute("filter") && !hasAlarmFilter.test(iconElement.getAttribute("filter"))) {
                iconElement.removeAttribute("filter")
            }
        }
        if (!iconElement) {
            iconElement = this.svg.image(this.svg.getElementById("block_" + node.id), node.x, node.y,
                parseInt(node.style["icon-width"]),
                parseInt(node.style["icon-height"]),
                ctxImg + "/topology/icon_svg/" + node.style["icon"],
                $.extend(opts, {
                    "id": node.id
                }))
        } else {
            this.svg.change(iconElement, $.extend(opts, {
                "x": node.x,
                "y": node.y,
                "width": parseInt(node.style["icon-width"]),
                "height": parseInt(node.style["icon-height"]),
                "href": ctxImg + "/topology/icon_svg/" + node.style["icon"]
            }))
        }
        return iconElement
    },
    _label: function(node) {
        if (!node.name || $.trim(node.name) === "") {
            return null
        }
        var style = node.style,
            isDisplay = style["text-display"] != 0,
            labelId = "label_" + node.id,
            label = this.svg.getElementById(labelId);
        if (!isDisplay) {
            if (label) {
                this.svg.remove(label)
            }
            return null
        }
        var name = $.trim(node.name),
            opts4nodeText = this.options.node_text,
            nameLines = name
            .split("<br>");
        if (!label) {
            label = this.svg.group(this.svg.getElementById("block_" + node.id),
                labelId);

            function handelLabelClickEvent(e) {
                if (e.detail != 2) {
                    return
                }
                var node = $.topology.graphEngine.findModel(e.target.id)
            }
            this.event.add(label, "click", handelLabelClickEvent)
        }
        var opts = $.extend({
            "id": "text_" + node.id,
            "font-family": style["font-family"] ? style["font-family"] : opts4nodeText["font-family"],
            "fill": style["font-color"] ? style["font-color"] : opts4nodeText["font-color"],
            "fill-opacity": style["text-opacity"] ? style["text-opacity"] : opts4nodeText["text-opacity"],
            "font-style": style["font-style"] ? style["font-style"] : opts4nodeText["font-style"],
            "font-weight": style["font-weight"] ? style["font-weight"] : opts4nodeText["font-weight"],
            "font-size": style["font-size"] ? style["font-size"] : opts4nodeText["font-size"],
            "text-decoration": style["text-decoration"] ? style["text-decoration"] : opts4nodeText["text-decoration"],
            "letter-spacing": opts4nodeText["letter-spacing"]
        }, ((style["text-stroke"] && style["text-stroke"] !== "0") || opts4nodeText["text-stroke"] !== "0" ? {
            "stroke-width": style["text-stroke"] ? style["text-stroke"] : opts4nodeText["text-stroke"],
            "stroke": style["text-stroke-color"] ? style["text-stroke-color"] : opts4nodeText["text-stroke-color"]
        } : {}));
        var text = this.svg.getElementById("text_" + node.id);
        if (text) {
            this.svg.remove(text);
            text = null
        }
        if (style["text-shadow"] && style["text-shadow"] !== "" && style["text-shadow"] !== "null") {
            opts.filter = "url(#shadow_" + style["text-shadow"].toLowerCase() + ")"
        } else {
            if (label && label.getAttribute("filter")) {
                label.removeAttribute("filter")
            }
        }
        if (nameLines.length == 1) {
            text = this.svg.text(label, node.x, node.y, name, opts)
        } else {
            var multiLinesText = this.svg.createText(),
                dy = parseInt(opts["font-size"].replace(/px/i, "")) + parseInt(opts4nodeText["text-line-spacing"]);
            opts = $.extend(opts, {
                "text-anchor": opts4nodeText["text-anchor"],
                "text-line-height": opts4nodeText["text-line-height"]
            });
            for (var i = 0, len = nameLines.length; i < len; i++) {
                if (i === 0) {
                    multiLinesText.span(nameLines[i], {
                        "id": opts.id + "_" + i,
                        "x": node.x
                    })
                } else {
                    multiLinesText.span(nameLines[i], {
                        "id": opts.id + "_" + i,
                        "x": node.x,
                        "dy": dy
                    })
                }
            }
            text = this.svg.text(label, node.x, node.y, multiLinesText, opts)
        }
        return label
    },
    _initDefFilters: function() {
        // if ($.topology.status === "SHOW") {
        this._shadowRenderFilter();
        this._alarmRenderFilter();
        this._highlightRenderFilter()
        // } else {
        // this._shadowRenderFilter();
        // this._highlightRenderFilter()
        // }
    },
    _shadowRenderFilter: function() {
        var $svg = this.svg,
            $defs = this.defs;
        $.each(this.shadow, function(course, offset) {
            if (!offset) {
                return true
            }
            var filter = $svg.filter($defs, "shadow_" + course, "-100%", "-100%", "300%", "300%");
            $svg.gaussianBlur(filter, "blur", "SourceAlpha", "4");
            $svg.offset(filter, "offsetBlur", "blur", offset.offsetX, offset.offsetY);
            $svg.blend(filter, "shadow_" + course, "normal", "SourceGraphic", "offsetBlur")
        })
    },
    _alarmRenderFilter: function() {
        var $svg = this.svg,
            $defs = this.defs,
            _shadow = this.shadow,
            filters4Symbol = null,
            filters4line = null,
            filter = null;
        filters4Symbol = topoData.config.event4symbol;
        filters4line = topoData.config.event4line;
        if (ctxface == "dark") {
            filters4line = topoData.config.event4line.dark;
        }
        $.each(filters4Symbol, function(i, renderCfg) {
            var _in = renderCfg["in"],
                _type = renderCfg["type"],
                _value = renderCfg["values"];
            filter = $svg.filter($defs, "alarm_r4s_" + _in);
            $svg.colorMatrix(filter, null, "SourceGraphic", _type, _value);
            $.each(_shadow, function(course, offset) {
                if (!offset) {
                    return true
                }
                filter = $svg.filter($defs, "alarm_r4s_" + _in + "_shadow_" + course, "-100%", "-100%", "300%", "300%");
                $svg.colorMatrix(filter, "cm", "SourceGraphic", _type, _value);
                $svg.gaussianBlur(filter, "blur", "SourceAlpha", "4");
                $svg.offset(filter, "offsetBlur", "blur", offset.offsetX, offset.offsetY);
                $svg.blend(filter, "alarm_r4s_" + _in + "_shadow_" + course, "normal", "cm", "offsetBlur")
            })
        });
        $.each(filters4line, function(i, renderCfg) {
            var _in = renderCfg["in"],
                _type = renderCfg["type"],
                _value = renderCfg["values"];
            filter = $svg.filter($defs, "alarm_r4l_" + _in);
            $svg.colorMatrix(filter, null, "SourceGraphic", _type, _value);
            $.each(_shadow, function(course, offset) {
                if (!offset) {
                    return true
                }
                filter = $svg.filter($defs, "alarm_r4l_" + _in + "_shadow_" + course, "-100%", "-100%", "300%", "300%");
                $svg.colorMatrix(filter, "cm", "SourceGraphic", _type, _value);
                $svg.gaussianBlur(filter, "blur", "SourceAlpha", "4");
                $svg.offset(filter, "offsetBlur", "blur", offset.offsetX, offset.offsetY);
                $svg.blend(filter, "alarm_r4l_" + _in + "_shadow_" + course, "normal", "cm", "offsetBlur")
            })
        });
        filter = $svg.filter($defs, "alarm_r_normal");
        $svg.colorMatrix(filter, null, "SourceGraphic", "hueRotate", "0")
    },
    highlight: function(ids) {
        if (!ids || !$.isArray(ids)) {
            return
        }
        var $topo = $.topology,
            $ge = $topo.graphEngine,
            symbols = {},
            lines = {};
        if ($ge.highLighter) {
            var viewMask = $ge.svg.getElementById("view_mask");
            $ge.svg.remove(viewMask);
            $ge.event.remove("view_mask");
            $ge.lowlight()
        }
        $ge.highLighter = {};
        var $highLighter = $ge.highLighter,
            _f_find = $topo.find;
        for (var i = 0, len = ids.length; i < len; i++) {
            var _id = ids[i];
            if ($topo.isSymbol(_id)) {
                symbols[_id] = _f_find(_id, "symbol")
            } else {
                if ($topo.isLine(_id)) {
                    lines[_id] = _f_find(_id, "line")
                }
            }
        }
        $highLighter.changes = [];
        var highlightIds = [],
            _f_highlightCoverage = $ge._highlightCoverage;
        for (var id in lines) {
            var _parent = lines[id].parent;
            if (_parent && !_parent.isExpand) {
                _parent.expand();
                $highLighter.changes.push(_parent.id)
            }
            _f_highlightCoverage.call($ge, id);
            highlightIds.push(id)
        }
        for (var id in symbols) {
            var _parent = symbols[id].parent;
            if (_parent && !_parent.isExpand) {
                _parent.expand();
                $highLighter.changes.push(_parent.id)
            }
            _f_highlightCoverage.call($ge, id);
            highlightIds.push(id)
        }
        $highLighter.elements = highlightIds;
        var viewMask = $ge.svg.rect(
            $ge.coverage.getCoverageById("coverage_80"), 0, 0,
            parseInt($topo.view.style["width"]),
            parseInt($topo.view.style["height"]), {
                "id": "view_mask",
                "fill": "#000000",
                "fill-opacity": "0"
            });
        $ge.event.add("view_mask", "click", $ge.lowlight);
        $ge.animation.transform(viewMask, [{ "attr": "fill-opacity", "value": "0.85" }], 200)
    },
    _highlightCoverage: function(id) {
        var ele = this.svg.getElementById("block_" + id);
        var upBlockEle = ele.cloneNode(true),
            hlBlockEle = ele.cloneNode(true);
        while (ele.firstChild) {
            ele.removeChild(ele.firstChild)
        }
        this.svg.change(ele, {
            "id": "block_hl_after_" + id
        });
        var highLightBlock = this.svg.group(this.coverage.getCoverageById("coverage_90"), "block_hl_" + id);
        hlBlockEle.firstChild.setAttribute("id", "block_hl_blur_" + id);
        hlBlockEle.firstChild.setAttribute("filter", "url(#highlight_render)");
        if (hlBlockEle.childNodes.length > 1) {
            hlBlockEle.removeChild(hlBlockEle.childNodes[1])
        }
        this.svg.add(highLightBlock, hlBlockEle);
        this.svg.add(highLightBlock, upBlockEle)
    },
    lowlight: function() {
        var $ge = $.topology.graphEngine,
            viewMask = $ge.svg
            .getElementById("view_mask");
        if (viewMask) {
            $ge.animation.transform(viewMask, [{
                "attr": "fill-opacity",
                "value": "0"
            }], 200, function() {
                $.topology.graphEngine.svg.remove(viewMask);
                $.topology.graphEngine.event.remove("view_mask")
            })
        }
        if (!$ge.highLighter) {
            return
        }
        var $svg = $ge.svg,
            _f_gebi = $svg.getElementById,
            _f_add = $svg.add,
            _f_change = $svg.change,
            _f_remove = $svg.remove,
            _f_find = $.topology.find,
            ids = $ge.highLighter.elements,
            changeEleIds = $ge.highLighter.changes;
        for (var i = 0, len = ids.length; i < len; i++) {
            var block = _f_gebi.call($svg, "block_hl_" + ids[i]);
            var nodes = block.cloneNode(true).childNodes[1].childNodes;
            var afterBlock = _f_gebi.call($svg, "block_hl_after_" + ids[i]);
            for (var j = 0, jl = nodes.length; j < jl; j++) {
                _f_add.call($svg, afterBlock, nodes[j])
            }
            _f_remove(_f_gebi.call($svg, "block_hl_" + ids[i]));
            _f_change(afterBlock, {
                "id": "block_" + ids[i]
            })
        }
        for (var i = 0, len = changeEleIds.length; i < len; i++) {
            var changeObj = _f_find(changeEleIds[i], "container|lineseter");
            try {
                changeObj.collapse()
            } catch (e) {}
        }
        $ge.highLighter = null
    },
    _highlightRenderFilter: function() {
        var filter = this.svg.filter(this.defs, "highlight_render", 0, 0, $(window).width(), $(window).height(), {
            "filterUnits": "userSpaceOnUse"
        });
        this.svg.colorMatrix(filter, "cmWhite", "SourceGraphic", "matrix", "1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0.8 0");
        this.svg.gaussianBlur(filter, null, "cmWhite", "12")
    },
    bindViewSelectEvent: function(elementId) {
        if (!elementId || !this.event) {
            return
        }
        var id = String(elementId);
        if (!this.event.has(id, "mousedown", selectView)) {
            this.event.add(id, "mousedown", selectView)
        }

        function selectView() {
            $.topology.selector.select($.topology.view.id)
        }
    },
    bindViewDragEvent: function(elementId) {
        if (!elementId || !this.event) {
            return
        }
        var id = String(elementId);
        if (!this.event.has(id, "drag", dragView)) {
            this.event.add(id, "drag", dragView)
        }

        function dragView(evt) {
            var $topo = $.topology,
                $ge = $topo.graphEngine;
            if ($topo.ui.viewDragAction != $topo.ui.VIEW_DRAG_ACTION_MOVE) {
                return
            }
            if ($ge.drawStraightLine.state) {
                return
            }
            var scale = $ge.canvas.scale();
            var dx = evt.dx,
                dy = evt.dy;
            var x = dx / scale;
            var y = dy / scale;
            $ge.moveView(x, y)
        }
    },
    bindViewContextMenuEvent: function(elementId) {
        var id = String(elementId);
        this.event.add(id, "mouseup", handleEvent);

        function handleEvent(evt) {
            if (evt.button != 2) {
                return
            }
            var $topo = $.topology;
            if ($topo.graphEngine.drawStraightLine.state) {
                return
            }
            $topo.selector.select(evt.target.id);
            $topo.contextObj = $topo.view;
            $topo.lastClickPoint = {
                x: evt.pageX,
                y: evt.pageY
            };
            $.lab.menu.showContextMenu(evt.pageX, evt.pageY)
        }
    },
    bindElementContextMenuEvent: function(elementId) {
        var id = String(elementId);
        if (!this.event.has(id, "mouseup", handleEvent)) {
            this.event.add(id, "mouseup", handleEvent)
        }

        function handleEvent(evt) {
            if (evt.button != 2) {
                return
            }
            var $topo = $.topology;
            if ($topo.graphEngine.drawStraightLine.state) {
                return
            }
            var target = evt.target,
                element = $topo.graphEngine.findModel(target.id);
            if (!element) {
                return
            }
            var selector = $topo.selector;
            if ((selector.symbols().length + selector.containers().length) > 0 && (selector.lines().length + selector.lineseters().length) > 0) {
                return
            }
            var id = element.id;
            if (!selector.contains(id)) {
                selector.select(id)
            }
            $topo.contextObj = element;
            $topo.lastClickPoint = {
                x: evt.pageX,
                y: evt.pageY
            };
            $.lab.menu.showContextMenu(evt.pageX, evt.pageY)
        }
    },
    bindNodeSelectEvent: function(elementId) {
        var id = String(elementId),
            event = this.event,
            $ge = this,
            $selector = $.topology.selector;
        event.add(id, "dragstart", dragStart);
        event.add(id, "drag", drag);
        event.add(id, "dragend", dragEnd);
        var moved = 0,
            node = null,
            nodeId = null,
            isAdd = false;

        function dragStart(e) {
            moved = 0;
            isAdd = false;
            if (e.button == 0) {
                node = $ge.findModel(e.target.id);
                if (node) {
                    nodeId = node.id;
                    var ctrlKey = e.ctrlKey;
                    if (!ctrlKey) {
                        if (!$selector.contains(nodeId)) {
                            $selector.select(nodeId);
                            isAdd = true
                        }
                    } else {
                        var ids = [].concat($selector.symbols()).concat(
                            $selector.containers());
                        var index = $.inArray(nodeId, ids);
                        if (index == -1) {
                            ids.push(nodeId);
                            $selector.select(ids);
                            isAdd = true
                        }
                    }
                }
            }
        }

        function drag(e) {
            moved |= e.dx | e.dy
        }

        function dragEnd(e) {
            if (e.button == 0 && node) {
                nodeId = node.id;
                var ctrlKey = e.ctrlKey;
                if (!ctrlKey) {
                    if (!moved && !isAdd && $selector.contains(nodeId)) {
                        $selector.select(nodeId)
                    }
                } else {
                    if (!moved && !isAdd) {
                        var ids = [].concat($selector.symbols()).concat($selector.containers());
                        var index = $.inArray(nodeId, ids);
                        if (index != -1) {
                            ids.splice(index, 1);
                            $selector.select(ids)
                        }
                    }
                }
            }
            moved = 0
        }
    },
    bindLineSelectEvent: function(elementId) {
        var id = String(elementId);
        if (!this.event.has(id, "mousedown", handleEvent)) {
            this.event.add(id, "mousedown", handleEvent)
        }
        var $ge = this;

        function handleEvent(e) {
            if (e.button == 0) {
                var element = $ge.findModel(e.target.id);
                if (element) {
                    var eleId = element.id;
                    var $topo = $.topology,
                        selector = $topo.selector,
                        focus = selector.focus(),
                        ctrlKey = e.ctrlKey;
                    if (ctrlKey && ($topo.isLine(focus) || $topo.isLineseter(focus))) {
                        var ids = [].concat(selector.lines()).concat(selector.lineseters());
                        var index = $.inArray(eleId, ids);
                        if (index != -1) {
                            ids.splice(index, 1)
                        } else {
                            ids.push(eleId)
                        }
                        selector.select(ids)
                    } else {
                        selector.select(eleId);
                        var element = $topo.graphEngine.findModel(eleId);
                        $topo.contextObj = element;
                    }
                }
            }
        }
    },
    bindViewDrawRectSelectEvent: function(elementId) {
        var id = String(elementId);
        this.event.add(id, "dragstart", drawRectStart);
        this.event.add(id, "drag", drawRect);
        this.event.add(id, "dragend", drawRectEnd);
        var $ge = this,
            $svg = this.svg,
            canvas = this.canvas,
            selectorRect = null,
            x1 = null,
            y1 = null,
            x2 = null,
            y2 = null,
            width = null,
            height = null;
        var drawRect = false;
        var moved = 0;

        function drawRectStart(evt) {
            if (evt.button != 0) {
                return
            }
            if ($.topology.ui.viewDragAction != $.topology.ui.VIEW_DRAG_ACTION_SELECT) {
                return
            }
            if ($.topology.graphEngine.drawStraightLine.state) {
                return
            }
            drawRect = true;
            moved = 0;
            x1 = x2 = evt.x, y1 = y2 = evt.y;
            if (!selectorRect) {
                selectorRect = $svg.rect(null, x1, y1, 0, 0, {
                    "id": "selectorRubberBand",
                    "fill": "#22C",
                    "fill-opacity": "0.15",
                    "stroke": "#fff",
                    "stroke-width": "0.5",
                    "display": "none",
                    "style": "pointer-events:none"
                })
            } else {
                $svg.change(selectorRect, {
                    "x": x1,
                    "y": y1,
                    "width": 0,
                    "height": 0
                })
            }
        }

        function drawRect(evt) {
            if (!drawRect || evt.button != 0) {
                return
            }
            if ($.topology.ui.viewDragAction != $.topology.ui.VIEW_DRAG_ACTION_SELECT) {
                return
            }
            moved |= evt.dx | evt.dy;
            x2 = evt.x;
            y2 = evt.y;
            width = x2 - x1;
            height = y2 - y1;
            $svg.change(selectorRect, {
                "display": "block",
                "x": width >= 0 ? x1 : x1 + width,
                "y": height >= 0 ? y1 : y1 + height,
                "width": Math.abs(width),
                "height": Math.abs(height)
            })
        }

        function drawRectEnd(evt) {
            if (!drawRect) {
                return
            }
            $svg.change(selectorRect, {
                "display": "none"
            });
            if (!moved) {
                drawRect = false;
                return
            }
            var p1 = canvas.coordinateConvert.svg2Canvas(x1, y1);
            var p2 = canvas.coordinateConvert.svg2Canvas(x2, y2);
            var minX = Math.min(p1.x, p2.x),
                minY = Math.min(p1.y, p2.y),
                maxX = Math.max(p1.x, p2.x),
                maxY = Math.max(p1.y, p2.y);
            var viewScaleX = $.topology.view.fillScaleX,
                viewScaleY = $.topology.view.fillScaleY;
            minX /= viewScaleX;
            minY /= viewScaleY;
            maxX /= viewScaleX;
            maxY /= viewScaleY;
            var ids = [];
            var s = $.topology.shapes,
                o, iconBBox;
            for (var id in s["symbols"]) {
                o = s["symbols"][id];
                if (o.visible) {
                    iconBBox = o.getIconBBox();
                    if (isRectContaining([minX, minY, maxX, maxY], [iconBBox.minX, iconBBox.minY, iconBBox.maxX, iconBBox.maxY])) {
                        ids.push(id)
                    }
                }
            }
            for (var id in s["containers"]) {
                o = s["containers"][id];
                if (o.visible) {
                    iconBBox = o.getIconBBox();
                    if (isRectContaining([minX, minY, maxX, maxY], [iconBBox.minX, iconBBox.minY, iconBBox.maxX, iconBBox.maxY])) {
                        ids.push(id)
                    }
                }
            }
            if (ids.length > 0) {
                $.topology.selector.select(ids)
            }
            drawRect = false
        }

        function isRectIntersecting(r1, r2) {
            if ($.isArray(r1) && $.isArray(r2)) {
                var minX = Math.max(r1[0], r2[0]),
                    minY = Math.max(r1[1], r2[1]),
                    maxX = Math.min(r1[2], r2[2]),
                    maxY = Math.min(r1[3], r2[3]);
                return !(minX > maxX || minY > maxY)
            }
            return false
        }

        function isRectContaining(r1, r2) {
            if ($.isArray(r1) && $.isArray(r2)) {
                var offset = $ge.edgeDetect(r2, r1);
                return offset.x == 0 && offset.y == 0
            }
            return false
        }
    },
    bindViewFullScreenEvent: function(elementId) {
        if (!elementId || !this.event) {
            return
        }
        var eleId = String(elementId);
        this.event.add(eleId, "dblclick", fullScreenToggle);

        function fullScreenToggle() {
            var method = $.lab.menu.testFullScreen() ? "unfullScreen" : "fullScreen";
            $.lab.ui[method]()
        }
    },
    bindContainerExpandEvent: function(elementId) {
        if (!elementId || !this.event) {
            return
        }
        var eleId = String(elementId);
        // console.log(elementId+" has bindContainerExpandEvent " +
        // this.event.has(eleId, "dblclick", handleEvent))
        if (!this.event.has(eleId, "dblclick", handleEvent)) {
            this.event.add(eleId, "dblclick", handleEvent)
        }

        function handleEvent(e) {
            var container = $.topology.graphEngine.findModel(e.target.id);
            if (container && $.topology.isContainer(container)) {
                if (container.isPermit && !container.isExpand) {
                    container.expand();
                    container.change();
                    $.topology.selector.refresh()
                }
            }
        }
    },
    bindElementDbclickEvent: function(elementId) {
        // console.log("bindElementDbclickEvent " + elementId)
        if (!elementId || !this.event) {
            return
        }
        var eleId = String(elementId);
        if (!this.event.has(eleId, "dblclick", handleEvent)) {
            // console.log("has no " + eleId)
            this.event.add(eleId, "dblclick", handleEvent)
        }

        function handleEvent(e) {
            var element = $.topology.graphEngine.findModel(e.target.id);
            if (element.isDbclick) {
                if (element.isDbclick == "true" || element.isDbclick == true) {

                    if (element.dbclickType == "resource") {
                        var userId = $("#user_id").val();
                        var csrf = $("input[name='_csrf']").val();
                        $.ajax({
                            type: "post",
                            timeout: 60000, //超时时间设置，单位毫秒
                            url: ctx + "/monitor/permissionCheck.do?_csrf=" + csrf,
                            data: {
                                "user_id": userId,
                                "instanceId": element.dbclickRes
                            },
                            success: function(data) {
                                if ("1" == data) {
                                    window.open(ctx + "/monitor/resourceDetail.do?user_id=" + userId + "&instanceId=" + element.dbclickRes);
                                } else {
                                    layer.msg("您没有浏览资源详细信息的权限", { icon: 0 });
                                }
                            }
                        });
                    }
                    if (element.dbclickType == "url") {
                        window.open("http://" + element.dbclickRes)
                    }
                    if (element.dbclickType == "topo") {
                        window.open(ctx + "/network/topology/show.do?topoId=" + element.dbclickRes)
                    }
                }
            }
        }
    },
    bindTopologyShowEvents: function() {
        if (!this.event) {
            return
        }
        var $topo = $.topology,
            $ge = this,
            $event = this.event,
            plugin = $topo.config.plugin,
            typeConvert = TypeConvert();
        var _s = $.topology.shapes;
        for (var id in _s.symbols) {
            bindElementEvents(_s.symbols[id])
        }
        for (var id in _s.containers) {
            bindElementEvents(_s.containers[id])
        }
        for (var id in _s.lines) {
            bindElementEvents(_s.lines[id])
        }
        for (var id in _s.lineseters) {
            bindElementEvents(_s.lineseters[id])
        }

        function bindElementEvents(element) {
            var elementId;
            if (!element || !(elementId = element.id)) {
                return
            }
            var targetName = getElementPluginTargetName(element);
            if (!targetName) {
                return
            }
            var pluginEvents = getPluginEventsByTarget(targetName);
            if (!pluginEvents || $.isEmptyObject(pluginEvents)) {
                return
            }
            var ids = [];
            if ($topo.isSymbol(element)) {
                ids.push(elementId)
            } else {
                if ($topo.isContainer(element)) {
                    ids.push(elementId)
                } else {
                    if ($topo.isLine(element)) {
                        ids.push("wrap_" + elementId)
                    } else {
                        if ($topo.isLineseter(element)) {
                            ids.push("wrap_" + elementId)
                        }
                    }
                }
            }
            for (var type in pluginEvents) {
                var svgEventType = typeConvert.parseSvgEventName(type);
                if (svgEventType) {
                    for (var i in ids) {
                        $event.add(ids[i], svgEventType, handleEvent)
                    }
                }
            }
        }

        function handleEvent(e) {
            if (!e) {
                return
            }
            var target = e.target,
                eventType = e.type,
                element = $ge
                .findModel(target.id);
            if (!element) {
                return
            }
            var actions = getElementPluginEventActions(element, eventType);
            if (actions) {
                for (var i in actions) {
                    callFunction(actions[i], {
                        target: element,
                        pageX: e.pageX,
                        pageY: e.pageY
                    })
                }
            }
        }

        function getElementPluginEventActions(element, type) {
            if (!element || !type) {
                return null
            }
            var targetName = getElementPluginTargetName(element);
            if (!targetName) {
                return null
            }
            var pluginEvents = getPluginEventsByTarget(targetName);
            if (!pluginEvents || $.isEmptyObject(pluginEvents)) {
                return null
            }
            var pluginEventName = typeConvert.parseConfigEventName(type);
            var actionStr = pluginEvents[pluginEventName];
            return actionStr.split(";")
        }

        function getElementPluginTargetName(element) {
            return element && element.getObjectClass()
        }

        function getPluginEventsByTarget(target) {
            if (!target) {
                return null
            }
            var events = plugin[target];
            for (var type in events) {
                if (!type || !events[type]) {
                    delete events[type]
                }
            }
            return events
        }

        function getPluginEvents() {
            var types = [];
            var o, ts = {};
            for (var objectClass in plugin) {
                o = plugin[objectClass];
                for (var type in o) {
                    ts[type] = 1
                }
            }
            for (var type in ts) {
                types.push(type)
            }
            return types
        }

        function callFunction(actionName, params) {
            if (!actionName) {
                return
            }
            var tooltip = $.topology.ui.tooltip;
            switch (actionName) {
                case "showTooltip":
                    tooltip.show(params.target.id, params.pageX, params.pageY);
                    break;
                case "moveTooltip":
                    tooltip.move(params.target.id, params.pageX, params.pageY);
                    break;
                case "hideTooltip":
                    tooltip.hide(params.target.id);
                    break;
                case "openMainLink":
                    $.lab.direct.openMainLink(params.target);
                    break;
                default:
                    break
            }
        }

        function TypeConvert() {
            var typeMapper = {
                "CLICK": "click",
                "DBL_CLICK": "dblclick",
                "RIGHT_CLICK": "rightclick",
                "MOUSE_OVER": "mouseover",
                "MOUSE_OUT": "mouseout",
                "MOUSE_MOVE": "mousemove",
                "MOUSE_DOWN": "mousedown",
                "MOUSE_UP": "mouseup"
            };
            var svgEventMapper = {};
            for (var k in typeMapper) {
                var value = typeMapper[k];
                if (!svgEventMapper[value]) {
                    svgEventMapper[value] = []
                }
                svgEventMapper[value].push(k)
            }

            function parseConfigEventNames(svgEventName) {
                return svgEventMapper && svgEventMapper[svgEventName]
            }

            function parseSvgEventName(configEventName) {
                return configEventName && typeMapper[configEventName]
            }
            return {
                parseConfigEventName: parseConfigEventNames,
                parseSvgEventName: parseSvgEventName
            }
        }
    },
    bindContainerCollapseEvent: function(elementId) {
        if (!elementId || !this.event) {
            return
        }
        var eleId = String(elementId);
        if (!this.event.has(eleId, "dblclick", handleEvent)) {
            this.event.add(eleId, "dblclick", handleEvent)
        }

        function handleEvent(e) {
            var $topo = $.topology,
                container = $topo.graphEngine
                .findModel(e.target.id);
            if (container && $topo.isContainer(container)) {
                if (container.isPermit && container.isExpand) {
                    container.collapse();
                    container.change();
                    $topo.selector.refresh()
                }
            }
        }
    },
    bindLineRemoveToolToggleEvent: function() {
        var $ge = this,
            $svg = $ge.svg,
            $event = $ge.event;
        $($.topology).off("selectElement.lineRemove").on("selectElement.lineRemove", function() {
            var $selector = $.topology.selector,
                lastSelectedLine = []
                .concat($selector.lastSelected().lines),
                selectedLine = []
                .concat($selector.selected().lines);
            if (selectedLine.length == 1) {
                $(lastSelectedLine).each(function(i, lineId) {
                    if (!$selector.contains(lineId)) {
                        setTimeout(function() {
                            deleteRemoveTool(lineId)
                        }, 10)
                    }
                });
                $(selectedLine).each(function(i, lineId) {
                    setTimeout(function() {
                        renderRemoveTool(lineId)
                    }, 10)
                })
            } else {
                $(lastSelectedLine).each(function(i, lineId) {
                    setTimeout(function() {
                        deleteRemoveTool(lineId)
                    }, 10)
                })
            }
        });

        function renderRemoveTool(lineId) {
            if ($.topology.status === "EDIT") {
                var toolsBlock = $svg.getElementById("coverage_75"),
                    removeToolBlockId = "block_tool_remove_" + lineId,
                    removeToolPath = "M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z",
                    removeToolBlock = $svg.getElementById(removeToolBlockId),
                    removeToolId = "tool_remove_" + lineId,
                    removeToolAreaId = "tool_remove_area_" + lineId;
                if (removeToolBlock) {
                    return
                }
                removeToolBlock = $svg.group(toolsBlock, removeToolBlockId);
                $svg.change(removeToolBlock, {
                    transform: "translate(50, 50)"
                });
                $svg.circle(removeToolBlock, 0, 0, 11, {
                    id: removeToolAreaId,
                    fill: "red",
                    cursor: "pointer",
                    transform: "scale(.8)"
                });
                $svg.path(removeToolBlock, removeToolPath, {
                    id: removeToolId,
                    fill: "white",
                    cursor: "pointer",
                    transform: "scale(.8) scale(.8) translate(-16, -16)"
                });
                $svg.title(removeToolBlock, "删除");
                $ge.updateLineToolsPosition($ge.findModel(lineId));
                $event.add([removeToolId, removeToolAreaId], "click", function(e) {
                    var title = "提示";
                    var content = "当前操作不可恢复，是否确认删除？";
                    openquestionwindow(title, content, function() {
                        var line = $ge.findModel(e.target.id);
                        if (line) {
                            line.remove()
                        }
                        deleteRemoveTool(lineId)
                        $.topology.saveTopo();
                        closeWindow();
                    })
                })
            }
        }

        function deleteRemoveTool(lineId) {
            $ge.remove("block_tool_remove_" + lineId)
        }
    },
    bindLineCollapseToggleEvent: function(elementId) {
        if (!elementId || !this.event) {
            return
        }
        var eleId = String(elementId);
        if (!this.event.has(eleId, "dblclick", handleEvent)) {
            this.event.add(eleId, "dblclick", handleEvent)
        }

        function handleEvent(e) {
            var $topo = $.topology,
                $selector = $topo.selector;
            line = $topo.graphEngine.findModel(e.target.id);
            if (!line) {
                return
            }
            if ($topo.isLine(line)) {
                var parent = line.parent;
                if (parent) {
                    parent.collapse();
                    $selector.reset()
                }
            } else {
                if ($topo.isLineseter(line)) {
                    line.expand();
                    if ($selector.contains(line.id)) {
                        $selector.reset()
                    }
                }
            }
        }
    },
    bindNodeDragEvent: function(elementId) {
        if (!elementId || !this.event) {
            return
        }
        var event = this.event;
        var eleId = String(elementId);
        if (!event.has(eleId, "dragstart", dragNodeStart)) {
            event.add(eleId, "dragstart", dragNodeStart);
            event.add(eleId, "drag", dragNode);
            event.add(eleId, "dragend", dragNodeEnd)
        }
        var element = null,
            id = null,
            moved = 0,
            draggable = false,
            $topo = null,
            $ge = this,
            $selector = null,
            canvas = this.canvas,
            canvasGrid = this.canvasGrid,
            scale = null,
            symbols = null,
            containers = null,
            nodes = [],
            o = null,
            startMousePoint = null,
            mouseDistance = null,
            lineseterExpandMap = null;

        function dragNodeStart(evt) {
            moved = 0;
            draggable = false;
            mouseDistance = null;
            symbols = null;
            containers = null;
            lineseterExpandMap = null;
            if (!$topo) {
                $topo = $.topology;
                $selector = $topo.selector
            }
            if (evt.button == 0) {
                element = $ge.findModel(evt.target.id);
                if (element) {
                    draggable = true;
                    startMousePoint = canvas.coordinateConvert.page2Canvas(evt.pageX, evt.pageY);
                    id = element.id
                }
            }
        }

        function collapseSymbolLineseter(symbol) {
            if (!symbol) {
                return
            }
            var lines = symbol.lines;
            for (var k in lines) {
                var line = lines[k];
                if (line.state == 1 && $topo.isLineseter(line)) {
                    if (line.isExpand) {
                        lineseterExpandMap[line.id] = line.isExpand;
                        line.collapse()
                    }
                }
            }
        }

        function snapToGrid(value) {
            var gridSize = canvasGrid.getGridSize() / $topo.view.scale();
            var stepSize = gridSize / 2;
            value = Math.round(value / stepSize) * stepSize;
            return value
        }

        function getNodesMaxBBox(nodes) {
            var bbox, bboxs = [],
                o;
            for (var i = 0; i < nodes.length; i++) {
                o = nodes[i];
                bbox = $.extend({}, o.getBBox());
                if (o.parent) {
                    var parentPadding = o.parent.getExpandPadding();
                    bbox.minX -= parentPadding.left;
                    bbox.minY -= parentPadding.top;
                    bbox.maxX += parentPadding.right;
                    bbox.maxY += parentPadding.bottom
                }
                bboxs.push(bbox)
            }
            return $topo.getMaxBBox(bboxs)
        }

        function dragNode(evt) {
            if (!draggable || !id) {
                return
            }
            if (!symbols) {
                var symbolIds = $selector.symbols();
                var containerIds = $selector.containers();
                symbols = [];
                containers = [];
                for (var i = 0, len = symbolIds.length; i < len; i++) {
                    o = $topo.find(symbolIds[i]);
                    if (o) {
                        symbols.push(o)
                    }
                }
                for (var i = 0, len = containerIds.length; i < len; i++) {
                    o = $topo.find(containerIds[i]);
                    if (o) {
                        containers.push(o)
                    }
                }
                nodes = symbols.concat(containers);
                if (!nodes.length) {
                    draggable = false;
                    return
                }
                lineseterExpandMap = {};
                for (var i = 0; i < symbols.length; i++) {
                    o = symbols[i];
                    $ge.coverage.dragNode(o);
                    collapseSymbolLineseter(o)
                }
                var containerChildren, child;
                for (var i = 0; i < containers.length; i++) {
                    o = containers[i];
                    if (!o.isExpand) {
                        continue
                    }
                    containerChildren = o.children;
                    for (var sid in containerChildren) {
                        child = containerChildren[sid];
                        collapseSymbolLineseter(child)
                    }
                }
            }
            var nodesIconBbox = $topo.getNodesIconBBox(nodes);
            if (!mouseDistance) {
                mouseDistance = {
                    left: startMousePoint.x - nodesIconBbox.minX,
                    top: startMousePoint.y - nodesIconBbox.minY,
                    right: nodesIconBbox.maxX - startMousePoint.x,
                    bottom: nodesIconBbox.maxX - startMousePoint.x
                }
            }
            var mousePoint = canvas.coordinateConvert.page2Canvas(evt.pageX, evt.pageY);
            var currNodeMinX = mousePoint.x - mouseDistance.left,
                currNodeMinY = mousePoint.y - mouseDistance.top;
            if ($topo.config.gridSnapping) {
                currNodeMinX = snapToGrid(currNodeMinX);
                currNodeMinY = snapToGrid(currNodeMinY)
            }
            var dx = currNodeMinX - nodesIconBbox.minX;
            var dy = currNodeMinY - nodesIconBbox.minY;
            var viewBox = $topo.view.getViewBox();
            var nodesBbox = getNodesMaxBBox(nodes);
            if (nodesBbox.minX + dx < viewBox.x) {
                dx = viewBox.x - nodesBbox.minX
            } else {
                if (nodesBbox.maxX + dx > viewBox.x + viewBox.width) {
                    dx = viewBox.x + viewBox.width - nodesBbox.maxX
                }
            }
            if (nodesBbox.minY + dy < viewBox.y) {
                dy = viewBox.y - nodesBbox.minY
            } else {
                if (nodesBbox.maxY + dy > viewBox.y + viewBox.height) {
                    dy = viewBox.y + viewBox.height - nodesBbox.maxY
                }
            }
            moved |= dx | dy;
            $topo.view.moveNodes(nodes, dx, dy);
            $selector.refresh()
        }

        function dragNodeEnd(evt) {
            if (!draggable) {
                return
            }
            draggable = false;
            if (moved) {
                var currentContainer = null,
                    symbolHasParent = false;
                for (var i = 0; i < symbols.length; i++) {
                    o = symbols[i];
                    if (o && o.parent) {
                        symbolHasParent = true;
                        break
                    }
                }
                if (!symbolHasParent && symbols.length > 0 && containers.length == 0) {
                    var mousePoint = canvas.coordinateConvert.page2Canvas(evt.pageX, evt.pageY),
                        mouseOffset = $ge.pointCanvasEdgeDetect(mousePoint.x, mousePoint.y);
                    if (mouseOffset.x == 0 && mouseOffset.y == 0) {
                        var viewContainers = $topo.shapes.containers,
                            nodeBbox;
                        for (var k in viewContainers) {
                            o = viewContainers[k];
                            if (!o) {
                                continue
                            }
                            nodeBbox = o.getBBox();
                            if (mousePoint.x >= nodeBbox.minX && mousePoint.x <= nodeBbox.maxX && mousePoint.y >= nodeBbox.minY && mousePoint.y <= nodeBbox.maxY) {
                                currentContainer = o;
                                break
                            }
                        }
                    }
                }
                if (lineseterExpandMap) {
                    for (var lid in lineseterExpandMap) {
                        o = $topo.find(lid);
                        if (!o) {
                            continue
                        }
                        o.expand()
                    }
                }
                if (currentContainer) {
                    for (var i = 0; i < symbols.length; i++) {
                        o = symbols[i];
                        currentContainer.addChild(o, true);
                        currentContainer.edgeDetect();
                        currentContainer.change()
                    }
                }
                $topo.view.moveNodesStop(nodes)
            }
            $selector.refresh()
        }
    },
    moveView: function(x, y) {
        this.canvas.move(x, y)
    },
    applySymbolTransform: function(symbol) {
        var block = this.findBlock(String(symbol.id));
        var transX = symbol.translate.x,
            transY = symbol.translate.y;
        this.applySVGElementTransform(block, transX, transY)
    },
    applyContainerTransform: function(container) {},
    applySVGElementTransform: function(element, transX, transY) {
        if (element) {
            element.setAttribute("transform", "translate(" + transX + ", " + transY + ")")
        }
    },
    clearSVGElementTransform: function(element) {
        if (element) {
            element.removeAttribute("transform")
        }
    }
};
// /hy.topology.engine.SVGEvent
hy.topology.engine.SVGEvent = function(container, svg) {
    var svgevent = {},
        eventPool = null,
        eventTypes = "click dblclick rightclick leftcick mousedown mouseup mousemove mouseover mouseout drag dragstart dragend",
        eventBindState = {},
        svgRoot;
    svgevent.init = function() {
        svgRoot = svg.root();
        eventBindState = {};
        svgevent.reset();
        container[0].ondragstart = function() {
            return false
        };
        container[0].onclick = function() {
            return false
        };
        svgRoot.addEventListener("mousedown", function(e) {
            e.preventDefault();
            return false
        }, false)
    };
    svgevent.reset = function() {
        eventPool = new EventPool()
    };
    svgevent.add = function(elementIds, eventType, listeners) {
        if (typeof elementIds === "object" && !$.isArray(elementIds)) {
            if (!$.isArray(listeners)) {
                listeners = [listeners]
            }
            for (var i in listeners) {
                elementIds.addEventListener(eventType, listeners[i], false)
            }
        } else {
            eventPool.add(elementIds, eventType, listeners);
            bindRootElementEvent(eventType)
        }
    };
    svgevent.remove = function(elementId, eventType, listener) {
        if (arguments.length == 1) {
            eventPool.remove(elementId)
        } else {
            if (arguments.length == 2) {
                eventPool.remove(elementId, eventType)
            } else {
                if (arguments.length == 3) {
                    if (typeof elementId === "object") {
                        elementId.removeEventListener(eventType, listener, false)
                    } else {
                        eventPool.remove(elementId, eventType, listener)
                    }
                }
            }
        }
    };
    svgevent.has = function(elementId, eventType, listener) {
        if (arguments.length == 2) {
            return eventPool.has(elementId, eventType)
        } else {
            if (arguments.length == 3) {
                return eventPool.has(elementId, eventType, listener)
            }
        }
    };
    svgevent.replaceId = function(oldId, newId) {
        if (arguments.length !== 2) {
            return
        }
        eventPool.replaceId(oldId, newId)
    };

    function bindRootElementEvent(eventType) {
        if (eventBindState[eventType]) {
            return
        }
        switch (eventType) {
            case "click":
            case "mousedown":
            case "mouseup":
            case "mousemove":
            case "mouseover":
            case "mouseout":
            case "focusin":
            case "focusout":
            case "keydown":
            case "keypress":
            case "keyup":
                svgRoot.addEventListener(eventType, handleEvent, false);
                eventBindState[eventType] = true;
                break;
            case "dblclick":
                bindSvgDblclickEvent(handleEvent);
                eventBindState[eventType] = true;
                break;
            case "leftclick":
                bindSvgLeftclickEvent(handleEvent);
                eventBindState[eventType] = true;
                break;
            case "rightclick":
                bindSvgRightclickEvent(handleEvent);
                eventBindState[eventType] = true;
                break;
            case "drag":
            case "dragstart":
            case "dragend":
                bindSvgDragEvent(handleEvent, handleEvent, handleEvent);
                eventBindState["drag"] = true;
                eventBindState["dragstart"] = true;
                eventBindState["dragend"] = true;
                break;
            default:
                break
        }
    }

    function handleEvent(evt) {
        var type = evt.type;
        var id = evt.target.id;
        if (!evt.pageX) {
            var offset = svgOffset();
            evt.pageX = evt.clientX + offset.left;
            evt.pageY = evt.clientY + offset.top
        }
        eventPool.fire(id, type, evt);
        eventPool.fire("*", type, evt)
    }

    function bindSvgDblclickEvent(listener) {
        if (document.addEventListener) {
            svgRoot.addEventListener("dblclick", listener, false)
        } else {
            svgRoot.addEventListener("click", click, false);

            function click(evt) {
                if (evt.button == 0 && evt.detail == 2) {
                    var e = {};
                    $.extend(e, evt);
                    e.type = "dblclick";
                    listener.call(null, e)
                }
            }
        }
    }

    function bindSvgLeftclickEvent(listener) {
        svgRoot.addEventListener("click", click, false);

        function click(evt) {
            if (evt.button == 0) {
                var e = {};
                $.extend(e, evt);
                e.type = "leftclick";
                listener.call(null, e)
            }
        }
    }

    function bindSvgRightclickEvent(listener) {
        svgRoot.addEventListener("mouseup", click, false);

        function click(evt) {
            if (evt.button == 2) {
                var e = {};
                $.extend(e, evt);
                e.type = "rightclick";
                listener.call(null, e)
            }
        }
    }

    function point(e) {
        var x, y;
        if (typeof e.pageX === "undefined") {
            var offset = svgOffset();
            x = e.clientX + offset.left;
            y = e.clientY + offset.top
        } else {
            x = e.pageX;
            y = e.pageY
        }
        return [x, y]
    }

    function svgOffset() {
        return container.offset()
    }

    function bindSvgDragEvent(dragListener, dragstartListener, dragendListener) {
        svgRoot.addEventListener("mousedown", mousedown, false);
        var isSvgMousedown = true;
        if (!window.addEventListener) {
            $(document).on("mousedown", function(e) {
                isSvgMousedown = e.target.tagName == "EMBED"
            })
        }

        function mousedown(evt) {
            if (!isSvgMousedown) {
                return
            }
            var target = evt.target,
                evtButton = evt.button,
                origin = point(evt),
                svgElementOffset = svgOffset(),
                offset = [svgElementOffset.left, svgElementOffset.top],
                moved = 0;
            $("body").addClass("dragselect").on("selectstart", shieldSelect);
            if (window.addEventListener) {
                window.addEventListener("mousemove", dragmove, false);
                window.addEventListener("mouseup", dragend, true)
            } else {
                $(document).on("mousemove", dragmove);
                $(document).on("mouseup", dragend)
            }
            if ($.isFunction(dragstartListener)) {
                var e = {};
                e = $.extend(e, evt);
                e = $.extend(e, {
                    type: "dragstart",
                    button: evtButton,
                    target: target,
                    pageX: origin[0],
                    pageY: origin[1],
                    x: origin[0] - offset[0],
                    y: origin[1] - offset[1]
                });
                dragstartListener.call(null, e);
                if (!eventPool.has(target.id, "dragstart")) {
                    return
                }
            }

            function dragmove(evt) {
                var p = point(evt),
                    dx = p[0] - origin[0],
                    dy = p[1] - origin[1];
                moved |= dx | dy;
                origin = p;
                if ($.isFunction(dragListener)) {
                    var e = {};
                    e = $.extend(e, evt);
                    e = $.extend(e, {
                        type: "drag",
                        button: evtButton,
                        target: target,
                        currentTarget: evt.target,
                        pageX: p[0],
                        pageY: p[1],
                        x: p[0] - offset[0],
                        y: p[1] - offset[1],
                        dx: dx,
                        dy: dy
                    });
                    dragListener.call(null, e)
                }
            }

            function dragend(evt) {
                if ($.isFunction(dragendListener)) {
                    var e = {};
                    e = $.extend(e, evt);
                    e = $.extend(e, {
                        type: "dragend",
                        button: evtButton,
                        target: target,
                        pageX: evt.pageX,
                        pageY: evt.pageY
                    });
                    dragendListener.call(null, e)
                }
                $("body").removeClass("dragselect").off("selectstart", shieldSelect);
                if (window.removeEventListener) {
                    window.removeEventListener("mousemove", dragmove, false);
                    window.removeEventListener("mouseup", dragend, true)
                } else {
                    $(document).off("mousemove", dragmove);
                    $(document).off("mouseup", dragend)
                }
            }
        }

        function shieldSelect() {
            return false
        }
    }

    function EventPool() {
        var eventpool = {},
            series = {};
        eventpool.add = function(ids, type, _callbacks) {
            if (arguments.length != 3 || typeof type !== "string") {
                return
            }
            if (typeof ids === "string") {
                ids = [ids]
            }
            if (!$.isArray(ids)) {
                return
            }
            var callbacks = $.isArray(_callbacks) ? _callbacks : [_callbacks];
            if (!series[type]) {
                series[type] = []
            }
            var l = callbacks.length;
            var callback, index, idStr;
            for (var i = 0; i < l; i++) {
                callback = callbacks[i];
                if (typeof callback !== "string" && !$.isFunction(callback)) {
                    continue
                }
                index = getIndexOfCallback(type, callback);
                idStr = "";
                if (index == -1) {
                    idStr = "," + ids.join(",") + ",";
                    idStr = idStr.replace(new RegExp(",,", "g"), ",");
                    series[type].push([callback, idStr])
                } else {
                    var idsOld = series[type][index][1];
                    idStr = idsOld + ids.join(",") + ",";
                    idStr = idStr.replace(new RegExp(",,", "g"), ",");
                    series[type][index][1] = idStr
                }
            }
        };

        function getIndexOfCallback(type, callback) {
            if (series[type]) {
                var l = series[type].length;
                for (var i = 0; i < l; i++) {
                    var c = series[type][i] && series[type][i][0];
                    if (c == callback) {
                        return i
                    }
                }
            }
            return -1
        }

        function findCallbacksByTypeAndId(type, id) {
            if (typeof type !== "string" || typeof id !== "string" || id.length == 0 || !series[type] || series[type].length == 0) {
                return null
            }
            var callbacks = null;
            var l = series[type].length;
            for (var i = 0; i < l; i++) {
                var idStr = series[type][i][1];
                if (isExistsInIds(idStr, id)) {
                    if (!callbacks) {
                        callbacks = []
                    }
                    callbacks.push(series[type][i][0])
                }
            }
            return callbacks
        }

        function isExistsInIds(idStr, id) {
            return idStr.split("," + id + ",").length > 1
        }

        function isExistsId(type, id) {
            if (series[type]) {
                var l = series[type].length;
                for (var i = 0; i < l; i++) {
                    var idStr = series[type][i][1];
                    if (isExistsInIds(idStr, id)) {
                        return true
                    }
                }
            }
            return false
        }
        eventpool.disable = function(ids, type) {};
        eventpool.empty = function(ids, type) {};
        eventpool.fire = function(id, type, args) {
            var callbacks = findCallbacksByTypeAndId(type, id),
                len;
            if (!callbacks || (len = callbacks.length) == 0) {
                return
            }
            var callback;
            for (var i = 0; i < len; i++) {
                callback = callbacks[i];
                if (typeof callback === "string") {
                    callback = eval(callback)
                }
                if ($.isFunction(callback)) {
                    callback.call(null, args)
                }
            }
        };
        eventpool.has = function(id, type, callback) {
            if (arguments.length == 1) {} else {
                if (arguments.length == 2) {
                    return isExistsId(type, id)
                } else {
                    if (arguments.length == 3) {
                        var index = getIndexOfCallback(type, callback);
                        if (index == -1) {
                            return false
                        }
                        var idStr = series[type][index][1];
                        return isExistsInIds(idStr, id)
                    }
                }
            }
        };
        eventpool.remove = function(id, _type, callback) {
            if (arguments.length == 1) {
                var callbacks, len, i;
                for (type in series) {
                    callbacks = findCallbacksByTypeAndId(type, id);
                    if (!callbacks || (len = callbacks.length) == 0) {
                        continue
                    }
                    for (i = 0; i < len; i++) {
                        eventpool.remove(id, type, callbacks[i])
                    }
                }
            } else {
                if (arguments.length == 3) {
                    var type = _type;
                    if (!series[type]) {
                        return
                    }
                    var l = series[type].length;
                    for (var i = 0; i < l; i++) {
                        if (!series[type][i] || series[type][i][0] !== callback) {
                            continue
                        }
                        var idStr = series[type][i][1];
                        if (idStr && isExistsInIds(idStr, id)) {
                            if (idStr != "," + id + ",") {
                                idStr = idStr.replace(
                                    new RegExp("," + id, "g"), "")
                            } else {
                                idStr = ""
                            }
                            if (idStr.length > 0) {
                                series[type][i][1] = idStr
                            } else {
                                series[type].splice(i, 1)
                            }
                        }
                    }
                }
            }
        };
        eventpool.replaceId = function(oldId, newId) {
            if (arguments.length !== 2) {
                return
            }
            oldId = String(oldId);
            newId = String(newId);
            var callbacks, len, i;
            for (var type in series) {
                callbacks = findCallbacksByTypeAndId(type, oldId);
                if (!callbacks || (len = callbacks.length) == 0) {
                    continue
                }
                for (i = 0; i < len; i++) {
                    eventpool.add(newId, type, callbacks[i]);
                    eventpool.remove(oldId, type, callbacks[i])
                }
            }
        };
        return eventpool
    }
    return svgevent
};
// /hy.topology.engine.SVGCanvas
hy.topology.engine.SVGCanvas = function(container, svg, rootId) {
    var svgcanvas = {},
        zoomOnScroll = true,
        zoomMax = 8,
        zoomMin = 0.5,
        rootElement = null,
        scale = 1,
        transX = 0,
        transY = 0,
        baseScale = 1,
        baseTransX = 0,
        baseTransY = 0,
        width = 0,
        height = 0,
        bbox = null;
    svgcanvas.init = function() {
        svgcanvas.reset();
        svgcanvas.updateSize();
        svgcanvas.bindContainerEvents()
    };
    svgcanvas.reset = function() {
        rootElement = svg.getElementById(rootId);
        scale = 1;
        transX = 0;
        transY = 0;
        baseScale = 1;
        baseTransX = 0;
        baseTransY = 0;
        width = 0;
        height = 0;
        bbox = null
    };
    svgcanvas.resize = function() {
        var curBaseScale = baseScale;

        if (width / height > bbox.width / bbox.height) {
            baseScale = height / bbox.height;
            baseTransX = Math.abs(width - bbox.width * baseScale) / (2 * baseScale)
        } else {
            baseScale = width / bbox.width;
            baseTransY = Math.abs(height - bbox.height * baseScale) / (2 * baseScale)
        }
        scale *= baseScale / curBaseScale;
        transX *= baseScale / curBaseScale;
        transY *= baseScale / curBaseScale
    };
    svgcanvas.setSize = function() {
        width = container.width();
        height = container.height();
        $(svg.root()).attr("width", width);
        $(svg.root()).attr("height", height);
        svgcanvas.updateBBox();
        svgcanvas.resize();
        svgcanvas.applyTransform()
    };
    svgcanvas.updateSize = function() {
        svgcanvas.setSize();
        $(svgcanvas).triggerHandler("canvasResize")
    };
    svgcanvas.updateCanvas = function() {
        svgcanvas.updateBBox();
        svgcanvas.resize();
        svgcanvas.applyTransform()
    };
    svgcanvas.fitToCanvas = function() {
        svgcanvas.updateBBox();
        svgcanvas.viewport(bbox.x, bbox.y, bbox.width, bbox.height)
    };
    svgcanvas.width = function() {
        return width
    };
    svgcanvas.height = function() {
        return height
    };
    svgcanvas.updateBBox = function() {
        bbox = getViewElementBBox();

        function getViewElementBBox() {
            return svg.getElementById("view_background").getBBox()
        }
    };
    svgcanvas.bbox = function() {
        return bbox
    };
    svgcanvas.offset = function() {
        return getSvgOffset();

        function getSvgOffset() {
            return container.offset()
        }
    };
    svgcanvas.translate = function() {
        return {
            x: transX,
            y: transY
        }
    };
    svgcanvas.bindContainerEvents = function() {
        if (container.attr("svgcanvas-event")) {
            return
        }
        container.attr("svgcanvas-event", "true");
        container.resize(function() {
            svgcanvas.updateSize()
        });
        if (zoomOnScroll) {
            container.mousewheel(function(event, delta, deltaX, deltaY) {
                if (isNaN(delta)) {
                    return

                }
                var p = svgcanvas.coordinateConvert.page2Svg(event.pageX, event.pageY);
                centerX = p.x, centerY = p.y;
                zoomStep = Math.pow(1.1, delta);
                svgcanvas.scale(scale * zoomStep, centerX, centerY);
                event.preventDefault()
            })
        }
    };
    svgcanvas.bindContainerTouchEvents = function() {};
    svgcanvas.scale = function(_scale, anchorX, anchorY, isCentered) {
        if (!arguments.length) {
            return scale
        }
        if (_scale > zoomMax * baseScale) {
            _scale = zoomMax * baseScale
        } else {
            if (_scale < zoomMin * baseScale) {
                _scale = zoomMin * baseScale
            }
        }
        if (typeof anchorX != "undefined" && typeof anchorY != "undefined") {
            if (isCentered) {
                transX = anchorX + bbox.width * (width / (bbox.width * _scale)) / 2;
                transY = anchorY + bbox.height * (height / (bbox.height * _scale)) / 2
            } else {
                var zoomStep = _scale / scale;
                transX -= (zoomStep - 1) / _scale * anchorX;
                transY -= (zoomStep - 1) / _scale * anchorY
            }
        }
        scale = _scale;
        svgcanvas.applyTransform()
    };
    svgcanvas.applyTransform = function() {
        svgcanvas.updateBBox();
        var maxTransX, maxTransY, minTransX, minTransY;
        if (bbox.width * scale <= width) {
            maxTransX = (width - bbox.width * scale) / (2 * scale);
            minTransX = (width - bbox.width * scale) / (2 * scale)
        } else {
            maxTransX = 0;
            minTransX = (width - bbox.width * scale) / scale
        }
        if (bbox.height * scale <= height) {
            maxTransY = (height - bbox.height * scale) / (2 * scale);
            minTransY = (height - bbox.height * scale) / (2 * scale)
        } else {
            maxTransY = 0;
            minTransY = (height - bbox.height * scale) / scale
        }
        if (transX > maxTransX) {
            transX = maxTransX
        } else {
            if (transX < minTransX) {
                transX = minTransX
            }
        }
        if (transY > maxTransY) {
            transY = maxTransY
        } else {
            if (transY < minTransY) {
                transY = minTransY
            }
        }

        applyTransformParams(scale, transX, transY); // 放大缩小属性
        $(svgcanvas).triggerHandler("change", {
            scale: scale
        })
    };

    function applyTransformParams(scale, transX, transY) { // 放大缩小属性
        rootElement.setAttribute("transform", "scale(" + scale + ") translate(" + transX + ", " + transY + ")")
    }
    svgcanvas.move = function(x, y) {
        var w = bbox.width * scale;
        var h = bbox.height * scale;
        if (w <= width) {
            x = 0
        }
        if (h <= height) {
            y = 0
        }
        if ((x == 0 && y == 0) || !svgcanvas.isMoveEnabled()) {
            return
        }
        transX += +x;
        transY += +y;
        svgcanvas.applyTransform()
    };
    svgcanvas.isMoveEnabled = function() {
        return svgcanvas.isMoveHorizontalEnabled() || svgcanvas.isMoveVerticalEnabled()
    };
    svgcanvas.isMoveHorizontalEnabled = function() {
        return bbox.width * scale > width
    };
    svgcanvas.isMoveVerticalEnabled = function() {
        return bbox.height * scale > height
    };

    function getViewport() {
        var x, y, w = bbox.width * scale,
            h = bbox.height * scale;
        if (w <= width) {
            x = bbox.x;
            w = bbox.width
        } else {
            x = bbox.x - transX;
            w = width / scale
        }
        if (h <= height) {
            y = bbox.y;
            h = bbox.height
        } else {
            y = bbox.y - transY;
            h = height / scale
        }
        return {
            x: x,
            y: y,
            width: w,
            height: h
        }
    }
    svgcanvas.viewport = function(x, y, _width, _height) {
        if (!arguments.length) {
            return getViewport()
        } else {
            if (arguments.length != 4) {
                return
            }
        }
        svgcanvas.updateBBox();
        x = Number(x);
        y = Number(y);
        _width = Number(_width);
        _height = Number(_height);
        if (x < bbox.x) {
            x = bbox.x
        }
        if (y < bbox.y) {
            y = bbox.y
        }
        if (_width > bbox.width) {
            _width = bbox.width
        }
        if (_height > bbox.height) {
            _height = bbox.height
        }
        svgcanvas.scale(Math.min(width / _width, height / _height), -(x + _width / 2), -(y + _height / 2), true)
    };
    svgcanvas.coordinateConvert = function() {
        function page2Svg(px, py) {
            var svgOffset = svgcanvas.offset();
            return {
                x: px - svgOffset.left,
                y: py - svgOffset.top
            }
        }

        function svg2Canvas(sx, sy) {
            return {
                x: sx / scale - transX,
                y: sy / scale - transY
            }
        }

        function page2Canvas(px, py) {
            var temp = page2Svg(px, py);
            return svg2Canvas(temp.x, temp.y)
        }

        function canvas2Page(cx, cy) {
            var t = canvas2Svg(cx, cy);
            return svg2Page(t.x, t.y)
        }

        function canvas2Svg(cx, cy) {
            return {
                x: (cx + transX) * scale,
                y: (cy + transY) * scale
            }
        }

        function svg2Page(sx, sy) {
            var svgOffset = svgcanvas.offset();
            return {
                x: sx + svgOffset.left,
                y: sy + svgOffset.top
            }
        }
        return {
            svg2Page: svg2Page,
            page2Svg: page2Svg,
            svg2Canvas: svg2Canvas,
            page2Canvas: page2Canvas,
            canvas2Svg: canvas2Svg,
            canvas2Page: canvas2Page
        }
    }();
    return svgcanvas
};
// /hy.topology.engine.SVGCoordsConvert
hy.topology.engine.SVGCoordsConvert = function(view, canvas) {
    var canvasCoordsConvert = canvas.coordinateConvert;

    function canvas2View(coords) {
        return {
            x: coords.x / view.fillScaleX,
            y: coords.y / view.fillScaleY
        }
    }

    function view2Canvas(coords) {
        return {
            x: coords.x * view.fillScaleX,
            y: coords.y * view.fillScaleY
        }
    }

    function svg2Canvas(coords) {
        return canvasCoordsConvert.svg2Canvas(coords.x, coords.y)
    }

    function canvas2Svg(coords) {
        return canvasCoordsConvert.canvas2Svg(coords.x, coords.y)
    }

    function page2Svg(coords) {
        return canvasCoordsConvert.page2Svg(coords.x, coords.y)
    }

    function svg2Page(coords) {
        return canvasCoordsConvert.svg2Page(coords.x, coords.y)
    }

    function page2Canvas(coords) {
        return canvasCoordsConvert.page2Canvas(coords.x, coords.y)
    }

    function svg2View(coords) {
        var canvasCoords = svg2Canvas(coords);
        return canvas2View(canvasCoords)
    }

    function view2Svg(coords) {
        var canvasCoords = view2Canvas(coords);
        return canvas2Svg(canvasCoords)
    }

    function page2View(coords) {
        var svgCoords = page2Svg(coords);
        return svg2View(svgCoords)
    }

    function view2Page(coords) {
        var svgCoords = view2Svg(coords);
        return svg2Page(svgCoords)
    }
    var converts = {
        page: {
            svg: page2Svg,
            canvas: page2Canvas,
            view: page2View
        },
        svg: {
            page: svg2Page,
            view: svg2View
        },
        view: {
            page: view2Page,
            svg: view2Svg,
            canvas: view2Canvas
        }
    };
    return function(opts) {
        try {
            return converts[opts.from][opts.to](opts.coords)
        } catch (e) {
            return opts ? opts.coords : null
        }
    }
};
// /hy.topology.engine.SVGCanvasGrid
hy.topology.engine.SVGCanvasGrid = function() {
    var canvasgrid = {},
        hcanvas = null,
        $topo = null,
        $ge = null,
        $svg = null,
        $defs = null,
        svgdoc = null,
        canvBG = null,
        grid = null,
        gridImg = null,
        showGrid = false,
        initialized = false,
        gridColor = "#eee";
    intervals = [0.01, 0.1, 1, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 2000, 3000];

    function removeGrid() {
        if (canvBG) {
            $svg.remove(canvBG);
            canvBG = null
        }
    }

    function addGrid() {
        if (canvBG) {
            return
        }
        canvBG = svgdoc.createElementNS($.svg.svgNS, "svg");
        $svg.change(canvBG, {
            "id": "canvasBackground",
            "x": 0,
            "y": 0
        });
        var viewBG = $svg.getElementById($topo.view.id);
        var v = viewBG.cloneNode(true);
        $svg.change(v, {
            "id": "canvasBackgroundImg",
            "x": 0,
            "y": 0,
            "width": "100%",
            "height": "100%",
            "preserveAspectRatio": "none meet"
        });
        canvBG.appendChild(v);
        $svg.getElementById("background").appendChild(canvBG);
        grid = svgdoc.createElementNS($.svg.svgNS, "svg");
        $svg.change(grid, {
            "id": "canvasGrid",
            "width": "100%",
            "height": "100%",
            "x": 0,
            "y": 0,
            "overflow": "visible"
        });
        canvBG.appendChild(grid);
        var gridPattern = svgdoc.createElementNS($.svg.svgNS, "pattern");
        $svg.change(gridPattern, {
            "id": "gridpattern",
            "patternUnits": "userSpaceOnUse",
            "x": 0,
            "y": 0,
            "width": 100,
            "height": 100
        });
        gridImg = svgdoc.createElementNS($.svg.svgNS, "image");
        $svg.change(gridImg, {
            "x": 0,
            "y": 0,
            "width": 100,
            "height": 100
        });
        gridPattern.appendChild(gridImg);
        $defs.appendChild(gridPattern);
        var gridBox = svgdoc.createElementNS($.svg.svgNS, "rect");
        $svg.change(gridBox, {
            "width": "100%",
            "height": "100%",
            "x": 0,
            "y": 0,
            "stroke-width": 0.5,
            "stroke": "#fff",
            "fill": "url(#gridpattern)",
            "style": "pointer-events: none; display:visible;"
        });
        grid.appendChild(gridBox)
    }

    function initCanvas() {
        hcanvas = document.createElement("canvas");
        $(hcanvas).hide().appendTo("body")
    }
    canvasgrid.init = function() {
        if (!canvasgrid.isSupport() || initialized) {
            return
        }
        $topo = $.topology;
        $ge = $topo.graphEngine;
        $svg = $ge.svg;
        $defs = $ge.defs;
        svgdoc = $svg.root().ownerDocument;
        initCanvas();
        addGrid();
        $($ge.canvas).on("change", canvasgrid.updateGrid);
        initialized = true
    };
    canvasgrid.reset = function() {
        if (showGrid && initialized) {
            removeGrid();
            addGrid();
            canvasgrid.updateGrid()
        }
    };
    canvasgrid.isShow = function() {
        return showGrid
    };
    canvasgrid.isSupport = function() {
        return !!document.createElement("canvas").getContext
    };

    function updateCanvBGTransform(zoom) {
        var translate = $topo.view.translate();
        $svg.change(canvBG, {
            "x": translate.x * zoom,
            "y": translate.y * zoom,
            "width": $topo.view.getWidth() * zoom,
            "height": $topo.view.getHeight() * zoom
        })
    }

    function getGridSize(zoom) {
        var u_multi = zoom;
        var raw_m = 100 / u_multi;
        var multi = 1;
        for (var i = 0; i < intervals.length; i++) {
            var num = intervals[i];
            multi = num;
            if (raw_m <= num) {
                break
            }
        }
        var big_int = multi * u_multi;
        return big_int / 10
    }

    function updateGrid(zoom) {
        var part = getGridSize(zoom);
        var big_int = part * 10;
        hcanvas.width = big_int;
        hcanvas.height = big_int;
        var ctx2d = hcanvas.getContext("2d");
        var cur_d = 0.5;
        ctx2d.globalAlpha = 0.5;
        ctx2d.strokeStyle = gridColor;
        for (var i = 1; i < 10; i++) {
            var sub_d = Math.round(part * i) + 0.5;
            var line_num = 0;
            ctx2d.moveTo(sub_d, big_int);
            ctx2d.lineTo(sub_d, line_num);
            ctx2d.moveTo(big_int, sub_d);
            ctx2d.lineTo(line_num, sub_d)
        }
        ctx2d.stroke();
        ctx2d.beginPath();
        ctx2d.globalAlpha = 0.9;
        ctx2d.moveTo(cur_d, big_int);
        ctx2d.lineTo(cur_d, 0);
        ctx2d.moveTo(big_int, cur_d);
        ctx2d.lineTo(0, cur_d);
        ctx2d.stroke();
        var datauri = hcanvas.toDataURL("image/png");
        gridImg.setAttribute("width", big_int);
        gridImg.setAttribute("height", big_int);
        gridImg.parentNode.setAttribute("width", big_int);
        gridImg.parentNode.setAttribute("height", big_int);
        gridImg.setAttributeNS($.svg.xlinkNS, "xlink:href", datauri)
    }
    canvasgrid.updateGrid = function() {
        if (showGrid) {
            var zoom = $topo.view.scale();
            updateGrid(zoom);
            updateCanvBGTransform(zoom)
        }
    };
    canvasgrid.gridColor = function(x) {
        if (!arguments.length) {
            return gridColor
        }
        if (x) {
            gridColor = x
        }
    };
    canvasgrid.getGridSize = function() {
        var zoom = $.topology.view.scale();
        return getGridSize(zoom)
    };
    canvasgrid.show = function() {
        if (!initialized) {
            canvasgrid.init()
        }
        if (initialized) {
            showGrid = true;
            addGrid();
            canvasgrid.updateGrid();
            $("#view_background").attr("opacity", 0)
        }
    };
    canvasgrid.hide = function() {
        if (showGrid && initialized) {
            showGrid = false;
            $("#view_background").attr("opacity", 1);
            removeGrid()
        }
    };
    canvasgrid.toggle = function(showOrHide) {
        if (!arguments.length) {
            showOrHide = !showGrid
        }
        if (showOrHide) {
            canvasgrid.show()
        } else {
            canvasgrid.hide()
        }
    };
    return canvasgrid
};
// /hy.topology.engine.SVGCoverage
hy.topology.engine.SVGCoverage = function() {
    this._coverageContainer = null;
    this._init.apply(this, arguments)
};
hy.topology.engine.SVGCoverage.prototype = {
    getCoverageById: function(id) {
        if (id.search(/coverage_/gi) !== -1) {
            return this._coverageContainer[id]
        } else {
            return $.topology.graphEngine.svg.getElementById(id)
        }
    },
    up: function(element) {
        var $topo = $.topology,
            obj = null,
            nextObj = null,
            parentElement = null,
            nextElement = null;
        if ($.type(element) === "string") {
            obj = $topo.find(element);
            element = $topo.graphEngine.findBlock(element)
        } else {
            obj = element;
            element = $topo.graphEngine.findBlock(obj.id)
        }
        parentElement = element.parentNode;
        nextElement = this._getNextSibling(element);
        if (!nextElement) {
            return
        }
        nextObj = $topo.find(nextElement.getAttribute("id").replace("block_", ""));
        var _tU = this._getNextSibling(element),
            _tN = this._getNextSibling(nextElement);
        if (_tU) {
            parentElement.insertBefore(nextElement, _tU)
        } else {
            parentElement.appendChild(nextElement)
        }
        if (_tN) {
            parentElement.insertBefore(element, _tN)
        } else {
            parentElement.appendChild(element)
        }
        var tmpCoverage = obj.style["coverage"];
        obj.style["coverage"] = nextObj.style["coverage"];
        nextObj.style["coverage"] = tmpCoverage
    },
    down: function(element) {
        var $topo = $.topology,
            obj = null,
            previousObj = null,
            parentElement = null,
            previousElement = null;
        if ($.type(element) === "string") {
            obj = $topo.find(element);
            element = $topo.graphEngine.findBlock(element)
        } else {
            obj = element;
            element = $topo.graphEngine.findBlock(obj.id)
        }
        parentElement = element.parentNode;
        previousElement = this._getPreviousSibling(element);
        if (!previousElement) {
            return
        }
        previousObj = $topo.find(previousElement.getAttribute("id").replace(
            "block_", ""));
        var _tD = this._getPreviousSibling(element),
            _tP = this._getPreviousSibling(previousElement);
        if (_tD) {
            parentElement.insertBefore(previousElement, _tD)
        } else {
            parentElement.appendChild(previousElement)
        }
        if (_tP) {
            parentElement.insertBefore(element, _tP)
        } else {
            parentElement.appendChild(element)
        }
        var tmpCoverage = obj.style["coverage"];
        obj.style["coverage"] = previousObj.style["coverage"];
        previousObj.style["coverage"] = tmpCoverage
    },
    up2Top: function(element) {
        var parentElement = null;
        if ($.type(element) === "string") {
            element = $.topology.graphEngine.findBlock(element)
        }
        parentElement = element.parentNode;
        parentElement.appendChild(element);
        this.reset(element)
    },
    down2Bottom: function(element) {
        var parentElement = null,
            firstElement = null;
        if ($.type(element) === "string") {
            element = $.topology.graphEngine.findBlock(element)
        }
        parentElement = element.parentNode;
        parentElement.removeChild(element);
        firstElement = parentElement.firstChild;
        parentElement.insertBefore(element, firstElement);
        this.reset(element)
    },
    reset: function(element) {
        if (!element) {
            return
        }
        var parentElement = element.parentNode,
            count = 1,
            node = null,
            obj = null,
            _f_find = $.topology.find;
        for (var i = 0, len = parentElement.childNodes.length; i < len; i++) {
            node = parentElement.childNodes.item(i);
            if (node.nodeType !== 1) {
                continue
            }
            obj = _f_find(node.getAttribute("id").replace("block_", ""));
            obj.style["coverage"] = count;
            count++
        }
        return count
    },
    dragNode: function(node) {
        if (!node) {
            return
        }
        8431

        var $ge = $.topology.graphEngine,
            $svg = $ge.svg,
            element = $ge.findBlock(node.id);
        $svg.remove(element);
        $svg.add(this.getCoverageById("coverage_70"), element)
    },
    dropNode: function(node) {
        if (!node) {
            return
        }
        var $ge = $.topology.graphEngine,
            $svg = $ge.svg,
            _f_add = $svg.add,
            _f_remove = $svg.remove,
            element = $ge.findBlock(node.id),
            isDropInCtn = node.parent ? true : false,
            intoCoverage = "coverage_",
            relLineIntoCoverage = "coverage_",
            relLineseterIntoCoverage = "coverage_";
        if (!isDropInCtn) {
            intoCoverage += "50";
            relLineIntoCoverage += "40";
            relLineseterIntoCoverage += "41"
        } else {
            intoCoverage += "63";
            relLineIntoCoverage += "61";
            relLineseterIntoCoverage += "62"
        }
        _f_remove(element);
        _f_add.call($svg, this.getCoverageById(intoCoverage), element);
        var relLine = null,
            isLine = false,
            isLineFun = $.topology.isLine;
        for (var id in node.lines) {
            relLine = node.lines[id];
            isLine = isLineFun(relLine);
            element = $ge.findBlock(id);
            _f_remove(element);
            _f_add.call($svg, this.getCoverageById(isLine ? relLineIntoCoverage : relLineseterIntoCoverage), element)
        }
    },
    _init: function() {
        this._coverageContainer = [];
        var prefix = "coverage_",
            $svg = $.topology.graphEngine.svg,
            _f_group = $svg.group,
            background = _f_group.call($svg, "background"),
            root = _f_group.call($svg, "root"),
            view = _f_group.call($svg, root, "view"),
            viewBackground = _f_group.call($svg, view, "view_background"),
            viewMain = _f_group.call($svg, view, "view_main"),
            layer = [prefix + "10", prefix + "20", prefix + "30", prefix + "40", prefix + "41", prefix + "50",
                prefix + "60", prefix + "61", prefix + "62", prefix + "63", prefix + "64", prefix + "70",
                prefix + "71", prefix + "75", prefix + "80", prefix + "90"
            ];
        for (var i = 0, len = layer.length; i < len; i++) {
            if (layer[i] == prefix + "10") {
                this._coverageContainer[layer[i]] = _f_group.call($svg, viewBackground, layer[i])
            } else {
                this._coverageContainer[layer[i]] = _f_group.call($svg, viewMain, layer[i])
            }
        }
    },
    _getNextSibling: function(element) {
        var nextElement = element.nextSibling;
        while (nextElement && nextElement.nodeType !== 1) {
            nextElement = nextElement.nextSibling
        }
        return nextElement
    },
    _getPreviousSibling: function(element) {
        var previousElement = element.previousSibling;
        while (previousElement && previousElement.nodeType !== 1) {
            previousElement = previousElement.previousSibling
        }
        return previousElement
    }
};
// /hy.topology.engine.SVGAnimation
hy.topology.engine.SVGAnimation = function() {
    this.options = {
        "interval": 10,
        "flash": 500,
        "fadeOut": 1000,
        "fadeIn": 1000,
        "move": 1000,
        "scale": 400,
        "color": 800,
        "transform": 1000
    }
};
hy.topology.engine.SVGAnimation.prototype = {
    fade: function(element, type, duration, onComplete) {
        if (!element) {
            return
        }
        if ($.type(element) === "string") {
            element = $.topology.find(element)
        }
        var $ge = $.topology.graphEngine,
            _f_change = $ge.svg.change,
            block = $ge.findBlock(element.id),
            isOut = type === "out",
            times = parseInt((duration ? duration : (isOut ? this.options.fadeOut : this.options.fadeIn)) / this.options.interval),
            offset = isOut ? 0 : 1,
            step = 1 / times,
            intervalId = null,
            count = 0;
        intervalId = setInterval(function() {
            if (count === times) {
                clearInterval(intervalId);
                _f_change(block, {
                    "opacity": offset
                });
                if (onComplete && $.isFunction(onComplete)) {
                    onComplete.call()
                }
            } else {
                count++;
                _f_change(block, {
                    "opacity": step * count
                })
            }
        }, this.options.interval)
    },
    move: function(element, offsetX, offsetY, duration, onComplete) {
        if (!element) {
            return
        }
        if ($.type(element) === "string") {
            element = $.topology.find(element)
        }
        var $topo = $.topology,
            _f_refreshSelector = $topo.selector.refresh,
            times = parseInt((duration ? duration : this.options.move) / this.options.interval),
            stepX = offsetX !== 0 ? (offsetX / times) : 0,
            stepY = offsetY !== 0 ? (offsetY / times) : 0,
            toX = element.x + offsetX,
            toY = element.y + offsetY,
            intervalId = null,
            isSelected = ($topo.selector.symbols().length + $topo.selector.containers().length) >= 1,
            count = 0;
        intervalId = setInterval(
            function() {
                if (count === times) {
                    clearInterval(intervalId);
                    var ele = $topo.graphEngine.svg.getElementById(element.id),
                        currX = parseInt(ele.getAttribute("x")),
                        currY = parseInt(ele.getAttribute("y"));
                    element.move(offsetX !== 0 ? (toX - currX) : 0, offsetY !== 0 ? (currY - toY) : 0);
                    element.moveOver();
                    if (isSelected) {
                        $topo.selector.refresh()
                    }
                    if (onComplete && $.isFunction(onComplete)) {
                        onComplete.call()
                    }
                } else {
                    count++;
                    element.move(stepX, stepY);
                    if (isSelected) {
                        _f_refreshSelector()
                    }
                }
            }, this.options.interval)
    },
    scale: function(element, type, params, duration, onComplete) {
        if (!element) {
            return
        }
        var $svg = $.topology.graphEngine.svg,
            _f_gebi = $svg.getElementById,
            _f_change = $svg.change,
            times = parseInt((duration ? duration : this.options.scale) / this.options.interval),
            intervalId = null,
            param = null,
            offset = 0,
            count = 0,
            currValue = 0,
            offset = 0;
        if ($.type(element) === "string") {
            element = _f_gebi.call($svg, element)
        } else {
            element = _f_gebi.call($svg, element.id)
        }
        for (var i = 0, len = params.length; i < len; i++) {
            param = params[i];
            currValue = Number(element.getAttribute(param.attr));
            offset = type === "scale" ? (currValue * Number(param.value) - currValue) : Number(param.value);
            param["original"] = currValue;
            param["step"] = offset / times
        }
        intervalId = setInterval(function() {
            if (count === times) {
                clearInterval(intervalId);
                if (onComplete && $.isFunction(onComplete)) {
                    onComplete.call()
                }
                return
            }
            count++;
            var _opt = {};
            for (var i = 0, len = params.length; i < len; i++) {
                _opt[params[i].attr] = params[i].original + params[i].step * count
            }
            _f_change(element, _opt)
        }, this.options.interval)
    },
    color: function(element, isGradient, params, duration, onComplete) {
        if (!element) {
            return
        }
        var $svg = $.topology.graphEngine.svg,
            _f_gebi = $svg.getElementById,
            _f_change = $svg.change,
            _f_colorGradient = $.color.gradient,
            times = parseInt((duration ? duration : this.options.color) / (isGradient ? this.options.interval : this.options.flash)),
            intervalId = null,
            param = null,
            count = 0;
        if ($.type(element) === "string") {
            element = _f_gebi.call($svg, element)
        } else {
            element = _f_gebi.call($svg, element.id)
        }
        for (var i = 0, len = params.length; i < len; i++) {
            param = params[i];
            param["original"] = element.getAttribute(param.attr);
            param["step"] = isGradient ? _f_colorGradient(param["original"],
                param.value, times) : [param.value]
        }
        intervalId = setInterval(function() {
            if (count === times) {
                clearInterval(intervalId);
                if (onComplete && $.isFunction(onComplete)) {
                    onComplete.call()
                }
                return
            }
            count++;
            var _opt = {};
            for (var i = 0, len = params.length; i < len; i++) {
                if (isGradient) {
                    _opt[params[i].attr] = params[i].step[count]
                } else {
                    if (count % 2 === 0) {
                        _opt[params[i].attr] = params[i].original
                    } else {
                        _opt[params[i].attr] = params[i].step[0]
                    }
                }
            }
            _f_change(element, _opt)
        }, (isGradient ? this.options.interval : this.options.flash))
    },
    transform: function(element, params, duration, onComplete) {
        if (!element) {
            return
        }
        var $svg = $.topology.graphEngine.svg,
            _f_gebi = $svg.getElementById,
            _f_change = $svg.change,
            times = parseInt((duration ? duration : this.options.transform) / this.options.interval),
            intervalId = null,
            param = null,
            count = 0;
        if ($.type(element) === "string") {
            element = _f_gebi.call($svg, element)
        } else {
            element = _f_gebi.call($svg, element.id)
        }
        for (var i = 0, len = params.length; i < len; i++) {
            param = params[i];
            param["original"] = element.getAttribute(param.attr);
            param["step"] = Number(param.value) / times
        }
        intervalId = setInterval(function() {
            if (count === times) {
                clearInterval(intervalId);
                var _opt = {};
                for (var i = 0, len = params.length; i < len; i++) {
                    _opt[params[i].attr] = params[i].original + params[i].value
                }
                _f_change(element, _opt);
                if (onComplete && $.isFunction(onComplete)) {
                    onComplete.call()
                }
            } else {
                count++;
                var _opt = {};
                for (var i = 0, len = params.length; i < len; i++) {
                    _opt[params[i].attr] = params[i].original + params[i].step * count
                }
                _f_change(element, _opt)
            }
        }, this.options.interval)
    }
};
// /hy.topology.engine.SVGSelector
hy.topology.engine.SVGSelector = function() {
    this.group = null;
    this.grid = null;
    this.gridBorder = null;
    this.gridPathPoints = null;
    this.gripPointObjects = {
        "n": null,
        "s": null,
        "w": null,
        "e": null,
        "nw": null,
        "ne": null,
        "sw": null,
        "se": null
    };
    this.gripPointCoords = {
        "n": {},
        "s": {},
        "w": {},
        "e": {},
        "nw": {},
        "ne": {},
        "sw": {},
        "se": {}
    };
    this.focusBox = null;
    this.selectBox = [];
    this.option = { //选择框样式
        "gridStyle": {
            "fill": "none",
            "stroke": "#cccccc",
            "stroke-opacity": "0.8",
            "stroke-width": "1",
            "stroke-dasharray": "5,5",
            "style": "pointer-events:none"
        },
        "gridBorderStyle": {
            "fill": "none",
            "stroke": "#ffffff",
            "stroke-width": "2",
            "stroke-opacity": "0.8",
            "style": "pointer-events:none"
        },
        "gripStyle": {
            "fill": "#cccccc",
            "fill-opacity": "0.8",
            "stroke": "#ffffff",
            "stroke-width": "1",
            "stroke-opacity": "0.8"
        },
        "focusStyle": {
            "fill": "none",
            "stroke": "#aaaaaa",
            "stroke-width": "2",
            "stroke-opacity": "0.8",
            "style": "pointer-events:none"
        },
        "gridSpace": 4,
        "gripWidth": 6,
        "gripHeight": 6,
        "gripR": 2
    };
    this.init.apply(this, arguments)
};
hy.topology.engine.SVGSelector.prototype = {
    init: function() {
        var $ge = $.topology.graphEngine;
        if ($ge.isDrew("selector")) {
            return
        }
        var $svg = $ge.svg;
        this.group = $svg.group($ge.coverage.getCoverageById("coverage_71"),
            "selector", {
                "display": "none"
            });
        this.gridBorder = $svg.path(this.group, "M0,0 L0,0", $.extend(
            this.option.gridBorderStyle, {
                "id": "selector_gridborder"
            }));
        this.grid = $svg.path(this.group, "M0,0 L0,0", $.extend(
            this.option.gridStyle, {
                "id": "selector_grid"
            }));
        this.focusBox = $svg.rect($ge.coverage.getCoverageById("coverage_60"),
            0, 0, 0, 0, 2, 2, $.extend(this.option.focusStyle, {
                "id": "selector_focus",
                "display": "none"
            }));
        for (var id in this.gripPointObjects) {
            this.gripPointObjects[id] = this.gripPoint("selector_" + id)
        }
    },
    resize: function() {
        var selected = $.topology.selector.selected(),
            selectedNodeCount = selected.symbols.length + selected.containers.length;
        if (selectedNodeCount === 0 || !selected.focus) {
            return
        }
        var $topo = $.topology,
            $ge = $topo.graphEngine,
            $svg = $ge.svg,
            _f_find = $topo.find,
            _f_rect = $svg.rect,
            _f_svgChange = $svg.change,
            isMultiSelected = selectedNodeCount > 1,
            maxX = 0,
            maxY = 0,
            minX = 99999,
            minY = 99999,
            i = 0,
            len = 0,
            _mx = 0,
            _my = 0,
            obj = null,
            selBox = null,
            gridStrokeWidth = Number(this.option.gridStyle["stroke-width"]);
        if (isMultiSelected) {
            for (len = selected.symbols.length; i < len; i++) {
                obj = _f_find(selected.symbols[i], "symbol");
                _mx = obj.x + parseInt(obj.style["icon-width"]);
                _my = obj.y + parseInt(obj.style["icon-height"]);
                maxX = Math.max(_mx, maxX);
                maxY = Math.max(_my, maxY);
                minX = Math.min(obj.x, minX);
                minY = Math.min(obj.y, minY);
                if ($ge.isDrew("selector_" + obj.id)) {
                    for (var j = 0, boxLen = this.selectBox.length; j < boxLen; j++) {
                        if (this.selectBox[j].getAttribute("id") === ("selector_" + obj.id)) {
                            selBox = this.selectBox[j];
                            break
                        }
                    }
                    _f_svgChange(selBox, {
                        "x": (obj.x - 2),
                        "y": (obj.y - 2),
                        "width": (_mx - obj.x + 4),
                        "height": (_my - obj.y + 4)
                    })
                } else {
                    selBox = _f_rect.call($svg, this.group, (obj.x - 2),
                        (obj.y - 2), (_mx - obj.x + 4), (_my - obj.y + 4),
                        2, 2, $.extend(this.option.focusStyle, {
                            "stroke-width": "1",
                            "display": "inline",
                            "id": "selector_" + obj.id
                        }));
                    this.selectBox.push(selBox)
                }
            }
            i = 0, len = 0;
            for (len = selected.containers.length; i < len; i++) {
                obj = _f_find(selected.containers[i], "container");
                if (obj.isExpand) {
                    _mx = obj.expandX + obj.expandWidth;
                    _my = obj.expandY + obj.expandHeight;
                    minX = Math.min(obj.expandX, minX);
                    minY = Math.min(obj.expandY, minY);
                    if ($ge.isDrew("selector_" + obj.id)) {
                        for (var j = 0, boxLen = this.selectBox.length; j < boxLen; j++) {
                            if (this.selectBox[j].getAttribute("id") === ("selector_" + obj.id)) {
                                selBox = this.selectBox[j];
                                break
                            }
                        }
                        _f_svgChange(selBox, {
                            "x": (obj.expandX - 2),
                            "y": (obj.expandY - 2),
                            "width": (obj.expandWidth + 4),
                            "height": (obj.expandHeight + 4)
                        })
                    } else {
                        selBox = _f_rect.call($svg, this.group,
                            (obj.expandX - 2), (obj.expandY - 2),
                            (obj.expandWidth + 4), (obj.expandHeight + 4),
                            2, 2, $.extend(this.option.focusStyle, {
                                "stroke-width": "1",
                                "display": "inline",
                                "id": "selector_" + obj.id
                            }));
                        this.selectBox.push(selBox)
                    }
                } else {
                    _mx = obj.x + parseInt(obj.style["icon-width"]);
                    _my = obj.y + parseInt(obj.style["icon-height"]);
                    minX = Math.min(obj.x, minX);
                    minY = Math.min(obj.y, minY);
                    if ($ge.isDrew("selector_" + obj.id)) {
                        for (var j = 0, boxLen = this.selectBox.length; j < boxLen; j++) {
                            if (this.selectBox[j].getAttribute("id") === ("selector_" + obj.id)) {
                                selBox = this.selectBox[j];
                                break
                            }
                        }
                        _f_svgChange(selBox, {
                            "x": (obj.x - 2),
                            "y": (obj.y - 2),
                            "width": (_mx - obj.x + 4),
                            "height": (_my - obj.y + 4)
                        })
                    } else {
                        selBox = _f_rect.call($svg, this.group, (obj.x - 2), (obj.y - 2), (_mx - obj.x + 4),
                            (_my - obj.y + 4), 2, 2, $.extend(this.option.focusStyle, { "stroke-width": "1", "display": "inline", "id": "selector_" + obj.id }));
                        this.selectBox.push(selBox)
                    }
                }
                maxX = Math.max(_mx, maxX);
                maxY = Math.max(_my, maxY)
            }
            obj = selected.focus;
            if (obj instanceof hy.topology.model.Symbol) {
                _f_svgChange(this.focusBox, {
                    "x": obj.x - 2,
                    "y": obj.y - 2,
                    "width": parseInt(obj.style["icon-width"]) + 4,
                    "height": parseInt(obj.style["icon-height"]) + 4,
                    "display": "inline"
                })
            } else {
                if (obj instanceof hy.topology.model.Container) {
                    if (obj.isExpand) {
                        _f_svgChange(this.focusBox, {
                            "x": obj.expandX - 2,
                            "y": obj.expandY - 2,
                            "width": obj.expandWidth + 4,
                            "height": obj.expandHeight + 4,
                            "display": "inline"
                        })
                    } else {
                        _f_svgChange(this.focusBox, {
                            "x": obj.x - 2,
                            "y": obj.y - 2,
                            "width": parseInt(obj.style["icon-width"]) + 4,
                            "height": parseInt(obj.style["icon-height"]) + 4,
                            "display": "inline"
                        })
                    }
                }
            }
        } else {
            obj = selected.focus;
            if (obj instanceof hy.topology.model.Symbol) {
                minX = obj.x;
                minY = obj.y;
                maxX = obj.x + parseInt(obj.style["icon-width"]);
                maxY = obj.y + parseInt(obj.style["icon-height"])
            } else {
                if (obj instanceof hy.topology.model.Container) {
                    if (obj.isExpand) {
                        minX = obj.expandX;
                        minY = obj.expandY;
                        maxX = obj.expandX + obj.expandWidth;
                        maxY = obj.expandY + obj.expandHeight
                    } else {
                        minX = obj.x;
                        minY = obj.y;
                        maxX = obj.x + parseInt(obj.style["icon-width"]);
                        maxY = obj.y + parseInt(obj.style["icon-height"])
                    }
                }
            }
        }
        minX -= this.option.gridSpace;
        minY -= this.option.gridSpace;
        maxX += this.option.gridSpace;
        maxY += this.option.gridSpace;
        var pathPoints = [],
            halfGridWidth = gridStrokeWidth / 2;
        pathPoints[0] = [], pathPoints[1] = [], pathPoints[2] = [], pathPoints[3] = [], pathPoints[4] = [];
        pathPoints[0][0] = minX - halfGridWidth;
        pathPoints[0][1] = minY - halfGridWidth;
        pathPoints[1][0] = maxX + halfGridWidth;
        pathPoints[1][1] = minY - halfGridWidth;
        pathPoints[2][0] = maxX + halfGridWidth;
        pathPoints[2][1] = maxY + halfGridWidth;
        pathPoints[3][0] = minX - halfGridWidth;
        pathPoints[3][1] = maxY + halfGridWidth;
        pathPoints[4][0] = pathPoints[0][0];
        pathPoints[4][1] = pathPoints[0][1];
        this.gridPathPoints = pathPoints;
        var gridPath = $ge.path(pathPoints);
        _f_svgChange(this.grid, { "d": gridPath });
        _f_svgChange(this.gridBorder, { "d": gridPath });
        maxX += gridStrokeWidth / 2;
        maxY += gridStrokeWidth / 2;
        minX -= gridStrokeWidth / 2;
        minY -= gridStrokeWidth / 2;
        var halfGripWidth = this.option.gripWidth / 2;
        this.gripPointCoords["n"].x = (maxX - minX) / 2 + minX - halfGripWidth;
        this.gripPointCoords["n"].y = minY - halfGripWidth;
        _f_svgChange(this.gripPointObjects["n"], {
            "x": this.gripPointCoords["n"].x,
            "y": this.gripPointCoords["n"].y
        });
        this.gripPointCoords["s"].x = (maxX - minX) / 2 + minX - halfGripWidth;
        this.gripPointCoords["s"].y = maxY - halfGripWidth;
        _f_svgChange(this.gripPointObjects["s"], {
            "x": this.gripPointCoords["s"].x,
            "y": this.gripPointCoords["s"].y
        });
        this.gripPointCoords["w"].x = minX - halfGripWidth;
        this.gripPointCoords["w"].y = (maxY - minY) / 2 + minY - halfGripWidth;
        _f_svgChange(this.gripPointObjects["w"], {
            "x": this.gripPointCoords["w"].x,
            "y": this.gripPointCoords["w"].y
        });
        this.gripPointCoords["e"].x = maxX - halfGripWidth;
        this.gripPointCoords["e"].y = (maxY - minY) / 2 + minY - halfGripWidth;
        _f_svgChange(this.gripPointObjects["e"], {
            "x": this.gripPointCoords["e"].x,
            "y": this.gripPointCoords["e"].y
        });
        this.gripPointCoords["nw"].x = minX - halfGripWidth;
        this.gripPointCoords["nw"].y = minY - halfGripWidth;
        _f_svgChange(this.gripPointObjects["nw"], {
            "x": this.gripPointCoords["nw"].x,
            "y": this.gripPointCoords["nw"].y
        });
        this.gripPointCoords["ne"].x = maxX - halfGripWidth;
        this.gripPointCoords["ne"].y = minY - halfGripWidth;
        _f_svgChange(this.gripPointObjects["ne"], {
            "x": this.gripPointCoords["ne"].x,
            "y": this.gripPointCoords["ne"].y
        });
        this.gripPointCoords["sw"].x = minX - halfGripWidth;
        this.gripPointCoords["sw"].y = maxY - halfGripWidth;
        _f_svgChange(this.gripPointObjects["sw"], {
            "x": this.gripPointCoords["sw"].x,
            "y": this.gripPointCoords["sw"].y
        });
        this.gripPointCoords["se"].x = maxX - halfGripWidth;
        this.gripPointCoords["se"].y = maxY - halfGripWidth;
        _f_svgChange(this.gripPointObjects["se"], {
            "x": this.gripPointCoords["se"].x,
            "y": this.gripPointCoords["se"].y
        });
        if (this.group.getAttribute("display") === "none") {
            _f_svgChange(this.group, {
                "display": "inline"
            })
        }
    },
    reset: function() {
        var $svg = $.topology.graphEngine.svg,
            _f_svgRemove = $svg.remove;
        $svg.change(this.focusBox, {
            "display": "none"
        });
        $svg.change(this.group, {
            "display": "none"
        });
        for (var i = 0, len = this.selectBox.length; i < len; i++) {
            _f_svgRemove(this.selectBox[i])
        }
        this.selectBox.length = 0
    },
    gripPoint: function(id) {
        var point = $.topology.graphEngine.svg.rect(this.group, 0, 0,
            this.option.gripWidth, this.option.gripHeight,
            this.option.gripR, this.option.gripR,
            $.extend(this.option.gripStyle, {
                "id": id,
                // "style" : $.topology.status === "EDIT" ? ("cursor: " +
                // id.replace(/selector_/i, "") + "-resize;") : ""
                "style": "cursor: " + id.replace(/selector_/i, "") + "-resize;"
            }));
        // if ($.topology.status === "EDIT") {
        this.bindDrawGripPointEvent(id.replace(/selector_/i, ""))
        // }
        return point
    },
    dragGripPoint: function(e, id) {
        var viewBox = $.topology.view.getViewBox(),
            $ge = $.topology.graphEngine,
            mousePoint = $ge.canvas.coordinateConvert.page2Canvas(e.pageX, e.pageY),
            vertex = mousePoint,
            mouseBBox = {
                minX: viewBox.x,
                minY: viewBox.y,
                maxX: viewBox.x + viewBox.width,
                maxY: viewBox.y + viewBox.height
            },
            mouseOffset = $ge.edgeDetect([mousePoint.x, mousePoint.y, mousePoint.x, mousePoint.y], [mouseBBox.minX, mouseBBox.minY, mouseBBox.maxX, mouseBBox.maxY]),
            gripPoint = this.gripPointObjects[id];
        if (mouseOffset.x > 0) {
            vertex.x = viewBox.x
        } else {
            if (mouseOffset.x < 0) {
                vertex.x = viewBox.x + viewBox.width
            }
        }
        if (mouseOffset.y > 0) {
            vertex.y = viewBox.y
        } else {
            if (mouseOffset.y < 0) {
                vertex.y = viewBox.y + viewBox.height
            }
        }
        if (id === "nw") {
            if (vertex.x > (this.gripPointCoords["se"].x - this.option.gripWidth)) {
                vertex.x = this.gripPointCoords["se"].x - this.option.gripWidth
            }
            if (vertex.y > (this.gripPointCoords["se"].y - this.option.gripHeight)) {
                vertex.y = this.gripPointCoords["se"].y - this.option.gripHeight
            }
        } else {
            if (id === "se") {
                if (vertex.x < (this.gripPointCoords["nw"].x + this.option.gripWidth * 2)) {
                    vertex.x = this.gripPointCoords["nw"].x + this.option.gripWidth * 2
                }
                if (vertex.y < (this.gripPointCoords["nw"].y + this.option.gripHeight * 2)) {
                    vertex.y = this.gripPointCoords["nw"].y + this.option.gripHeight * 2
                }
            } else {
                if (id === "ne") {
                    if (vertex.x < (this.gripPointCoords["sw"].x + this.option.gripWidth * 2)) {
                        vertex.x = this.gripPointCoords["sw"].x + this.option.gripWidth * 2
                    }
                    if (vertex.y > (this.gripPointCoords["sw"].y - this.option.gripHeight)) {
                        vertex.y = this.gripPointCoords["sw"].y - this.option.gripHeight
                    }
                } else {
                    if (id === "sw") {
                        if (vertex.x > (this.gripPointCoords["ne"].x - this.option.gripWidth)) {
                            vertex.x = this.gripPointCoords["ne"].x - this.option.gripWidth
                        }
                        if (vertex.y < (this.gripPointCoords["ne"].y + this.option.gripHeight * 2)) {
                            vertex.y = this.gripPointCoords["ne"].y + this.option.gripHeight * 2
                        }
                    } else {
                        if (id === "n") {
                            vertex.x = this.gripPointCoords["n"].x;
                            if (vertex.y > (this.gripPointCoords["s"].y - this.option.gripHeight)) {
                                vertex.y = this.gripPointCoords["s"].y - this.option.gripHeight
                            }
                        } else {
                            if (id === "s") {
                                vertex.x = this.gripPointCoords["s"].x;
                                if (vertex.y < (this.gripPointCoords["n"].y + this.option.gripHeight * 2)) {
                                    vertex.y = this.gripPointCoords["n"].y + this.option.gripHeight * 2
                                }
                            } else {
                                if (id === "w") {
                                    vertex.y = this.gripPointCoords["w"].y;
                                    if (vertex.x > (this.gripPointCoords["e"].x - this.option.gripWidth)) {
                                        vertex.x = this.gripPointCoords["e"].x - this.option.gripWidth
                                    }
                                } else {
                                    if (id === "e") {
                                        vertex.y = this.gripPointCoords["e"].y;
                                        if (vertex.x < (this.gripPointCoords["w"].x + this.option.gripWidth * 2)) {
                                            vertex.x = this.gripPointCoords["w"].x + this.option.gripWidth * 2
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return this.changeGripPoint(id, vertex)
    },
    _gpSymbolChange: function(symbol, id, offsetX, offsetY) {
        switch (id) {
            case "n":
            case "w":
            case "nw":
                symbol.x += offsetX;
                symbol.y += offsetY;
                symbol.setIconWidth(Number(symbol.style["icon-width"]) - offsetX);
                symbol.setIconHeight(Number(symbol.style["icon-height"]) - offsetY);
                break;
            case "s":
            case "e":
            case "se":
                symbol.setIconWidth(Number(symbol.style["icon-width"]) + offsetX);
                symbol.setIconHeight(Number(symbol.style["icon-height"]) + offsetY);
                break;
            case "ne":
                symbol.y += offsetY;
                symbol.setIconWidth(Number(symbol.style["icon-width"]) + offsetX);
                symbol.setIconHeight(Number(symbol.style["icon-height"]) - offsetY);
                break;
            case "sw":
                symbol.x += offsetX;
                symbol.setIconWidth(Number(symbol.style["icon-width"]) - offsetX);
                symbol.setIconHeight(Number(symbol.style["icon-height"]) + offsetY);
                break
        }
        symbol.change(true, true);
        if (symbol.parent) {
            symbol.updateParentSize()
        }
    },
    _gpContainerChange: function(container, id, offsetX, offsetY) {
        if (container.isExpand) {
            return
        }
        switch (id) {
            case "n":
            case "w":
            case "nw":
                container.x += offsetX;
                container.y += offsetY;
                container.setCollapseIconWidth(Number(container.style["icon-width"]) - offsetX);
                container.setCollapseIconHeight(Number(container.style["icon-height"]) - offsetY);
                break;
            case "s":
            case "e":
            case "se":
                container.setCollapseIconWidth(Number(container.style["icon-width"]) + offsetX);
                container.setCollapseIconHeight(Number(container.style["icon-height"]) + offsetY);
                break;
            case "ne":
                container.y += offsetY;
                container.setCollapseIconWidth(Number(container.style["icon-width"]) + offsetX);
                container.setCollapseIconHeight(Number(container.style["icon-height"]) - offsetY);
                break;
            case "sw":
                container.x += offsetX;
                container.setCollapseIconWidth(Number(container.style["icon-width"]) - offsetX);
                container.setCollapseIconHeight(Number(container.style["icon-height"]) + offsetY);
                break
        }
        container.change(true)
    },
    dropGripPoint: function(id, offsetX, offsetY) {
        var len = 0,
            i = 0,
            selected = $.topology.selector.selected(),
            _f_find = $.topology.find;
        if ((selected.symbols.length + selected.containers.length) > 1) {
            for (len = selected.symbols.length; i < len; i++) {
                this._gpSymbolChange(_f_find(selected.symbols[i], "symbol"), id, offsetX, offsetY)
            }
            i = 0, len = 0;
            for (len = selected.containers.length; i < len; i++) {
                this._gpContainerChange(_f_find(selected.containers[i], "container"), id, offsetX, offsetY)
            }
        } else {
            if (selected.focus instanceof hy.topology.model.Symbol) {
                this._gpSymbolChange(selected.focus, id, offsetX, offsetY)
            } else {
                if (selected.focus instanceof hy.topology.model.Container) {
                    this._gpContainerChange(selected.focus, id, offsetX, offsetY)
                }
            }
        }
        this.resize()
    },
    changeGripPoint: function(id, vertex) {
        var $ge = $.topology.graphEngine,
            $svg = $ge.svg,
            _f_change = $svg.change,
            _width = 0,
            _height = 0,
            offsetX = 0,
            offsetY = 0,
            gridPath = null,
            halfGW = this.option.gripWidth / 2,
            halfGH = this.option.gripWidth / 2,
            _pathPoints = $.extend(true, [], this.gridPathPoints);
        if (id === "nw") {
            _pathPoints[3][0] = _pathPoints[4][0] = _pathPoints[0][0] = vertex.x;
            _pathPoints[1][1] = _pathPoints[4][1] = _pathPoints[0][1] = vertex.y;
            _width = _pathPoints[2][0] - _pathPoints[0][0];
            _height = _pathPoints[2][1] - _pathPoints[0][1];
            offsetX = vertex.x - this.gridPathPoints[0][0];
            offsetY = vertex.y - this.gridPathPoints[0][1];
            _f_change(this.gripPointObjects["nw"], {
                "x": vertex.x - halfGW,
                "y": vertex.y - halfGH
            });
            _f_change(this.gripPointObjects["n"], {
                "x": vertex.x + _width / 2 - halfGW,
                "y": vertex.y - halfGH
            });
            _f_change(this.gripPointObjects["w"], {
                "x": vertex.x - halfGW,
                "y": vertex.y + _height / 2 - halfGH
            });
            _f_change(this.gripPointObjects["s"], {
                "x": vertex.x + _width / 2 - halfGW
            });
            _f_change(this.gripPointObjects["sw"], {
                "x": vertex.x - halfGW
            });
            _f_change(this.gripPointObjects["e"], {
                "y": vertex.y + _height / 2 - halfGH
            });
            _f_change(this.gripPointObjects["ne"], {
                "y": vertex.y - halfGH
            })
        } else {
            if (id === "ne") {
                _pathPoints[2][0] = _pathPoints[1][0] = vertex.x;
                _pathPoints[0][1] = _pathPoints[4][1] = _pathPoints[1][1] = vertex.y;
                _width = _pathPoints[1][0] - _pathPoints[3][0];
                _height = _pathPoints[3][1] - _pathPoints[1][1];
                offsetX = vertex.x - this.gridPathPoints[1][0];
                offsetY = vertex.y - this.gridPathPoints[1][1];
                _f_change(this.gripPointObjects["ne"], {
                    "x": vertex.x - halfGW,
                    "y": vertex.y - halfGH
                });
                _f_change(this.gripPointObjects["n"], {
                    "x": vertex.x - _width / 2 - halfGW,
                    "y": vertex.y - halfGH
                });
                _f_change(this.gripPointObjects["e"], {
                    "x": vertex.x - halfGW,
                    "y": vertex.y + _height / 2 - halfGH
                });
                _f_change(this.gripPointObjects["s"], {
                    "x": vertex.x - _width / 2 - halfGW
                });
                _f_change(this.gripPointObjects["se"], {
                    "x": vertex.x - halfGW
                });
                _f_change(this.gripPointObjects["w"], {
                    "y": vertex.y + _height / 2 - halfGH
                });
                _f_change(this.gripPointObjects["nw"], {
                    "y": vertex.y - halfGH
                })
            } else {
                if (id === "sw") {
                    _pathPoints[3][0] = _pathPoints[4][0] = _pathPoints[0][0] = vertex.x;
                    _pathPoints[3][1] = _pathPoints[2][1] = vertex.y;
                    _width = _pathPoints[1][0] - _pathPoints[3][0];
                    _height = _pathPoints[3][1] - _pathPoints[1][1];
                    offsetX = vertex.x - this.gridPathPoints[3][0];
                    offsetY = vertex.y - this.gridPathPoints[3][1];
                    _f_change(this.gripPointObjects["sw"], {
                        "x": vertex.x - halfGW,
                        "y": vertex.y - halfGH
                    });
                    _f_change(this.gripPointObjects["w"], {
                        "x": vertex.x - halfGW,
                        "y": vertex.y - _height / 2 - halfGH
                    });
                    _f_change(this.gripPointObjects["s"], {
                        "x": vertex.x + _width / 2 - halfGW,
                        "y": vertex.y - halfGH
                    });
                    _f_change(this.gripPointObjects["n"], {
                        "x": vertex.x + _width / 2 - halfGW
                    });
                    _f_change(this.gripPointObjects["nw"], {
                        "x": vertex.x - halfGW
                    });
                    _f_change(this.gripPointObjects["e"], {
                        "y": vertex.y - _height / 2 - halfGH
                    });
                    _f_change(this.gripPointObjects["se"], {
                        "y": vertex.y - halfGH
                    })
                } else {
                    if (id === "se") {
                        _pathPoints[2][0] = _pathPoints[1][0] = vertex.x;
                        _pathPoints[2][1] = _pathPoints[3][1] = vertex.y;
                        _width = _pathPoints[2][0] - _pathPoints[3][0];
                        _height = _pathPoints[2][1] - _pathPoints[1][1];
                        offsetX = vertex.x - this.gridPathPoints[2][0];
                        offsetY = vertex.y - this.gridPathPoints[2][1];
                        _f_change(this.gripPointObjects["se"], {
                            "x": vertex.x - halfGW,
                            "y": vertex.y - halfGH
                        });
                        _f_change(this.gripPointObjects["s"], {
                            "x": vertex.x - _width / 2 - halfGW,
                            "y": vertex.y - halfGH
                        });
                        _f_change(this.gripPointObjects["e"], {
                            "x": vertex.x - halfGW,
                            "y": vertex.y - _height / 2 - halfGH
                        });
                        _f_change(this.gripPointObjects["n"], {
                            "x": vertex.x - _width / 2 - halfGW
                        });
                        _f_change(this.gripPointObjects["ne"], {
                            "x": vertex.x - halfGW
                        });
                        _f_change(this.gripPointObjects["w"], {
                            "y": vertex.y - _height / 2 - halfGH
                        });
                        _f_change(this.gripPointObjects["sw"], {
                            "y": vertex.y - halfGH
                        })
                    } else {
                        if (id === "n") {
                            _pathPoints[0][1] = _pathPoints[1][1] = _pathPoints[4][1] = vertex.y;
                            _height = _pathPoints[3][1] - _pathPoints[0][1];
                            offsetX = 0;
                            offsetY = vertex.y - this.gridPathPoints[0][1];
                            _f_change(this.gripPointObjects["n"], {
                                "y": vertex.y - halfGH
                            });
                            _f_change(this.gripPointObjects["nw"], {
                                "y": vertex.y - halfGH
                            });
                            _f_change(this.gripPointObjects["ne"], {
                                "y": vertex.y - halfGH
                            });
                            _f_change(this.gripPointObjects["w"], {
                                "y": _pathPoints[3][1] - _height / 2 - halfGH
                            });
                            _f_change(this.gripPointObjects["e"], {
                                "y": _pathPoints[2][1] - _height / 2 - halfGH
                            })
                        } else {
                            if (id === "s") {
                                _pathPoints[3][1] = _pathPoints[2][1] = vertex.y;
                                _height = _pathPoints[3][1] - _pathPoints[0][1];
                                offsetX = 0;
                                offsetY = vertex.y - this.gridPathPoints[3][1];
                                _f_change(this.gripPointObjects["s"], {
                                    "y": vertex.y - halfGH
                                });
                                _f_change(this.gripPointObjects["sw"], {
                                    "y": vertex.y - halfGH
                                });
                                _f_change(this.gripPointObjects["se"], {
                                    "y": vertex.y - halfGH
                                });
                                _f_change(this.gripPointObjects["w"], {
                                    "y": _pathPoints[3][1] - _height / 2 - halfGH
                                });
                                _f_change(this.gripPointObjects["e"], {
                                    "y": _pathPoints[2][1] - _height / 2 - halfGH
                                })
                            } else {
                                if (id === "w") {
                                    _pathPoints[0][0] = _pathPoints[3][0] = _pathPoints[4][0] = vertex.x;
                                    _width = _pathPoints[1][0] - _pathPoints[0][0];
                                    offsetX = vertex.x - this.gridPathPoints[0][0];
                                    offsetY = 0;
                                    _f_change(this.gripPointObjects["w"], {
                                        "x": vertex.x - halfGW
                                    });
                                    _f_change(this.gripPointObjects["nw"], {
                                        "x": vertex.x - halfGW
                                    });
                                    _f_change(this.gripPointObjects["sw"], {
                                        "x": vertex.x - halfGW
                                    });
                                    _f_change(this.gripPointObjects["n"], {
                                        "x": vertex.x + _width / 2 - halfGW
                                    });
                                    _f_change(this.gripPointObjects["s"], {
                                        "x": vertex.x + _width / 2 - halfGW
                                    })
                                } else {
                                    if (id === "e") {
                                        _pathPoints[1][0] = _pathPoints[2][0] = vertex.x;
                                        _width = _pathPoints[1][0] - _pathPoints[0][0];
                                        offsetX = vertex.x - this.gridPathPoints[1][0];
                                        offsetY = 0;
                                        _f_change(this.gripPointObjects["e"], { "x": vertex.x - halfGW });
                                        _f_change(this.gripPointObjects["ne"], { "x": vertex.x - halfGW });
                                        _f_change(this.gripPointObjects["se"], { "x": vertex.x - halfGW });
                                        _f_change(this.gripPointObjects["n"], {
                                            "x": vertex.x - _width / 2 - halfGW
                                        });
                                        _f_change(this.gripPointObjects["s"], {
                                            "x": vertex.x - _width / 2 - halfGW
                                        })
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        gridPath = $ge.path(_pathPoints);
        _f_change(this.grid, { "d": gridPath });
        _f_change(this.gridBorder, { "d": gridPath });
        return {
            "offsetX": offsetX,
            "offsetY": offsetY
        }
    },
    bindDrawGripPointEvent: function(id) {
        var $event = $.topology.graphEngine.event;
        $event.add("selector_" + id, "dragstart", dragstart);

        function dragstart(e) {
            if (e.button != 0) {
                return
            }
            var target = e.target,
                moved = 0,
                $selector = $.topology.graphEngine.selector,
                offset = null;
            $event.add(target.id, "drag", drag);
            $event.add(target.id, "dragend", dragend);

            function drag(e) {
                moved |= e.dx | e.dy;
                if (moved) {
                    offset = $selector.dragGripPoint(e, id)
                }
            }

            function dragend(e) {
                $event.remove(target.id, "drag", drag);
                $event.remove(target.id, "dragend", dragend);
                if (moved) {
                    $selector.dropGripPoint(id, offset.offsetX, offset.offsetY)
                }
            }
        }
    }
};

function extend(sub, base) {
    for (var ptototypeName in base.prototype) {
        if (typeof(sub.prototype[ptototypeName]) === "undefined") {
            sub.prototype[ptototypeName] = base.prototype[ptototypeName]
        }
    }
    sub.prototype.constructor = sub
};